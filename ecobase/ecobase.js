import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/elysia/node_modules/cookie/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse2;
  exports.serialize = serialize;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  var __toString = Object.prototype.toString;
  var NullObject = /* @__PURE__ */ (() => {
    const C = function() {};
    C.prototype = Object.create(null);
    return C;
  })();
  function parse2(str, options) {
    const obj = new NullObject;
    const len = str.length;
    if (len < 2)
      return obj;
    const dec = options?.decode || decode2;
    let index = 0;
    do {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      const colonIdx = str.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str, index, eqIdx);
      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      const key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str, endIdx, valStartIdx);
        const value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      const code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      const code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str += "; HttpOnly";
    }
    if (options.secure) {
      str += "; Secure";
    }
    if (options.partitioned) {
      str += "; Partitioned";
    }
    if (options.priority) {
      const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    }
    if (options.sameSite) {
      const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    }
    return str;
  }
  function decode2(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});

// node_modules/clone/clone.js
var require_clone = __commonJS((exports, module) => {
  var clone2 = function() {
    function _instanceof(obj, type2) {
      return type2 != null && obj instanceof type2;
    }
    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_) {
      nativeMap = function() {};
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_) {
      nativeSet = function() {};
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_) {
      nativePromise = function() {};
    }
    function clone3(parent, circular, depth, prototype, includeNonEnumerable) {
      if (typeof circular === "object") {
        depth = circular.depth;
        prototype = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != "undefined";
      if (typeof circular == "undefined")
        circular = true;
      if (typeof depth == "undefined")
        depth = Infinity;
      function _clone(parent2, depth2) {
        if (parent2 === null)
          return null;
        if (depth2 === 0)
          return parent2;
        var child;
        var proto;
        if (typeof parent2 != "object") {
          return parent2;
        }
        if (_instanceof(parent2, nativeMap)) {
          child = new nativeMap;
        } else if (_instanceof(parent2, nativeSet)) {
          child = new nativeSet;
        } else if (_instanceof(parent2, nativePromise)) {
          child = new nativePromise(function(resolve, reject) {
            parent2.then(function(value) {
              resolve(_clone(value, depth2 - 1));
            }, function(err) {
              reject(_clone(err, depth2 - 1));
            });
          });
        } else if (clone3.__isArray(parent2)) {
          child = [];
        } else if (clone3.__isRegExp(parent2)) {
          child = new RegExp(parent2.source, __getRegExpFlags(parent2));
          if (parent2.lastIndex)
            child.lastIndex = parent2.lastIndex;
        } else if (clone3.__isDate(parent2)) {
          child = new Date(parent2.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent2)) {
          if (Buffer.allocUnsafe) {
            child = Buffer.allocUnsafe(parent2.length);
          } else {
            child = new Buffer(parent2.length);
          }
          parent2.copy(child);
          return child;
        } else if (_instanceof(parent2, Error)) {
          child = Object.create(parent2);
        } else {
          if (typeof prototype == "undefined") {
            proto = Object.getPrototypeOf(parent2);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }
        if (circular) {
          var index = allParents.indexOf(parent2);
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent2);
          allChildren.push(child);
        }
        if (_instanceof(parent2, nativeMap)) {
          parent2.forEach(function(value, key) {
            var keyChild = _clone(key, depth2 - 1);
            var valueChild = _clone(value, depth2 - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent2, nativeSet)) {
          parent2.forEach(function(value) {
            var entryChild = _clone(value, depth2 - 1);
            child.add(entryChild);
          });
        }
        for (var i in parent2) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent2[i], depth2 - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(parent2);
          for (var i = 0;i < symbols.length; i++) {
            var symbol = symbols[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol] = _clone(parent2[symbol], depth2 - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol, {
                enumerable: false
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent2);
          for (var i = 0;i < allPropertyNames.length; i++) {
            var propertyName = allPropertyNames[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }
        return child;
      }
      return _clone(parent, depth);
    }
    clone3.clonePrototype = function clonePrototype(parent) {
      if (parent === null)
        return null;
      var c = function() {};
      c.prototype = parent;
      return new c;
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone3.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === "object" && __objToStr(o) === "[object Date]";
    }
    clone3.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === "object" && __objToStr(o) === "[object Array]";
    }
    clone3.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === "object" && __objToStr(o) === "[object RegExp]";
    }
    clone3.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
      var flags = "";
      if (re.global)
        flags += "g";
      if (re.ignoreCase)
        flags += "i";
      if (re.multiline)
        flags += "m";
      return flags;
    }
    clone3.__getRegExpFlags = __getRegExpFlags;
    return clone3;
  }();
  if (typeof module === "object" && module.exports) {
    module.exports = clone2;
  }
});

// node_modules/node-cache/lib/node_cache.js
var require_node_cache = __commonJS((exports, module) => {
  (function() {
    var EventEmitter, NodeCache, clone2, splice = [].splice, boundMethodCheck = function(instance, Constructor2) {
      if (!(instance instanceof Constructor2)) {
        throw new Error("Bound instance method accessed before binding");
      }
    }, indexOf = [].indexOf;
    clone2 = require_clone();
    EventEmitter = __require("events").EventEmitter;
    module.exports = NodeCache = function() {

      class NodeCache2 extends EventEmitter {
        constructor(options = {}) {
          super();
          this.get = this.get.bind(this);
          this.mget = this.mget.bind(this);
          this.set = this.set.bind(this);
          this.mset = this.mset.bind(this);
          this.del = this.del.bind(this);
          this.take = this.take.bind(this);
          this.ttl = this.ttl.bind(this);
          this.getTtl = this.getTtl.bind(this);
          this.keys = this.keys.bind(this);
          this.has = this.has.bind(this);
          this.getStats = this.getStats.bind(this);
          this.flushAll = this.flushAll.bind(this);
          this.flushStats = this.flushStats.bind(this);
          this.close = this.close.bind(this);
          this._checkData = this._checkData.bind(this);
          this._check = this._check.bind(this);
          this._isInvalidKey = this._isInvalidKey.bind(this);
          this._wrap = this._wrap.bind(this);
          this._getValLength = this._getValLength.bind(this);
          this._error = this._error.bind(this);
          this._initErrors = this._initErrors.bind(this);
          this.options = options;
          this._initErrors();
          this.data = {};
          this.options = Object.assign({
            forceString: false,
            objectValueSize: 80,
            promiseValueSize: 80,
            arrayValueSize: 40,
            stdTTL: 0,
            checkperiod: 600,
            useClones: true,
            deleteOnExpire: true,
            enableLegacyCallbacks: false,
            maxKeys: -1
          }, this.options);
          if (this.options.enableLegacyCallbacks) {
            console.warn("WARNING! node-cache legacy callback support will drop in v6.x");
            ["get", "mget", "set", "del", "ttl", "getTtl", "keys", "has"].forEach((methodKey) => {
              var oldMethod;
              oldMethod = this[methodKey];
              this[methodKey] = function(...args) {
                var cb, err, ref, res;
                ref = args, [...args] = ref, [cb] = splice.call(args, -1);
                if (typeof cb === "function") {
                  try {
                    res = oldMethod(...args);
                    cb(null, res);
                  } catch (error1) {
                    err = error1;
                    cb(err);
                  }
                } else {
                  return oldMethod(...args, cb);
                }
              };
            });
          }
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.validKeyTypes = ["string", "number"];
          this._checkData();
          return;
        }
        get(key) {
          var _ret, err;
          boundMethodCheck(this, NodeCache2);
          if ((err = this._isInvalidKey(key)) != null) {
            throw err;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            this.stats.hits++;
            _ret = this._unwrap(this.data[key]);
            return _ret;
          } else {
            this.stats.misses++;
            return;
          }
        }
        mget(keys) {
          var _err, err, i, key, len, oRet;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            _err = this._error("EKEYSTYPE");
            throw _err;
          }
          oRet = {};
          for (i = 0, len = keys.length;i < len; i++) {
            key = keys[i];
            if ((err = this._isInvalidKey(key)) != null) {
              throw err;
            }
            if (this.data[key] != null && this._check(key, this.data[key])) {
              this.stats.hits++;
              oRet[key] = this._unwrap(this.data[key]);
            } else {
              this.stats.misses++;
            }
          }
          return oRet;
        }
        set(key, value, ttl) {
          var _err, err, existent;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          if (this.options.forceString && false === "string") {
            value = JSON.stringify(value);
          }
          if (ttl == null) {
            ttl = this.options.stdTTL;
          }
          if ((err = this._isInvalidKey(key)) != null) {
            throw err;
          }
          existent = false;
          if (this.data[key]) {
            existent = true;
            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
          }
          this.data[key] = this._wrap(value, ttl);
          this.stats.vsize += this._getValLength(value);
          if (!existent) {
            this.stats.ksize += this._getKeyLength(key);
            this.stats.keys++;
          }
          this.emit("set", key, value);
          return true;
        }
        mset(keyValueSet) {
          var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          for (i = 0, len = keyValueSet.length;i < len; i++) {
            keyValuePair = keyValueSet[i];
            ({ key, val, ttl } = keyValuePair);
            if (ttl && typeof ttl !== "number") {
              _err = this._error("ETTLTYPE");
              throw _err;
            }
            if ((err = this._isInvalidKey(key)) != null) {
              throw err;
            }
          }
          for (j = 0, len1 = keyValueSet.length;j < len1; j++) {
            keyValuePair = keyValueSet[j];
            ({ key, val, ttl } = keyValuePair);
            this.set(key, val, ttl);
          }
          return true;
        }
        del(keys) {
          var delCount, err, i, key, len, oldVal;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            keys = [keys];
          }
          delCount = 0;
          for (i = 0, len = keys.length;i < len; i++) {
            key = keys[i];
            if ((err = this._isInvalidKey(key)) != null) {
              throw err;
            }
            if (this.data[key] != null) {
              this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
              this.stats.ksize -= this._getKeyLength(key);
              this.stats.keys--;
              delCount++;
              oldVal = this.data[key];
              delete this.data[key];
              this.emit("del", key, oldVal.v);
            }
          }
          return delCount;
        }
        take(key) {
          var _ret;
          boundMethodCheck(this, NodeCache2);
          _ret = this.get(key);
          if (_ret != null) {
            this.del(key);
          }
          return _ret;
        }
        ttl(key, ttl) {
          var err;
          boundMethodCheck(this, NodeCache2);
          ttl || (ttl = this.options.stdTTL);
          if (!key) {
            return false;
          }
          if ((err = this._isInvalidKey(key)) != null) {
            throw err;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            if (ttl >= 0) {
              this.data[key] = this._wrap(this.data[key].v, ttl, false);
            } else {
              this.del(key);
            }
            return true;
          } else {
            return false;
          }
        }
        getTtl(key) {
          var _ttl, err;
          boundMethodCheck(this, NodeCache2);
          if (!key) {
            return;
          }
          if ((err = this._isInvalidKey(key)) != null) {
            throw err;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            _ttl = this.data[key].t;
            return _ttl;
          } else {
            return;
          }
        }
        keys() {
          var _keys;
          boundMethodCheck(this, NodeCache2);
          _keys = Object.keys(this.data);
          return _keys;
        }
        has(key) {
          var _exists;
          boundMethodCheck(this, NodeCache2);
          _exists = this.data[key] != null && this._check(key, this.data[key]);
          return _exists;
        }
        getStats() {
          boundMethodCheck(this, NodeCache2);
          return this.stats;
        }
        flushAll(_startPeriod = true) {
          boundMethodCheck(this, NodeCache2);
          this.data = {};
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this._killCheckPeriod();
          this._checkData(_startPeriod);
          this.emit("flush");
        }
        flushStats() {
          boundMethodCheck(this, NodeCache2);
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.emit("flush_stats");
        }
        close() {
          boundMethodCheck(this, NodeCache2);
          this._killCheckPeriod();
        }
        _checkData(startPeriod = true) {
          var key, ref, value;
          boundMethodCheck(this, NodeCache2);
          ref = this.data;
          for (key in ref) {
            value = ref[key];
            this._check(key, value);
          }
          if (startPeriod && this.options.checkperiod > 0) {
            this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);
            if (this.checkTimeout != null && this.checkTimeout.unref != null) {
              this.checkTimeout.unref();
            }
          }
        }
        _killCheckPeriod() {
          if (this.checkTimeout != null) {
            return clearTimeout(this.checkTimeout);
          }
        }
        _check(key, data) {
          var _retval;
          boundMethodCheck(this, NodeCache2);
          _retval = true;
          if (data.t !== 0 && data.t < Date.now()) {
            if (this.options.deleteOnExpire) {
              _retval = false;
              this.del(key);
            }
            this.emit("expired", key, this._unwrap(data));
          }
          return _retval;
        }
        _isInvalidKey(key) {
          var ref;
          boundMethodCheck(this, NodeCache2);
          if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {
            return this._error("EKEYTYPE", {
              type: typeof key
            });
          }
        }
        _wrap(value, ttl, asClone = true) {
          var livetime, now, oReturn, ttlMultiplicator;
          boundMethodCheck(this, NodeCache2);
          if (!this.options.useClones) {
            asClone = false;
          }
          now = Date.now();
          livetime = 0;
          ttlMultiplicator = 1000;
          if (ttl === 0) {
            livetime = 0;
          } else if (ttl) {
            livetime = now + ttl * ttlMultiplicator;
          } else {
            if (this.options.stdTTL === 0) {
              livetime = this.options.stdTTL;
            } else {
              livetime = now + this.options.stdTTL * ttlMultiplicator;
            }
          }
          return oReturn = {
            t: livetime,
            v: asClone ? clone2(value) : value
          };
        }
        _unwrap(value, asClone = true) {
          if (!this.options.useClones) {
            asClone = false;
          }
          if (value.v != null) {
            if (asClone) {
              return clone2(value.v);
            } else {
              return value.v;
            }
          }
          return null;
        }
        _getKeyLength(key) {
          return key.toString().length;
        }
        _getValLength(value) {
          boundMethodCheck(this, NodeCache2);
          if (typeof value === "string") {
            return value.length;
          } else if (this.options.forceString) {
            return JSON.stringify(value).length;
          } else if (Array.isArray(value)) {
            return this.options.arrayValueSize * value.length;
          } else if (typeof value === "number") {
            return 8;
          } else if (typeof (value != null ? value.then : undefined) === "function") {
            return this.options.promiseValueSize;
          } else if (typeof Buffer !== "undefined" && Buffer !== null ? Buffer.isBuffer(value) : undefined) {
            return value.length;
          } else if (value != null && typeof value === "object") {
            return this.options.objectValueSize * Object.keys(value).length;
          } else if (typeof value === "boolean") {
            return 8;
          } else {
            return 0;
          }
        }
        _error(type2, data = {}) {
          var error3;
          boundMethodCheck(this, NodeCache2);
          error3 = new Error;
          error3.name = type2;
          error3.errorcode = type2;
          error3.message = this.ERRORS[type2] != null ? this.ERRORS[type2](data) : "-";
          error3.data = data;
          return error3;
        }
        _initErrors() {
          var _errMsg, _errT, ref;
          boundMethodCheck(this, NodeCache2);
          this.ERRORS = {};
          ref = this._ERRORS;
          for (_errT in ref) {
            _errMsg = ref[_errT];
            this.ERRORS[_errT] = this.createErrorMessage(_errMsg);
          }
        }
        createErrorMessage(errMsg) {
          return function(args) {
            return errMsg.replace("__key", args.type);
          };
        }
      }
      NodeCache2.prototype._ERRORS = {
        ENOTFOUND: "Key `__key` not found",
        ECACHEFULL: "Cache max keys amount exceeded",
        EKEYTYPE: "The key argument has to be of type `string` or `number`. Found: `__key`",
        EKEYSTYPE: "The keys argument has to be an array.",
        ETTLTYPE: "The ttl argument has to be a number."
      };
      return NodeCache2;
    }.call(this);
  }).call(exports);
});

// node_modules/node-cache/index.js
var require_node_cache2 = __commonJS((exports, module) => {
  (function() {
    var exports2;
    exports2 = module.exports = require_node_cache();
    exports2.version = "5.1.2";
  }).call(exports);
});

// node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.4.7",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var crypto2 = __require("crypto");
  var packageJson = require_package();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse3(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, `
`);
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, `
`);
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error3) {
        if (i + 1 >= length) {
          throw error3;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _log(message) {
    console.log(`[dotenv@${version}][INFO] ${message}`);
  }
  function _warn(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri2;
    try {
      uri2 = new URL(dotenvKey);
    } catch (error3) {
      if (error3.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error3;
    }
    const key = uri2.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri2.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error3) {
      const isRange = error3 instanceof RangeError;
      const invalidKeyLength = error3.message === "Invalid key length";
      const decryptionFailed = error3.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error3;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse: parse3,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/pg/node_modules/pg-types/node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  exports.parse = function(source, transform2) {
    return new ArrayParser(source, transform2).parse();
  };

  class ArrayParser {
    constructor(source, transform2) {
      this.source = source;
      this.transform = transform2 || identity;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char = this.nextCharacter();
          if (char.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
  function identity(value) {
    return value;
  }
});

// node_modules/pg/node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array = require_postgres_array();
  module.exports = {
    create: function(source, transform2) {
      return {
        parse: function() {
          return array.parse(source, transform2);
        }
      };
    }
  };
});

// node_modules/pg/node_modules/pg-types/node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE2 = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date2;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date2 = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
      if (is0To99(year)) {
        date2.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date2.setTime(date2.getTime() - offset);
      }
    } else {
      date2 = new Date(year, month, day, hour, minute, second, ms);
      if (is0To99(year)) {
        date2.setFullYear(year);
      }
    }
    return date2;
  };
  function getDate(isoDate) {
    var matches = DATE2.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var date2 = new Date(year, month, day);
    if (is0To99(year)) {
      date2.setFullYear(year);
    }
    return date2;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type2 = zone[1];
    if (type2 === "Z") {
      return 0;
    }
    var sign = type2 === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  }
  function bcYearToNegativeYear(year) {
    return -(year - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
});

// node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  module.exports = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// node_modules/pg/node_modules/pg-types/node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var extend = require_mutable();
  module.exports = PostgresInterval;
  function PostgresInterval(raw) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw);
    }
    extend(this, parse3(raw));
  }
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME2 = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME2].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  }
  function parse3(interval) {
    if (!interval)
      return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value)
        return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  }
});

// node_modules/pg/node_modules/pg-types/node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return new Buffer(input.substr(2), "hex");
    }
    var output = "";
    var i = 0;
    while (i < input.length) {
      if (input[i] !== "\\") {
        output += input[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input.length && input[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output, "binary");
  };
});

// node_modules/pg/node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var array = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  function allowNull(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  }
  function parseBool(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  }
  function parseBoolArray(value) {
    if (!value)
      return null;
    return array.parse(value, parseBool);
  }
  function parseBaseTenInt(string) {
    return parseInt(string, 10);
  }
  function parseIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value.length - 1; i++) {
      if (!pointParsed) {
        point += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var BASE = 1e6;
  function readInt8(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t3;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t3 = 4294967296 * carry + low;
      low = t3 / BASE >>> 0;
      digits = "" + (t3 - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t3 = 4294967296 * carry + low;
      low = t3 / BASE >>> 0;
      digits = "" + (t3 - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t3 = 4294967296 * carry + low;
      low = t3 / BASE >>> 0;
      digits = "" + (t3 - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t3 = 4294967296 * carry + low;
      digits = "" + t3 % BASE;
      return sign + digits + result;
    }
  }
  module.exports = readInt8;
});

// node_modules/pg/node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask2 = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask2 = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask2 = mask2 >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask2, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse3 = function(dimension, elementType2) {
      var array = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array[i2] = parse3(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array[i2] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse3(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// node_modules/pg/node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// node_modules/pg/node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  }
  function setTypeParser(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  }
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// node_modules/pg/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var defaults = require_defaults();
  function escapeElement(elementRepresentation) {
    var escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    var result = "{";
    for (var i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        var item = val[i];
        if (!(item instanceof Buffer)) {
          var buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  }
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        var buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (val instanceof Date) {
        if (defaults.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date2) {
    var offset = -date2.getTimezoneOffset();
    var year = date2.getFullYear();
    var isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    var ret = String(year).padStart(4, "0") + "-" + String(date2.getMonth() + 1).padStart(2, "0") + "-" + String(date2.getDate()).padStart(2, "0") + "T" + String(date2.getHours()).padStart(2, "0") + ":" + String(date2.getMinutes()).padStart(2, "0") + ":" + String(date2.getSeconds()).padStart(2, "0") + "." + String(date2.getMilliseconds()).padStart(3, "0");
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function dateToStringUTC(date2) {
    var year = date2.getUTCFullYear();
    var isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    var ret = String(year).padStart(4, "0") + "-" + String(date2.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date2.getUTCDate()).padStart(2, "0") + "T" + String(date2.getUTCHours()).padStart(2, "0") + ":" + String(date2.getUTCMinutes()).padStart(2, "0") + ":" + String(date2.getUTCSeconds()).padStart(2, "0") + "." + String(date2.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config, values, callback) {
    config = typeof config === "string" ? { text: config } : config;
    if (values) {
      if (typeof values === "function") {
        config.callback = values;
      } else {
        config.values = values;
      }
    }
    if (callback) {
      config.callback = callback;
    }
    return config;
  }
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    var hasBackslash = false;
    var escaped = "'";
    for (var i = 0;i < str.length; i++) {
      var c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  function md5(string) {
    return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user, password, salt) {
    var inner = md5(password + user);
    var outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha256(text) {
    return nodeCrypto.createHash("sha256").update(text).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hmacSha256,
    md5
  };
});

// node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
  function randomBytes(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  }
  async function md5(string) {
    try {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string === "string" ? textEncoder.encode(string) : string;
      const hash2 = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash2)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    var inner = await md5(password + user);
    var outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha256(text) {
    return await subtleCrypto.digest("SHA-256", text);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
});

// node_modules/pg/lib/crypto/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var crypto2 = require_utils2();
  function startSession(mechanisms) {
    if (mechanisms.indexOf("SCRAM-SHA-256") === -1) {
      throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
    }
    const clientNonce = crypto2.randomBytes(18).toString("base64");
    return {
      mechanism: "SCRAM-SHA-256",
      clientNonce,
      response: "n,,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session, password, serverData) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    var clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    var serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    var clientFinalMessageWithoutProof = "c=biws,r=" + sv.nonce;
    var authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    var saltBytes = Buffer.from(sv.salt, "base64");
    var saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
    var clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
    var storedKey = await crypto2.sha256(clientKey);
    var clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
    var clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    var serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
    var serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text.split("").map((_, i) => text.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  }
  function isBase64(text) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
  }
  function parseAttributePairs(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value = attrValue.substring(2);
      return [name, value];
    }));
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  }
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var types = require_pg_types();
  function TypeOverrides(userTypes) {
    this._types = userTypes || types;
    this.text = {};
    this.binary = {};
  }
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  function parse3(str) {
    if (str.charAt(0) === "/") {
      const config2 = str.split(" ");
      return { host: config2[0], database: config2[1] };
    }
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
    }
    try {
      result = new URL(str, "postgres://base");
    } catch (e) {
      result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
      dummyHost = true;
    }
    for (const entry of result.searchParams.entries()) {
      config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config.host = decodeURI(result.pathname);
      config.database = result.searchParams.get("db");
      config.client_encoding = result.searchParams.get("encoding");
      return config;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config.host) {
      config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
      config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === "true" || config.ssl === "1") {
      config.ssl = true;
    }
    if (config.ssl === "0") {
      config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
      config.ssl = {};
    }
    const fs = config.sslcert || config.sslkey || config.sslrootcert ? __require("fs") : null;
    if (config.sslcert) {
      config.ssl.cert = fs.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
      config.ssl.key = fs.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
      config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
    }
    switch (config.sslmode) {
      case "disable": {
        config.ssl = false;
        break;
      }
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full": {
        break;
      }
      case "no-verify": {
        config.ssl.rejectUnauthorized = false;
        break;
      }
    }
    return config;
  }
  module.exports = parse3;
  parse3.parse = parse3;
});

// node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = __require("dns");
  var defaults = require_defaults();
  var parse3 = require_pg_connection_string().parse;
  var val = function(key, config, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {} else {
      envVar = process.env[envVar];
    }
    return config[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params, config, paramName) {
    var value = config[paramName];
    if (value !== undefined && value !== null) {
      params.push(paramName + "=" + quoteParamValue(value));
    }
  };

  class ConnectionParameters {
    constructor(config) {
      config = typeof config === "string" ? parse3(config) : config || {};
      if (config.connectionString) {
        config = Object.assign({}, config, parse3(config.connectionString));
      }
      this.user = val("user", config);
      this.database = val("database", config);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config), 10);
      this.host = val("host", config);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config)
      });
      this.binary = val("binary", config);
      this.options = val("options", config);
      this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config);
      this.replication = val("replication", config);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config, false);
      this.statement_timeout = val("statement_timeout", config, false);
      this.lock_timeout = val("lock_timeout", config, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
      this.query_timeout = val("query_timeout", config, false);
      if (config.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
      }
      if (config.keepAlive === false) {
        this.keepalives = 0;
      } else if (config.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      var params = [];
      add(params, this, "user");
      add(params, this, "password");
      add(params, this, "port");
      add(params, this, "application_name");
      add(params, this, "fallback_application_name");
      add(params, this, "connect_timeout");
      add(params, this, "options");
      var ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params, ssl, "sslmode");
      add(params, ssl, "sslca");
      add(params, ssl, "sslkey");
      add(params, ssl, "sslcert");
      add(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err, address) {
        if (err)
          return cb(err, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types2) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types2;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      var match;
      if (msg.text) {
        match = matchRegexp.exec(msg.text);
      } else {
        match = matchRegexp.exec(msg.command);
      }
      if (match) {
        this.command = match[1];
        if (match[3]) {
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      var row = new Array(rowData.length);
      for (var i = 0, len = rowData.length;i < len; i++) {
        var rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      var row = { ...this._prebuiltEmptyResultObject };
      for (var i = 0, len = rowData.length;i < len; i++) {
        var rawValue = rowData[i];
        var field = this.fields[i].name;
        if (rawValue !== null) {
          row[field] = this._parsers[i](rawValue);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      var row = {};
      for (var i = 0;i < fieldDescriptions.length; i++) {
        var desc = fieldDescriptions[i];
        row[desc.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
        } else {
          this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var Result = require_result();
  var utils = require_utils();

  class Query extends EventEmitter {
    constructor(config, values, callback) {
      super();
      config = utils.normalizeQueryConfig(config, values, callback);
      this.text = config.text;
      this.values = config.values;
      this.rows = config.rows;
      this.types = config.types;
      this.name = config.name;
      this.queryMode = config.queryMode;
      this.binary = config.binary;
      this.portal = config.portal || "";
      this.callback = config.callback;
      this._rowMode = config.rowMode;
      if (process.domain && config.callback) {
        this.callback = process.domain.bind(config.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection.sync();
      }
    }
    handleEmptyQuery(connection) {
      if (this.rows) {
        connection.sync();
      }
    }
    handleError(err, connection) {
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err);
      }
      this.emit("error", err);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        this.prepare(connection);
      } else {
        connection.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection) {
      return this.name && connection.parsedStatements[this.name];
    }
    handlePortalSuspended(connection) {
      this._getRows(connection, this.rows);
    }
    _getRows(connection, rows) {
      connection.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection.sync();
      } else {
        connection.flush();
      }
    }
    prepare(connection) {
      if (!this.hasBeenParsed(connection)) {
        connection.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection);
        return;
      }
      connection.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection, this.rows);
    }
    handleCopyInResponse(connection) {
      connection.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection) {}
  }
  module.exports = Query;
});

// node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name) {
      super(message);
      this.length = length;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text) {
      this.length = length;
      this.text = text;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      var remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        var oldBuffer = this.buffer;
        var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string) {
      if (!string) {
        this.ensure(1);
      } else {
        var len = Buffer.byteLength(string);
        this.ensure(len + 1);
        this.buffer.write(string, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string = "") {
      var len = Buffer.byteLength(string);
      this.ensure(len);
      this.buffer.write(string, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      var result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    var bodyBuffer = writer.addCString("").flush();
    var length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query = (text) => {
    return writer.addCString(text).flush(81);
  };
  var emptyArray = [];
  var parse3 = (query2) => {
    const name = query2.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types = query2.types || emptyArray;
    var len = types.length;
    var buffer = writer.addCString(name).addCString(query2.text).addInt16(len);
    for (var i = 0;i < len; i++) {
      buffer.addInt32(types[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values, valueMapper) {
    for (let i = 0;i < values.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config = {}) => {
    const portal = config.portal || "";
    const statement = config.statement || "";
    const binary = config.binary || false;
    const values = config.values || emptyArray;
    const len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute = (config) => {
    if (!config || !config.portal && !config.rows) {
      return emptyExecute;
    }
    const portal = config.portal || "";
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize2 = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query,
    parse: parse3,
    bind,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize2;
});

// node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    uint32() {
      const result = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {}
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.uint32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.uint32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          message.name = "authenticationSASL";
          message.mechanisms = [];
          let mechanism;
          do {
            mechanism = this.reader.cstring();
            if (mechanism) {
              message.mechanisms.push(mechanism);
            }
          } while (mechanism);
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\x00") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports.Parser = Parser;
});

// node_modules/pg-protocol/dist/index.js
var require_dist2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  function parse3(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve2) => stream.on("end", () => resolve2()));
  }
  exports.parse = parse3;
});

// node_modules/pg-cloudflare/dist/empty.js
var exports_empty = {};
__export(exports_empty, {
  default: () => empty_default
});
var empty_default;
var init_empty = __esm(() => {
  empty_default = {};
});

// node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { getStream, getSecureStream } = getStreamFuncs();
  module.exports = {
    getStream,
    getSecureStream
  };
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net = __require("net");
      return new net.Socket;
    }
    function getSecureStream2(options) {
      var tls = __require("tls");
      return tls.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = (init_empty(), __toCommonJS(exports_empty));
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
});

// node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var { parse: parse3, serialize: serialize2 } = require_dist2();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize2.flush();
  var syncBuffer = serialize2.sync();
  var endBuffer = serialize2.end();

  class Connection extends EventEmitter {
    constructor(config) {
      super();
      config = config || {};
      this.stream = config.stream || getStream(config.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config);
      }
      this._keepAlive = config.keepAlive;
      this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      var self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      var self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error3) {
        if (self2._ending && (error3.code === "ECONNRESET" || error3.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error3);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        var responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        var net = __require("net");
        if (net.isIP && net.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err) {
          return self2.emit("error", err);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse3(stream, (msg) => {
        var eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize2.requestSsl());
    }
    startup(config) {
      this.stream.write(serialize2.startup(config));
    }
    cancel(processID, secretKey) {
      this._send(serialize2.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize2.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize2.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize2.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text) {
      this._send(serialize2.query(text));
    }
    parse(query) {
      this._send(serialize2.parse(query));
    }
    bind(config) {
      this._send(serialize2.bind(config));
    }
    execute(config) {
      this._send(serialize2.execute(config));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize2.close(msg));
    }
    describe(msg) {
      this._send(serialize2.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize2.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize2.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize2.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var { Transform: Transform2 } = __require("stream");
  var { StringDecoder } = __require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  function transform2(chunk, enc, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list = buf.split(this.matcher);
      if (list.length === 1)
        return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i = 0;i < list.length; i++) {
      try {
        push(this, this.mapper(list[i]));
      } catch (error3) {
        return cb(error3);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error3) {
        return cb(error3);
      }
    }
    cb();
  }
  function push(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  }
  function noop(incoming) {
    return incoming;
  }
  function split(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform2;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform2(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
      this._writableState.errorEmitted = false;
      cb(err);
    };
    return stream;
  }
  module.exports = split;
});

// node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var path = __require("path");
  var Stream = __require("stream").Stream;
  var split = require_split2();
  var util = __require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
  }
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  function warn() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat(`
`);
      warnStream.write(util.format.apply(util, args));
    }
  }
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env4 = rawEnv || process.env;
    var file3 = env4.PGPASSFILE || (isWin ? path.join(env4.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env4.HOME || "./", ".pgpass"));
    return file3;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
      if (idx == 1) {
        if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
          return prev && true;
        }
      }
      return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line) {
      var entry = parseLine(line);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
      var field = line.substring(i0, i1);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field = field.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field;
    };
    for (var i = 0;i < line.length - 1; i += 1) {
      curChar = line.charAt(i + 1);
      prevChar = line.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value = entry[fieldNames[idx]] || "";
      var res = rule(value);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/pgpass/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file3 = helper.getFileName();
    fs.stat(file3, function(err, stat3) {
      if (err || !helper.usePgPass(stat3, file3)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file3);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// node_modules/pg/lib/client.js
var require_client = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var utils = require_utils();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults = require_defaults();
  var Connection = require_connection();
  var crypto2 = require_utils2();

  class Client extends EventEmitter {
    constructor(config) {
      super();
      this.connectionParameters = new ConnectionParameters(config);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      var c = config || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.handleError(err, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      var self2 = this;
      var con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error3 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error3);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error3);
            } else {
              this._handleErrorEvent(error3);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error3);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve2, reject) => {
        this._connect((error3) => {
          if (error3) {
            reject(error3);
          } else {
            resolve2();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err) => {
          con.emit("error", err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }
      this.emit("error", err);
    }
    _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }
      this._queryable = false;
      this._errorAllQueries(err);
      this.emit("error", err);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      if (this.activeQuery == null) {
        const error3 = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error3);
        return;
      }
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      if (this.activeQuery == null) {
        const error3 = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error3);
        return;
      }
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      var params = this.connectionParameters;
      var data = {
        user: params.user,
        database: params.database
      };
      var appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client, query) {
      if (client.activeQuery === query) {
        var con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config, values, callback) {
      var query;
      var result;
      var readTimeout;
      var readTimeoutTimer;
      var queryCallback;
      if (config === null || config === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query = config;
        if (typeof values === "function") {
          query.callback = query.callback || values;
        }
      } else {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        query = new Query(config, values, callback);
        if (!query.callback) {
          result = new this._Promise((resolve2, reject) => {
            query.callback = (err, res) => err ? reject(err) : resolve2(res);
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          var error3 = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error3, this.connection);
          });
          queryCallback(error3);
          query.callback = () => {};
          var index = this.queryQueue.indexOf(query);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (this.binary && !query.binary) {
        query.binary = true;
      }
      if (query._result && !query._result._types) {
        query._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve2) => {
          this.connection.once("end", resolve2);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var NOOP = function() {};
  var removeWhere = (list, predicate) => {
    const i = list.findIndex(predicate);
    return i === -1 ? undefined : list.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client, idleListener, timeoutId) {
      this.client = client;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise3, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err, client) {
      err ? rej(err) : res(client);
    };
    const result = new Promise3(function(resolve2, reject) {
      res = resolve2;
      rej = reject;
    }).catch((err) => {
      Error.captureStackTrace(err);
      throw err;
    });
    return { callback: cb, result };
  }
  function makeIdleListener(pool, client) {
    return function idleListener(err) {
      err.client = client;
      client.removeListener("error", idleListener);
      client.on("error", () => {
        pool.log("additional client error after disconnection due to error", err);
      });
      pool._remove(client);
      pool.emit("error", err, client);
    };
  }

  class Pool extends EventEmitter {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {};
      this.Client = this.options.Client || Client || require_lib2().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client = idleItem.client;
        client.ref && client.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client) {
      const removed = removeWhere(this._idle, (item) => item.client === client);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client);
      client.end();
      this.emit("remove", client);
    }
    connect(cb) {
      if (this.ending) {
        const err = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err, res, done) => {
          clearTimeout(tid);
          response.callback(err, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client = new this.Client(this.options);
      this._clients.push(client);
      const idleListener = makeIdleListener(this, client);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client.connect((err) => {
        if (tid) {
          clearTimeout(tid);
        }
        client.on("error", idleListener);
        if (err) {
          this.log("client failed to connect", err);
          this._clients = this._clients.filter((c) => c !== client);
          if (timeoutHit) {
            err = new Error("Connection terminated due to connection timeout", { cause: err });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
              if (idleIndex !== -1) {
                this._acquireClient(client, new PendingItem((err2, client2, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client);
      }
      this.emit("acquire", client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, (err) => {
            if (err) {
              client.release(err);
              return pendingItem.callback(err, undefined, NOOP);
            }
            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    }
    _releaseOnce(client, idleListener) {
      let released = false;
      return (err) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client, idleListener, err);
      };
    }
    _release(client, idleListener, err) {
      client.on("error", idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1;
      this.emit("release", err, client);
      if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        this._remove(client);
        this._pulseQueue();
        return;
      }
      const isExpired = this._expired.has(client);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client);
        this._remove(client);
        this._pulseQueue();
        return;
      }
      let tid;
      if (this.options.idleTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client);
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client.unref();
      }
      this._idle.push(new IdleItem(client, idleListener, tid));
      this._pulseQueue();
    }
    query(text, values, cb) {
      if (typeof text === "function") {
        const response2 = promisify(this.Promise, text);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values === "function") {
        cb = values;
        values = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err, client) => {
        if (err) {
          return cb(err);
        }
        let clientReleased = false;
        const onError = (err2) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client.release(err2);
          cb(err2);
        };
        client.once("error", onError);
        this.log("dispatching query");
        try {
          client.query(text, values, (err2, res) => {
            this.log("query dispatched");
            client.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err2);
            if (err2) {
              return cb(err2);
            }
            return cb(undefined, res);
          });
        } catch (err2) {
          client.release(err2);
          return cb(err2);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err = new Error("Called end on pool more than once");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var util = __require("util");
  var utils = require_utils();
  var NativeQuery = module.exports = function(config, values, callback) {
    EventEmitter.call(this);
    config = utils.normalizeQueryConfig(config, values, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.queryMode = config.queryMode;
    this.callback = config.callback;
    this.state = "new";
    this._arrayMode = config.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util.inherits(NativeQuery, EventEmitter);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err) {
    var fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (var key in fields) {
        var normalizedFieldName = errorFieldMap[key] || key;
        err[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err);
    } else {
      this.emit("error", err);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve2, reject) {
      this._once("end", resolve2);
      this._once("error", reject);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client) {
    this.state = "running";
    var self2 = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    var after = function(err, rows, results) {
      client.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err) {
        return self2.handleError(err);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      var values = (this.values || []).map(utils.prepareValue);
      if (client.namedQueries[this.name]) {
        if (this.text && client.namedQueries[this.name] !== this.text) {
          const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err);
        }
        return client.native.execute(this.name, values, after);
      }
      return client.native.prepare(this.name, this.text, values.length, function(err) {
        if (err)
          return after(err);
        client.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err = new Error("Query values must be an array");
        return after(err);
      }
      var vals = this.values.map(utils.prepareValue);
      client.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client.native.query(this.text, [], after);
    } else {
      client.native.query(this.text, after);
    }
  };
});

// node_modules/pg/lib/native/client.js
var require_client2 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = (()=>{throw new Error("Cannot require module "+"pg-native");})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter = __require("events").EventEmitter;
  var util = __require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module.exports = function(config) {
    EventEmitter.call(this);
    config = config || {};
    this._Promise = config.Promise || global.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    var cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString)
      cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util.inherits(Client, EventEmitter);
  Client.prototype._errorAllQueries = function(err) {
    const enqueueError = (query) => {
      process.nextTick(() => {
        query.native = this.native;
        query.handleError(err);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    var self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err)
        return cb(err);
      self2.native.connect(conString, function(err2) {
        if (err2) {
          self2.native.end();
          return cb(err2);
        }
        self2._connected = true;
        self2.native.on("error", function(err3) {
          self2._queryable = false;
          self2._errorAllQueries(err3);
          self2.emit("error", err3);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve2, reject) => {
      this._connect((error3) => {
        if (error3) {
          reject(error3);
        } else {
          resolve2();
        }
      });
    });
  };
  Client.prototype.query = function(config, values, callback) {
    var query;
    var result;
    var readTimeout;
    var readTimeoutTimer;
    var queryCallback;
    if (config === null || config === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config.submit === "function") {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      result = query = config;
      if (typeof values === "function") {
        config.callback = values;
      }
    } else {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      query = new NativeQuery(config, values, callback);
      if (!query.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve2, reject) => {
          resolveOut = resolve2;
          rejectOut = reject;
        }).catch((err) => {
          Error.captureStackTrace(err);
          throw err;
        });
        query.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query.callback;
      readTimeoutTimer = setTimeout(() => {
        var error3 = new Error("Query read timeout");
        process.nextTick(() => {
          query.handleError(error3, this.connection);
        });
        queryCallback(error3);
        query.callback = () => {};
        var index = this._queryQueue.indexOf(query);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query.callback = (err, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err, res);
      };
    }
    if (!this._queryable) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    var self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    var result;
    if (!cb) {
      result = new this._Promise(function(resolve2, reject) {
        cb = (err) => err ? reject(err) : resolve2();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    var query = this._queryQueue.shift();
    if (!query) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query;
    query.submit(this);
    var self2 = this;
    query.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query) {
    if (this._activeQuery === query) {
      this.native.cancel(function() {});
    } else if (this._queryQueue.indexOf(query) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
    }
  };
  Client.prototype.ref = function() {};
  Client.prototype.unref = function() {};
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// node_modules/pg/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var Client = require_client();
  var defaults = require_defaults();
  var Connection = require_connection();
  var Pool = require_pg_pool();
  var { DatabaseError } = require_dist2();
  var { escapeIdentifier, escapeLiteral } = require_utils();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client2());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        var native = null;
        try {
          native = new PG(require_client2());
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND") {
            throw err;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// node_modules/dotenv/lib/env-options.js
var require_env_options = __commonJS((exports, module) => {
  var options = {};
  if (process.env.DOTENV_CONFIG_ENCODING != null) {
    options.encoding = process.env.DOTENV_CONFIG_ENCODING;
  }
  if (process.env.DOTENV_CONFIG_PATH != null) {
    options.path = process.env.DOTENV_CONFIG_PATH;
  }
  if (process.env.DOTENV_CONFIG_DEBUG != null) {
    options.debug = process.env.DOTENV_CONFIG_DEBUG;
  }
  if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
    options.override = process.env.DOTENV_CONFIG_OVERRIDE;
  }
  if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
    options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
  }
  module.exports = options;
});

// node_modules/dotenv/lib/cli-options.js
var require_cli_options = __commonJS((exports, module) => {
  var re = /^dotenv_config_(encoding|path|debug|override|DOTENV_KEY)=(.+)$/;
  module.exports = function optionMatcher(args) {
    return args.reduce(function(acc, cur) {
      const matches = cur.match(re);
      if (matches) {
        acc[matches[1]] = matches[2];
      }
      return acc;
    }, {});
  };
});

// node_modules/dotenv/config.js
var require_config = __commonJS(() => {
  (function() {
    require_main().config(Object.assign({}, require_env_options(), require_cli_options()(process.argv)));
  })();
});

// node_modules/memoirist/dist/cjs/index.js
var require_cjs = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Memoirist: () => Memoirist2,
    default: () => src_default
  });
  module.exports = __toCommonJS2(src_exports);
  var createNode2 = (part, inert) => {
    const inertMap = inert?.length ? {} : null;
    if (inertMap)
      for (const child of inert)
        inertMap[child.part.charCodeAt(0)] = child;
    return {
      part,
      store: null,
      inert: inertMap,
      params: null,
      wildcardStore: null
    };
  };
  var cloneNode2 = (node, part) => ({
    ...node,
    part
  });
  var createParamNode2 = (name) => ({
    name,
    store: null,
    inert: null
  });
  var Memoirist2 = class _Memoirist2 {
    constructor(config = {}) {
      this.config = config;
      if (config.lazy)
        this.find = this.lazyFind;
    }
    root = {};
    history = [];
    deferred = [];
    static regex = {
      static: /:.+?(?=\/|$)/,
      params: /:.+?(?=\/|$)/g,
      optionalParams: /:.+?\?(?=\/|$)/g
    };
    lazyFind = (method, url) => {
      if (!this.config.lazy)
        return this.find;
      this.build();
      return this.find(method, url);
    };
    build() {
      if (!this.config.lazy)
        return;
      for (const [method, path, store] of this.deferred)
        this.add(method, path, store, { lazy: false, ignoreHistory: true });
      this.deferred = [];
      this.find = (method, url) => {
        const root = this.root[method];
        if (!root)
          return null;
        return matchRoute2(url, url.length, root, 0);
      };
    }
    add(method, path, store, {
      ignoreError = false,
      ignoreHistory = false,
      lazy = this.config.lazy
    } = {}) {
      if (lazy) {
        this.find = this.lazyFind;
        this.deferred.push([method, path, store]);
        return store;
      }
      if (typeof path !== "string")
        throw new TypeError("Route path must be a string");
      if (path === "")
        path = "/";
      else if (path[0] !== "/")
        path = `/${path}`;
      const isWildcard = path[path.length - 1] === "*";
      const optionalParams = path.match(_Memoirist2.regex.optionalParams);
      if (optionalParams) {
        const originalPath = path.replaceAll("?", "");
        this.add(method, originalPath, store, {
          ignoreError,
          ignoreHistory,
          lazy
        });
        for (let i = 0;i < optionalParams.length; i++) {
          let newPath = path.replace("/" + optionalParams[i], "");
          this.add(method, newPath, store, {
            ignoreError: true,
            ignoreHistory,
            lazy
          });
        }
        return store;
      }
      if (optionalParams)
        path = path.replaceAll("?", "");
      if (this.history.find(([m, p, s]) => m === method && p === path))
        return store;
      if (isWildcard || optionalParams && path.charCodeAt(path.length - 1) === 63)
        path = path.slice(0, -1);
      if (!ignoreHistory)
        this.history.push([method, path, store]);
      const inertParts = path.split(_Memoirist2.regex.static);
      const paramParts = path.match(_Memoirist2.regex.params) || [];
      if (inertParts[inertParts.length - 1] === "")
        inertParts.pop();
      let node;
      if (!this.root[method])
        node = this.root[method] = createNode2("/");
      else
        node = this.root[method];
      let paramPartsIndex = 0;
      for (let i = 0;i < inertParts.length; ++i) {
        let part = inertParts[i];
        if (i > 0) {
          const param = paramParts[paramPartsIndex++].slice(1);
          if (node.params === null)
            node.params = createParamNode2(param);
          else if (node.params.name !== param) {
            if (ignoreError)
              return store;
            else
              throw new Error(`Cannot create route "${path}" with parameter "${param}" because a route already exists with a different parameter name ("${node.params.name}") in the same location`);
          }
          const params = node.params;
          if (params.inert === null) {
            node = params.inert = createNode2(part);
            continue;
          }
          node = params.inert;
        }
        for (let j = 0;; ) {
          if (j === part.length) {
            if (j < node.part.length) {
              const childNode = cloneNode2(node, node.part.slice(j));
              Object.assign(node, createNode2(part, [childNode]));
            }
            break;
          }
          if (j === node.part.length) {
            if (node.inert === null)
              node.inert = {};
            const inert = node.inert[part.charCodeAt(j)];
            if (inert) {
              node = inert;
              part = part.slice(j);
              j = 0;
              continue;
            }
            const childNode = createNode2(part.slice(j));
            node.inert[part.charCodeAt(j)] = childNode;
            node = childNode;
            break;
          }
          if (part[j] !== node.part[j]) {
            const existingChild = cloneNode2(node, node.part.slice(j));
            const newChild = createNode2(part.slice(j));
            Object.assign(node, createNode2(node.part.slice(0, j), [
              existingChild,
              newChild
            ]));
            node = newChild;
            break;
          }
          ++j;
        }
      }
      if (paramPartsIndex < paramParts.length) {
        const param = paramParts[paramPartsIndex];
        const name = param.slice(1);
        if (node.params === null)
          node.params = createParamNode2(name);
        else if (node.params.name !== name) {
          if (ignoreError)
            return store;
          else
            throw new Error(`Cannot create route "${path}" with parameter "${name}" because a route already exists with a different parameter name ("${node.params.name}") in the same location`);
        }
        if (node.params.store === null)
          node.params.store = store;
        return node.params.store;
      }
      if (isWildcard) {
        if (node.wildcardStore === null)
          node.wildcardStore = store;
        return node.wildcardStore;
      }
      if (node.store === null)
        node.store = store;
      return node.store;
    }
    find(method, url) {
      const root = this.root[method];
      if (!root)
        return null;
      return matchRoute2(url, url.length, root, 0);
    }
  };
  var matchRoute2 = (url, urlLength, node, startIndex) => {
    const part = node.part;
    const length = part.length;
    const endIndex = startIndex + length;
    if (length > 1) {
      if (endIndex > urlLength)
        return null;
      if (length < 15) {
        for (let i = 1, j = startIndex + 1;i < length; ++i, ++j)
          if (part.charCodeAt(i) !== url.charCodeAt(j))
            return null;
      } else if (url.slice(startIndex, endIndex) !== part)
        return null;
    }
    if (endIndex === urlLength) {
      if (node.store !== null)
        return {
          store: node.store,
          params: {}
        };
      if (node.wildcardStore !== null)
        return {
          store: node.wildcardStore,
          params: { "*": "" }
        };
      return null;
    }
    if (node.inert !== null) {
      const inert = node.inert[url.charCodeAt(endIndex)];
      if (inert !== undefined) {
        const route = matchRoute2(url, urlLength, inert, endIndex);
        if (route !== null)
          return route;
      }
    }
    if (node.params !== null) {
      const { store, name, inert } = node.params;
      const slashIndex = url.indexOf("/", endIndex);
      if (slashIndex !== endIndex) {
        if (slashIndex === -1 || slashIndex >= urlLength) {
          if (store !== null) {
            const params = {};
            params[name] = url.substring(endIndex, urlLength);
            return {
              store,
              params
            };
          }
        } else if (inert !== null) {
          const route = matchRoute2(url, urlLength, inert, slashIndex);
          if (route !== null) {
            route.params[name] = url.substring(endIndex, slashIndex);
            return route;
          }
        }
      }
    }
    if (node.wildcardStore !== null)
      return {
        store: node.wildcardStore,
        params: {
          "*": url.substring(endIndex, urlLength)
        }
      };
    return null;
  };
  var src_default = Memoirist2;
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/value.js
var require_value = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HasPropertyKey = HasPropertyKey3;
  exports.IsAsyncIterator = IsAsyncIterator5;
  exports.IsArray = IsArray5;
  exports.IsBigInt = IsBigInt5;
  exports.IsBoolean = IsBoolean5;
  exports.IsDate = IsDate5;
  exports.IsFunction = IsFunction5;
  exports.IsIterator = IsIterator5;
  exports.IsNull = IsNull5;
  exports.IsNumber = IsNumber5;
  exports.IsObject = IsObject5;
  exports.IsRegExp = IsRegExp4;
  exports.IsString = IsString5;
  exports.IsSymbol = IsSymbol5;
  exports.IsUint8Array = IsUint8Array5;
  exports.IsUndefined = IsUndefined5;
  function HasPropertyKey3(value, key) {
    return key in value;
  }
  function IsAsyncIterator5(value) {
    return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.asyncIterator in value;
  }
  function IsArray5(value) {
    return Array.isArray(value);
  }
  function IsBigInt5(value) {
    return typeof value === "bigint";
  }
  function IsBoolean5(value) {
    return typeof value === "boolean";
  }
  function IsDate5(value) {
    return value instanceof globalThis.Date;
  }
  function IsFunction5(value) {
    return typeof value === "function";
  }
  function IsIterator5(value) {
    return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.iterator in value;
  }
  function IsNull5(value) {
    return value === null;
  }
  function IsNumber5(value) {
    return typeof value === "number";
  }
  function IsObject5(value) {
    return typeof value === "object" && value !== null;
  }
  function IsRegExp4(value) {
    return value instanceof globalThis.RegExp;
  }
  function IsString5(value) {
    return typeof value === "string";
  }
  function IsSymbol5(value) {
    return typeof value === "symbol";
  }
  function IsUint8Array5(value) {
    return value instanceof globalThis.Uint8Array;
  }
  function IsUndefined5(value) {
    return value === undefined;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/value.js
var require_value2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = Clone3;
  var ValueGuard = require_value();
  function ArrayType6(value) {
    return value.map((value2) => Visit17(value2));
  }
  function DateType4(value) {
    return new Date(value.getTime());
  }
  function Uint8ArrayType3(value) {
    return new Uint8Array(value);
  }
  function RegExpType2(value) {
    return new RegExp(value.source, value.flags);
  }
  function ObjectType6(value) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value)) {
      result[key] = Visit17(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      result[key] = Visit17(value[key]);
    }
    return result;
  }
  function Visit17(value) {
    return ValueGuard.IsArray(value) ? ArrayType6(value) : ValueGuard.IsDate(value) ? DateType4(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType3(value) : ValueGuard.IsRegExp(value) ? RegExpType2(value) : ValueGuard.IsObject(value) ? ObjectType6(value) : value;
  }
  function Clone3(value) {
    return Visit17(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/type.js
var require_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CloneRest = CloneRest;
  exports.CloneType = CloneType2;
  var value_1 = require_value2();
  function CloneRest(schemas) {
    return schemas.map((schema) => CloneType2(schema));
  }
  function CloneType2(schema, options) {
    return options === undefined ? (0, value_1.Clone)(schema) : (0, value_1.Clone)({ ...options, ...schema });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/index.js
var require_clone2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_type(), exports);
  __exportStar(require_value2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/guard.js
var require_guard = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsAsyncIterator = IsAsyncIterator5;
  exports.IsIterator = IsIterator5;
  exports.IsStandardObject = IsStandardObject3;
  exports.IsInstanceObject = IsInstanceObject;
  exports.IsPromise = IsPromise4;
  exports.IsDate = IsDate5;
  exports.IsMap = IsMap2;
  exports.IsSet = IsSet2;
  exports.IsRegExp = IsRegExp4;
  exports.IsTypedArray = IsTypedArray2;
  exports.IsInt8Array = IsInt8Array;
  exports.IsUint8Array = IsUint8Array5;
  exports.IsUint8ClampedArray = IsUint8ClampedArray;
  exports.IsInt16Array = IsInt16Array;
  exports.IsUint16Array = IsUint16Array;
  exports.IsInt32Array = IsInt32Array;
  exports.IsUint32Array = IsUint32Array;
  exports.IsFloat32Array = IsFloat32Array;
  exports.IsFloat64Array = IsFloat64Array;
  exports.IsBigInt64Array = IsBigInt64Array;
  exports.IsBigUint64Array = IsBigUint64Array;
  exports.HasPropertyKey = HasPropertyKey3;
  exports.IsObject = IsObject5;
  exports.IsArray = IsArray5;
  exports.IsUndefined = IsUndefined5;
  exports.IsNull = IsNull5;
  exports.IsBoolean = IsBoolean5;
  exports.IsNumber = IsNumber5;
  exports.IsInteger = IsInteger4;
  exports.IsBigInt = IsBigInt5;
  exports.IsString = IsString5;
  exports.IsFunction = IsFunction5;
  exports.IsSymbol = IsSymbol5;
  exports.IsValueType = IsValueType2;
  function IsAsyncIterator5(value) {
    return IsObject5(value) && globalThis.Symbol.asyncIterator in value;
  }
  function IsIterator5(value) {
    return IsObject5(value) && globalThis.Symbol.iterator in value;
  }
  function IsStandardObject3(value) {
    return IsObject5(value) && (globalThis.Object.getPrototypeOf(value) === Object.prototype || globalThis.Object.getPrototypeOf(value) === null);
  }
  function IsInstanceObject(value) {
    return IsObject5(value) && !IsArray5(value) && IsFunction5(value.constructor) && value.constructor.name !== "Object";
  }
  function IsPromise4(value) {
    return value instanceof globalThis.Promise;
  }
  function IsDate5(value) {
    return value instanceof Date && globalThis.Number.isFinite(value.getTime());
  }
  function IsMap2(value) {
    return value instanceof globalThis.Map;
  }
  function IsSet2(value) {
    return value instanceof globalThis.Set;
  }
  function IsRegExp4(value) {
    return value instanceof globalThis.RegExp;
  }
  function IsTypedArray2(value) {
    return globalThis.ArrayBuffer.isView(value);
  }
  function IsInt8Array(value) {
    return value instanceof globalThis.Int8Array;
  }
  function IsUint8Array5(value) {
    return value instanceof globalThis.Uint8Array;
  }
  function IsUint8ClampedArray(value) {
    return value instanceof globalThis.Uint8ClampedArray;
  }
  function IsInt16Array(value) {
    return value instanceof globalThis.Int16Array;
  }
  function IsUint16Array(value) {
    return value instanceof globalThis.Uint16Array;
  }
  function IsInt32Array(value) {
    return value instanceof globalThis.Int32Array;
  }
  function IsUint32Array(value) {
    return value instanceof globalThis.Uint32Array;
  }
  function IsFloat32Array(value) {
    return value instanceof globalThis.Float32Array;
  }
  function IsFloat64Array(value) {
    return value instanceof globalThis.Float64Array;
  }
  function IsBigInt64Array(value) {
    return value instanceof globalThis.BigInt64Array;
  }
  function IsBigUint64Array(value) {
    return value instanceof globalThis.BigUint64Array;
  }
  function HasPropertyKey3(value, key) {
    return key in value;
  }
  function IsObject5(value) {
    return value !== null && typeof value === "object";
  }
  function IsArray5(value) {
    return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
  }
  function IsUndefined5(value) {
    return value === undefined;
  }
  function IsNull5(value) {
    return value === null;
  }
  function IsBoolean5(value) {
    return typeof value === "boolean";
  }
  function IsNumber5(value) {
    return typeof value === "number";
  }
  function IsInteger4(value) {
    return globalThis.Number.isInteger(value);
  }
  function IsBigInt5(value) {
    return typeof value === "bigint";
  }
  function IsString5(value) {
    return typeof value === "string";
  }
  function IsFunction5(value) {
    return typeof value === "function";
  }
  function IsSymbol5(value) {
    return typeof value === "symbol";
  }
  function IsValueType2(value) {
    return IsBigInt5(value) || IsBoolean5(value) || IsNull5(value) || IsNumber5(value) || IsString5(value) || IsSymbol5(value) || IsUndefined5(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/index.js
var require_guard2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_guard(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/system/policy.js
var require_policy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSystemPolicy = undefined;
  var index_1 = require_guard2();
  var TypeSystemPolicy3;
  (function(TypeSystemPolicy4) {
    TypeSystemPolicy4.InstanceMode = "default";
    TypeSystemPolicy4.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy4.AllowArrayObject = false;
    TypeSystemPolicy4.AllowNaN = false;
    TypeSystemPolicy4.AllowNullVoid = false;
    function IsExactOptionalProperty(value, key) {
      return TypeSystemPolicy4.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
    }
    TypeSystemPolicy4.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      const isObject2 = (0, index_1.IsObject)(value);
      return TypeSystemPolicy4.AllowArrayObject ? isObject2 : isObject2 && !(0, index_1.IsArray)(value);
    }
    TypeSystemPolicy4.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
    }
    TypeSystemPolicy4.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      return TypeSystemPolicy4.AllowNaN ? (0, index_1.IsNumber)(value) : Number.isFinite(value);
    }
    TypeSystemPolicy4.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      const isUndefined = (0, index_1.IsUndefined)(value);
      return TypeSystemPolicy4.AllowNullVoid ? isUndefined || value === null : isUndefined;
    }
    TypeSystemPolicy4.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy3 || (exports.TypeSystemPolicy = TypeSystemPolicy3 = {}));
});

// node_modules/@sinclair/typebox/build/cjs/type/create/immutable.js
var require_immutable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Immutable = Immutable2;
  var ValueGuard = require_value();
  function ImmutableArray2(value) {
    return globalThis.Object.freeze(value).map((value2) => Immutable2(value2));
  }
  function ImmutableDate2(value) {
    return value;
  }
  function ImmutableUint8Array2(value) {
    return value;
  }
  function ImmutableRegExp2(value) {
    return value;
  }
  function ImmutableObject2(value) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value)) {
      result[key] = Immutable2(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      result[key] = Immutable2(value[key]);
    }
    return globalThis.Object.freeze(result);
  }
  function Immutable2(value) {
    return ValueGuard.IsArray(value) ? ImmutableArray2(value) : ValueGuard.IsDate(value) ? ImmutableDate2(value) : ValueGuard.IsUint8Array(value) ? ImmutableUint8Array2(value) : ValueGuard.IsRegExp(value) ? ImmutableRegExp2(value) : ValueGuard.IsObject(value) ? ImmutableObject2(value) : value;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/create/type.js
var require_type2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateType = CreateType2;
  var policy_1 = require_policy();
  var immutable_1 = require_immutable();
  var value_1 = require_value2();
  function CreateType2(schema, options) {
    const result = options !== undefined ? { ...options, ...schema } : schema;
    switch (policy_1.TypeSystemPolicy.InstanceMode) {
      case "freeze":
        return (0, immutable_1.Immutable)(result);
      case "clone":
        return (0, value_1.Clone)(result);
      default:
        return result;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/create/index.js
var require_create = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_type2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/error/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeBoxError = undefined;

  class TypeBoxError2 extends Error {
    constructor(message) {
      super(message);
    }
  }
  exports.TypeBoxError = TypeBoxError2;
});

// node_modules/@sinclair/typebox/build/cjs/type/error/index.js
var require_error2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_error(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/symbols.js
var require_symbols = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Kind = exports.Hint = exports.OptionalKind = exports.ReadonlyKind = exports.TransformKind = undefined;
  exports.TransformKind = Symbol.for("TypeBox.Transform");
  exports.ReadonlyKind = Symbol.for("TypeBox.Readonly");
  exports.OptionalKind = Symbol.for("TypeBox.Optional");
  exports.Hint = Symbol.for("TypeBox.Hint");
  exports.Kind = Symbol.for("TypeBox.Kind");
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/index.js
var require_symbols2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_symbols(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/kind.js
var require_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsReadonly = IsReadonly3;
  exports.IsOptional = IsOptional3;
  exports.IsAny = IsAny3;
  exports.IsArgument = IsArgument3;
  exports.IsArray = IsArray5;
  exports.IsAsyncIterator = IsAsyncIterator5;
  exports.IsBigInt = IsBigInt5;
  exports.IsBoolean = IsBoolean5;
  exports.IsComputed = IsComputed3;
  exports.IsConstructor = IsConstructor3;
  exports.IsDate = IsDate5;
  exports.IsFunction = IsFunction5;
  exports.IsImport = IsImport2;
  exports.IsInteger = IsInteger4;
  exports.IsProperties = IsProperties2;
  exports.IsIntersect = IsIntersect3;
  exports.IsIterator = IsIterator5;
  exports.IsKindOf = IsKindOf3;
  exports.IsLiteralString = IsLiteralString2;
  exports.IsLiteralNumber = IsLiteralNumber2;
  exports.IsLiteralBoolean = IsLiteralBoolean2;
  exports.IsLiteralValue = IsLiteralValue3;
  exports.IsLiteral = IsLiteral3;
  exports.IsMappedKey = IsMappedKey3;
  exports.IsMappedResult = IsMappedResult3;
  exports.IsNever = IsNever3;
  exports.IsNot = IsNot3;
  exports.IsNull = IsNull5;
  exports.IsNumber = IsNumber5;
  exports.IsObject = IsObject5;
  exports.IsPromise = IsPromise4;
  exports.IsRecord = IsRecord3;
  exports.IsRecursive = IsRecursive2;
  exports.IsRef = IsRef3;
  exports.IsRegExp = IsRegExp4;
  exports.IsString = IsString5;
  exports.IsSymbol = IsSymbol5;
  exports.IsTemplateLiteral = IsTemplateLiteral3;
  exports.IsThis = IsThis3;
  exports.IsTransform = IsTransform3;
  exports.IsTuple = IsTuple3;
  exports.IsUndefined = IsUndefined5;
  exports.IsUnion = IsUnion3;
  exports.IsUint8Array = IsUint8Array5;
  exports.IsUnknown = IsUnknown3;
  exports.IsUnsafe = IsUnsafe3;
  exports.IsVoid = IsVoid3;
  exports.IsKind = IsKind3;
  exports.IsSchema = IsSchema3;
  var ValueGuard = require_value();
  var index_1 = require_symbols2();
  function IsReadonly3(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional3(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
  }
  function IsAny3(value) {
    return IsKindOf3(value, "Any");
  }
  function IsArgument3(value) {
    return IsKindOf3(value, "Argument");
  }
  function IsArray5(value) {
    return IsKindOf3(value, "Array");
  }
  function IsAsyncIterator5(value) {
    return IsKindOf3(value, "AsyncIterator");
  }
  function IsBigInt5(value) {
    return IsKindOf3(value, "BigInt");
  }
  function IsBoolean5(value) {
    return IsKindOf3(value, "Boolean");
  }
  function IsComputed3(value) {
    return IsKindOf3(value, "Computed");
  }
  function IsConstructor3(value) {
    return IsKindOf3(value, "Constructor");
  }
  function IsDate5(value) {
    return IsKindOf3(value, "Date");
  }
  function IsFunction5(value) {
    return IsKindOf3(value, "Function");
  }
  function IsImport2(value) {
    return IsKindOf3(value, "Import");
  }
  function IsInteger4(value) {
    return IsKindOf3(value, "Integer");
  }
  function IsProperties2(value) {
    return ValueGuard.IsObject(value);
  }
  function IsIntersect3(value) {
    return IsKindOf3(value, "Intersect");
  }
  function IsIterator5(value) {
    return IsKindOf3(value, "Iterator");
  }
  function IsKindOf3(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
  }
  function IsLiteralString2(value) {
    return IsLiteral3(value) && ValueGuard.IsString(value.const);
  }
  function IsLiteralNumber2(value) {
    return IsLiteral3(value) && ValueGuard.IsNumber(value.const);
  }
  function IsLiteralBoolean2(value) {
    return IsLiteral3(value) && ValueGuard.IsBoolean(value.const);
  }
  function IsLiteralValue3(value) {
    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);
  }
  function IsLiteral3(value) {
    return IsKindOf3(value, "Literal");
  }
  function IsMappedKey3(value) {
    return IsKindOf3(value, "MappedKey");
  }
  function IsMappedResult3(value) {
    return IsKindOf3(value, "MappedResult");
  }
  function IsNever3(value) {
    return IsKindOf3(value, "Never");
  }
  function IsNot3(value) {
    return IsKindOf3(value, "Not");
  }
  function IsNull5(value) {
    return IsKindOf3(value, "Null");
  }
  function IsNumber5(value) {
    return IsKindOf3(value, "Number");
  }
  function IsObject5(value) {
    return IsKindOf3(value, "Object");
  }
  function IsPromise4(value) {
    return IsKindOf3(value, "Promise");
  }
  function IsRecord3(value) {
    return IsKindOf3(value, "Record");
  }
  function IsRecursive2(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
  }
  function IsRef3(value) {
    return IsKindOf3(value, "Ref");
  }
  function IsRegExp4(value) {
    return IsKindOf3(value, "RegExp");
  }
  function IsString5(value) {
    return IsKindOf3(value, "String");
  }
  function IsSymbol5(value) {
    return IsKindOf3(value, "Symbol");
  }
  function IsTemplateLiteral3(value) {
    return IsKindOf3(value, "TemplateLiteral");
  }
  function IsThis3(value) {
    return IsKindOf3(value, "This");
  }
  function IsTransform3(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
  }
  function IsTuple3(value) {
    return IsKindOf3(value, "Tuple");
  }
  function IsUndefined5(value) {
    return IsKindOf3(value, "Undefined");
  }
  function IsUnion3(value) {
    return IsKindOf3(value, "Union");
  }
  function IsUint8Array5(value) {
    return IsKindOf3(value, "Uint8Array");
  }
  function IsUnknown3(value) {
    return IsKindOf3(value, "Unknown");
  }
  function IsUnsafe3(value) {
    return IsKindOf3(value, "Unsafe");
  }
  function IsVoid3(value) {
    return IsKindOf3(value, "Void");
  }
  function IsKind3(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]);
  }
  function IsSchema3(value) {
    return IsAny3(value) || IsArgument3(value) || IsArray5(value) || IsBoolean5(value) || IsBigInt5(value) || IsAsyncIterator5(value) || IsComputed3(value) || IsConstructor3(value) || IsDate5(value) || IsFunction5(value) || IsInteger4(value) || IsIntersect3(value) || IsIterator5(value) || IsLiteral3(value) || IsMappedKey3(value) || IsMappedResult3(value) || IsNever3(value) || IsNot3(value) || IsNull5(value) || IsNumber5(value) || IsObject5(value) || IsPromise4(value) || IsRecord3(value) || IsRef3(value) || IsRegExp4(value) || IsString5(value) || IsSymbol5(value) || IsTemplateLiteral3(value) || IsThis3(value) || IsTuple3(value) || IsUndefined5(value) || IsUnion3(value) || IsUint8Array5(value) || IsUnknown3(value) || IsUnsafe3(value) || IsVoid3(value) || IsKind3(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/type.js
var require_type3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeGuardUnknownTypeError = undefined;
  exports.IsReadonly = IsReadonly3;
  exports.IsOptional = IsOptional3;
  exports.IsAny = IsAny3;
  exports.IsArgument = IsArgument3;
  exports.IsArray = IsArray5;
  exports.IsAsyncIterator = IsAsyncIterator5;
  exports.IsBigInt = IsBigInt5;
  exports.IsBoolean = IsBoolean5;
  exports.IsComputed = IsComputed3;
  exports.IsConstructor = IsConstructor3;
  exports.IsDate = IsDate5;
  exports.IsFunction = IsFunction5;
  exports.IsImport = IsImport2;
  exports.IsInteger = IsInteger4;
  exports.IsProperties = IsProperties2;
  exports.IsIntersect = IsIntersect3;
  exports.IsIterator = IsIterator5;
  exports.IsKindOf = IsKindOf3;
  exports.IsLiteralString = IsLiteralString2;
  exports.IsLiteralNumber = IsLiteralNumber2;
  exports.IsLiteralBoolean = IsLiteralBoolean2;
  exports.IsLiteral = IsLiteral3;
  exports.IsLiteralValue = IsLiteralValue3;
  exports.IsMappedKey = IsMappedKey3;
  exports.IsMappedResult = IsMappedResult3;
  exports.IsNever = IsNever3;
  exports.IsNot = IsNot3;
  exports.IsNull = IsNull5;
  exports.IsNumber = IsNumber5;
  exports.IsObject = IsObject5;
  exports.IsPromise = IsPromise4;
  exports.IsRecord = IsRecord3;
  exports.IsRecursive = IsRecursive2;
  exports.IsRef = IsRef3;
  exports.IsRegExp = IsRegExp4;
  exports.IsString = IsString5;
  exports.IsSymbol = IsSymbol5;
  exports.IsTemplateLiteral = IsTemplateLiteral3;
  exports.IsThis = IsThis3;
  exports.IsTransform = IsTransform3;
  exports.IsTuple = IsTuple3;
  exports.IsUndefined = IsUndefined5;
  exports.IsUnionLiteral = IsUnionLiteral2;
  exports.IsUnion = IsUnion3;
  exports.IsUint8Array = IsUint8Array5;
  exports.IsUnknown = IsUnknown3;
  exports.IsUnsafe = IsUnsafe3;
  exports.IsVoid = IsVoid3;
  exports.IsKind = IsKind3;
  exports.IsSchema = IsSchema3;
  var ValueGuard = require_value();
  var index_1 = require_symbols2();
  var index_2 = require_error2();

  class TypeGuardUnknownTypeError2 extends index_2.TypeBoxError {
  }
  exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError2;
  var KnownTypes2 = [
    "Argument",
    "Any",
    "Array",
    "AsyncIterator",
    "BigInt",
    "Boolean",
    "Computed",
    "Constructor",
    "Date",
    "Enum",
    "Function",
    "Integer",
    "Intersect",
    "Iterator",
    "Literal",
    "MappedKey",
    "MappedResult",
    "Not",
    "Null",
    "Number",
    "Object",
    "Promise",
    "Record",
    "Ref",
    "RegExp",
    "String",
    "Symbol",
    "TemplateLiteral",
    "This",
    "Tuple",
    "Undefined",
    "Union",
    "Uint8Array",
    "Unknown",
    "Void"
  ];
  function IsPattern2(value) {
    try {
      new RegExp(value);
      return true;
    } catch {
      return false;
    }
  }
  function IsControlCharacterFree2(value) {
    if (!ValueGuard.IsString(value))
      return false;
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      if (code >= 7 && code <= 13 || code === 27 || code === 127) {
        return false;
      }
    }
    return true;
  }
  function IsAdditionalProperties2(value) {
    return IsOptionalBoolean2(value) || IsSchema3(value);
  }
  function IsOptionalBigInt2(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
  }
  function IsOptionalNumber2(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
  }
  function IsOptionalBoolean2(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
  }
  function IsOptionalString2(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
  }
  function IsOptionalPattern2(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree2(value) && IsPattern2(value);
  }
  function IsOptionalFormat2(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree2(value);
  }
  function IsOptionalSchema2(value) {
    return ValueGuard.IsUndefined(value) || IsSchema3(value);
  }
  function IsReadonly3(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional3(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
  }
  function IsAny3(value) {
    return IsKindOf3(value, "Any") && IsOptionalString2(value.$id);
  }
  function IsArgument3(value) {
    return IsKindOf3(value, "Argument") && ValueGuard.IsNumber(value.index);
  }
  function IsArray5(value) {
    return IsKindOf3(value, "Array") && value.type === "array" && IsOptionalString2(value.$id) && IsSchema3(value.items) && IsOptionalNumber2(value.minItems) && IsOptionalNumber2(value.maxItems) && IsOptionalBoolean2(value.uniqueItems) && IsOptionalSchema2(value.contains) && IsOptionalNumber2(value.minContains) && IsOptionalNumber2(value.maxContains);
  }
  function IsAsyncIterator5(value) {
    return IsKindOf3(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString2(value.$id) && IsSchema3(value.items);
  }
  function IsBigInt5(value) {
    return IsKindOf3(value, "BigInt") && value.type === "bigint" && IsOptionalString2(value.$id) && IsOptionalBigInt2(value.exclusiveMaximum) && IsOptionalBigInt2(value.exclusiveMinimum) && IsOptionalBigInt2(value.maximum) && IsOptionalBigInt2(value.minimum) && IsOptionalBigInt2(value.multipleOf);
  }
  function IsBoolean5(value) {
    return IsKindOf3(value, "Boolean") && value.type === "boolean" && IsOptionalString2(value.$id);
  }
  function IsComputed3(value) {
    return IsKindOf3(value, "Computed") && ValueGuard.IsString(value.target) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema3(schema));
  }
  function IsConstructor3(value) {
    return IsKindOf3(value, "Constructor") && value.type === "Constructor" && IsOptionalString2(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema3(schema)) && IsSchema3(value.returns);
  }
  function IsDate5(value) {
    return IsKindOf3(value, "Date") && value.type === "Date" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximumTimestamp) && IsOptionalNumber2(value.exclusiveMinimumTimestamp) && IsOptionalNumber2(value.maximumTimestamp) && IsOptionalNumber2(value.minimumTimestamp) && IsOptionalNumber2(value.multipleOfTimestamp);
  }
  function IsFunction5(value) {
    return IsKindOf3(value, "Function") && value.type === "Function" && IsOptionalString2(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema3(schema)) && IsSchema3(value.returns);
  }
  function IsImport2(value) {
    return IsKindOf3(value, "Import") && ValueGuard.HasPropertyKey(value, "$defs") && ValueGuard.IsObject(value.$defs) && IsProperties2(value.$defs) && ValueGuard.HasPropertyKey(value, "$ref") && ValueGuard.IsString(value.$ref) && value.$ref in value.$defs;
  }
  function IsInteger4(value) {
    return IsKindOf3(value, "Integer") && value.type === "integer" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
  }
  function IsProperties2(value) {
    return ValueGuard.IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree2(key) && IsSchema3(schema));
  }
  function IsIntersect3(value) {
    return IsKindOf3(value, "Intersect") && (ValueGuard.IsString(value.type) && value.type !== "object" ? false : true) && ValueGuard.IsArray(value.allOf) && value.allOf.every((schema) => IsSchema3(schema) && !IsTransform3(schema)) && IsOptionalString2(value.type) && (IsOptionalBoolean2(value.unevaluatedProperties) || IsOptionalSchema2(value.unevaluatedProperties)) && IsOptionalString2(value.$id);
  }
  function IsIterator5(value) {
    return IsKindOf3(value, "Iterator") && value.type === "Iterator" && IsOptionalString2(value.$id) && IsSchema3(value.items);
  }
  function IsKindOf3(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
  }
  function IsLiteralString2(value) {
    return IsLiteral3(value) && ValueGuard.IsString(value.const);
  }
  function IsLiteralNumber2(value) {
    return IsLiteral3(value) && ValueGuard.IsNumber(value.const);
  }
  function IsLiteralBoolean2(value) {
    return IsLiteral3(value) && ValueGuard.IsBoolean(value.const);
  }
  function IsLiteral3(value) {
    return IsKindOf3(value, "Literal") && IsOptionalString2(value.$id) && IsLiteralValue3(value.const);
  }
  function IsLiteralValue3(value) {
    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);
  }
  function IsMappedKey3(value) {
    return IsKindOf3(value, "MappedKey") && ValueGuard.IsArray(value.keys) && value.keys.every((key) => ValueGuard.IsNumber(key) || ValueGuard.IsString(key));
  }
  function IsMappedResult3(value) {
    return IsKindOf3(value, "MappedResult") && IsProperties2(value.properties);
  }
  function IsNever3(value) {
    return IsKindOf3(value, "Never") && ValueGuard.IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
  }
  function IsNot3(value) {
    return IsKindOf3(value, "Not") && IsSchema3(value.not);
  }
  function IsNull5(value) {
    return IsKindOf3(value, "Null") && value.type === "null" && IsOptionalString2(value.$id);
  }
  function IsNumber5(value) {
    return IsKindOf3(value, "Number") && value.type === "number" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
  }
  function IsObject5(value) {
    return IsKindOf3(value, "Object") && value.type === "object" && IsOptionalString2(value.$id) && IsProperties2(value.properties) && IsAdditionalProperties2(value.additionalProperties) && IsOptionalNumber2(value.minProperties) && IsOptionalNumber2(value.maxProperties);
  }
  function IsPromise4(value) {
    return IsKindOf3(value, "Promise") && value.type === "Promise" && IsOptionalString2(value.$id) && IsSchema3(value.item);
  }
  function IsRecord3(value) {
    return IsKindOf3(value, "Record") && value.type === "object" && IsOptionalString2(value.$id) && IsAdditionalProperties2(value.additionalProperties) && ValueGuard.IsObject(value.patternProperties) && ((schema) => {
      const keys = Object.getOwnPropertyNames(schema.patternProperties);
      return keys.length === 1 && IsPattern2(keys[0]) && ValueGuard.IsObject(schema.patternProperties) && IsSchema3(schema.patternProperties[keys[0]]);
    })(value);
  }
  function IsRecursive2(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
  }
  function IsRef3(value) {
    return IsKindOf3(value, "Ref") && IsOptionalString2(value.$id) && ValueGuard.IsString(value.$ref);
  }
  function IsRegExp4(value) {
    return IsKindOf3(value, "RegExp") && IsOptionalString2(value.$id) && ValueGuard.IsString(value.source) && ValueGuard.IsString(value.flags) && IsOptionalNumber2(value.maxLength) && IsOptionalNumber2(value.minLength);
  }
  function IsString5(value) {
    return IsKindOf3(value, "String") && value.type === "string" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minLength) && IsOptionalNumber2(value.maxLength) && IsOptionalPattern2(value.pattern) && IsOptionalFormat2(value.format);
  }
  function IsSymbol5(value) {
    return IsKindOf3(value, "Symbol") && value.type === "symbol" && IsOptionalString2(value.$id);
  }
  function IsTemplateLiteral3(value) {
    return IsKindOf3(value, "TemplateLiteral") && value.type === "string" && ValueGuard.IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
  }
  function IsThis3(value) {
    return IsKindOf3(value, "This") && IsOptionalString2(value.$id) && ValueGuard.IsString(value.$ref);
  }
  function IsTransform3(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
  }
  function IsTuple3(value) {
    return IsKindOf3(value, "Tuple") && value.type === "array" && IsOptionalString2(value.$id) && ValueGuard.IsNumber(value.minItems) && ValueGuard.IsNumber(value.maxItems) && value.minItems === value.maxItems && (ValueGuard.IsUndefined(value.items) && ValueGuard.IsUndefined(value.additionalItems) && value.minItems === 0 || ValueGuard.IsArray(value.items) && value.items.every((schema) => IsSchema3(schema)));
  }
  function IsUndefined5(value) {
    return IsKindOf3(value, "Undefined") && value.type === "undefined" && IsOptionalString2(value.$id);
  }
  function IsUnionLiteral2(value) {
    return IsUnion3(value) && value.anyOf.every((schema) => IsLiteralString2(schema) || IsLiteralNumber2(schema));
  }
  function IsUnion3(value) {
    return IsKindOf3(value, "Union") && IsOptionalString2(value.$id) && ValueGuard.IsObject(value) && ValueGuard.IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema3(schema));
  }
  function IsUint8Array5(value) {
    return IsKindOf3(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minByteLength) && IsOptionalNumber2(value.maxByteLength);
  }
  function IsUnknown3(value) {
    return IsKindOf3(value, "Unknown") && IsOptionalString2(value.$id);
  }
  function IsUnsafe3(value) {
    return IsKindOf3(value, "Unsafe");
  }
  function IsVoid3(value) {
    return IsKindOf3(value, "Void") && value.type === "void" && IsOptionalString2(value.$id);
  }
  function IsKind3(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]) && !KnownTypes2.includes(value[index_1.Kind]);
  }
  function IsSchema3(value) {
    return ValueGuard.IsObject(value) && (IsAny3(value) || IsArgument3(value) || IsArray5(value) || IsBoolean5(value) || IsBigInt5(value) || IsAsyncIterator5(value) || IsComputed3(value) || IsConstructor3(value) || IsDate5(value) || IsFunction5(value) || IsInteger4(value) || IsIntersect3(value) || IsIterator5(value) || IsLiteral3(value) || IsMappedKey3(value) || IsMappedResult3(value) || IsNever3(value) || IsNot3(value) || IsNull5(value) || IsNumber5(value) || IsObject5(value) || IsPromise4(value) || IsRecord3(value) || IsRef3(value) || IsRegExp4(value) || IsString5(value) || IsSymbol5(value) || IsTemplateLiteral3(value) || IsThis3(value) || IsTuple3(value) || IsUndefined5(value) || IsUnion3(value) || IsUint8Array5(value) || IsUnknown3(value) || IsUnsafe3(value) || IsVoid3(value) || IsKind3(value));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/index.js
var require_guard3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueGuard = exports.TypeGuard = exports.KindGuard = undefined;
  exports.KindGuard = require_kind();
  exports.TypeGuard = require_type3();
  exports.ValueGuard = require_value();
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Increment = Increment;
  function Increment(T) {
    return (parseInt(T) + 1).toString();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/index.js
var require_helpers2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_helpers(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/patterns.js
var require_patterns = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PatternNeverExact = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternNever = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = undefined;
  exports.PatternBoolean = "(true|false)";
  exports.PatternNumber = "(0|[1-9][0-9]*)";
  exports.PatternString = "(.*)";
  exports.PatternNever = "(?!.*)";
  exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
  exports.PatternNumberExact = `^${exports.PatternNumber}$`;
  exports.PatternStringExact = `^${exports.PatternString}$`;
  exports.PatternNeverExact = `^${exports.PatternNever}$`;
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/index.js
var require_patterns2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_patterns(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/format.js
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Entries = Entries3;
  exports.Clear = Clear3;
  exports.Delete = Delete5;
  exports.Has = Has4;
  exports.Set = Set5;
  exports.Get = Get4;
  var map3 = new Map;
  function Entries3() {
    return new Map(map3);
  }
  function Clear3() {
    return map3.clear();
  }
  function Delete5(format) {
    return map3.delete(format);
  }
  function Has4(format) {
    return map3.has(format);
  }
  function Set5(format, func) {
    map3.set(format, func);
  }
  function Get4(format) {
    return map3.get(format);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/type.js
var require_type4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Entries = Entries3;
  exports.Clear = Clear3;
  exports.Delete = Delete5;
  exports.Has = Has4;
  exports.Set = Set5;
  exports.Get = Get4;
  var map3 = new Map;
  function Entries3() {
    return new Map(map3);
  }
  function Clear3() {
    return map3.clear();
  }
  function Delete5(kind) {
    return map3.delete(kind);
  }
  function Has4(kind) {
    return map3.has(kind);
  }
  function Set5(kind, func) {
    map3.set(kind, func);
  }
  function Get4(kind) {
    return map3.get(kind);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/index.js
var require_registry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeRegistry = exports.FormatRegistry = undefined;
  exports.FormatRegistry = require_format();
  exports.TypeRegistry = require_type4();
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/set.js
var require_set = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SetIncludes = SetIncludes2;
  exports.SetIsSubset = SetIsSubset;
  exports.SetDistinct = SetDistinct2;
  exports.SetIntersect = SetIntersect2;
  exports.SetUnion = SetUnion;
  exports.SetComplement = SetComplement;
  exports.SetIntersectMany = SetIntersectMany2;
  exports.SetUnionMany = SetUnionMany2;
  function SetIncludes2(T, S) {
    return T.includes(S);
  }
  function SetIsSubset(T, S) {
    return T.every((L) => SetIncludes2(S, L));
  }
  function SetDistinct2(T) {
    return [...new Set(T)];
  }
  function SetIntersect2(T, S) {
    return T.filter((L) => S.includes(L));
  }
  function SetUnion(T, S) {
    return [...T, ...S];
  }
  function SetComplement(T, S) {
    return T.filter((L) => !S.includes(L));
  }
  function SetIntersectManyResolve2(T, Init) {
    return T.reduce((Acc, L) => {
      return SetIntersect2(Acc, L);
    }, Init);
  }
  function SetIntersectMany2(T) {
    return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve2(T.slice(1), T[0]) : [];
  }
  function SetUnionMany2(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...L);
    return Acc;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/index.js
var require_sets = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_set(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/any/any.js
var require_any = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Any = Any2;
  var index_1 = require_create();
  var index_2 = require_symbols2();
  function Any2(options) {
    return (0, index_1.CreateType)({ [index_2.Kind]: "Any" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/any/index.js
var require_any2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_any(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/array/array.js
var require_array = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Array = Array3;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Array3(items, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Array", type: "array", items }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/array/index.js
var require_array2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_array(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/argument/argument.js
var require_argument = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Argument = Argument2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Argument2(index) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Argument", index });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/argument/index.js
var require_argument2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_argument(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/async-iterator.js
var require_async_iterator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncIterator = AsyncIterator2;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  function AsyncIterator2(items, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/index.js
var require_async_iterator2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_async_iterator(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/computed/computed.js
var require_computed = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Computed = Computed2;
  var index_1 = require_create();
  var symbols_1 = require_symbols();
  function Computed2(target, parameters, options) {
    return (0, index_1.CreateType)({ [symbols_1.Kind]: "Computed", target, parameters }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/computed/index.js
var require_computed2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_computed(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/discard.js
var require_discard = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Discard = Discard2;
  function DiscardKey2(value, key) {
    const { [key]: _, ...rest } = value;
    return rest;
  }
  function Discard2(value, keys) {
    return keys.reduce((acc, key) => DiscardKey2(acc, key), value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/index.js
var require_discard2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_discard(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/never/never.js
var require_never = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Never = Never2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Never2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Never", not: {} }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/never/index.js
var require_never2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_never(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-key.js
var require_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedKey = MappedKey;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function MappedKey(T) {
    return (0, type_1.CreateType)({
      [index_1.Kind]: "MappedKey",
      keys: T
    });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-result.js
var require_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedResult = MappedResult2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function MappedResult2(properties) {
    return (0, type_1.CreateType)({
      [index_1.Kind]: "MappedResult",
      properties
    });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/constructor.js
var require_constructor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Constructor = Constructor2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Constructor2(parameters, returns, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/index.js
var require_constructor2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_constructor(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/function/function.js
var require_function = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Function = Function3;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Function3(parameters, returns, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Function", type: "Function", parameters, returns }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/function/index.js
var require_function2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_function(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-create.js
var require_union_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnionCreate = UnionCreate2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function UnionCreate2(T, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Union", anyOf: T }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-evaluated.js
var require_union_evaluated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnionEvaluated = UnionEvaluated2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var index_2 = require_discard2();
  var index_3 = require_never2();
  var index_4 = require_optional2();
  var union_create_1 = require_union_create();
  var kind_1 = require_kind();
  function IsUnionOptional2(types) {
    return types.some((type2) => (0, kind_1.IsOptional)(type2));
  }
  function RemoveOptionalFromRest3(types) {
    return types.map((left) => (0, kind_1.IsOptional)(left) ? RemoveOptionalFromType3(left) : left);
  }
  function RemoveOptionalFromType3(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  }
  function ResolveUnion2(types, options) {
    const isOptional2 = IsUnionOptional2(types);
    return isOptional2 ? (0, index_4.Optional)((0, union_create_1.UnionCreate)(RemoveOptionalFromRest3(types), options)) : (0, union_create_1.UnionCreate)(RemoveOptionalFromRest3(types), options);
  }
  function UnionEvaluated2(T, options) {
    return T.length === 1 ? (0, type_1.CreateType)(T[0], options) : T.length === 0 ? (0, index_3.Never)(options) : ResolveUnion2(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-type.js
var require_union_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union.js
var require_union = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Union = Union3;
  var index_1 = require_never2();
  var type_1 = require_type2();
  var union_create_1 = require_union_create();
  function Union3(types, options) {
    return types.length === 0 ? (0, index_1.Never)(options) : types.length === 1 ? (0, type_1.CreateType)(types[0], options) : (0, union_create_1.UnionCreate)(types, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/index.js
var require_union2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_union_evaluated(), exports);
  __exportStar(require_union_type(), exports);
  __exportStar(require_union(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralParserError = undefined;
  exports.TemplateLiteralParse = TemplateLiteralParse2;
  exports.TemplateLiteralParseExact = TemplateLiteralParseExact2;
  var index_1 = require_error2();

  class TemplateLiteralParserError2 extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralParserError = TemplateLiteralParserError2;
  function Unescape2(pattern) {
    return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
  }
  function IsNonEscaped2(pattern, index, char) {
    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
  }
  function IsOpenParen2(pattern, index) {
    return IsNonEscaped2(pattern, index, "(");
  }
  function IsCloseParen2(pattern, index) {
    return IsNonEscaped2(pattern, index, ")");
  }
  function IsSeparator2(pattern, index) {
    return IsNonEscaped2(pattern, index, "|");
  }
  function IsGroup2(pattern) {
    if (!(IsOpenParen2(pattern, 0) && IsCloseParen2(pattern, pattern.length - 1)))
      return false;
    let count = 0;
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen2(pattern, index))
        count += 1;
      if (IsCloseParen2(pattern, index))
        count -= 1;
      if (count === 0 && index !== pattern.length - 1)
        return false;
    }
    return true;
  }
  function InGroup2(pattern) {
    return pattern.slice(1, pattern.length - 1);
  }
  function IsPrecedenceOr2(pattern) {
    let count = 0;
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen2(pattern, index))
        count += 1;
      if (IsCloseParen2(pattern, index))
        count -= 1;
      if (IsSeparator2(pattern, index) && count === 0)
        return true;
    }
    return false;
  }
  function IsPrecedenceAnd2(pattern) {
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen2(pattern, index))
        return true;
    }
    return false;
  }
  function Or2(pattern) {
    let [count, start] = [0, 0];
    const expressions = [];
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen2(pattern, index))
        count += 1;
      if (IsCloseParen2(pattern, index))
        count -= 1;
      if (IsSeparator2(pattern, index) && count === 0) {
        const range2 = pattern.slice(start, index);
        if (range2.length > 0)
          expressions.push(TemplateLiteralParse2(range2));
        start = index + 1;
      }
    }
    const range = pattern.slice(start);
    if (range.length > 0)
      expressions.push(TemplateLiteralParse2(range));
    if (expressions.length === 0)
      return { type: "const", const: "" };
    if (expressions.length === 1)
      return expressions[0];
    return { type: "or", expr: expressions };
  }
  function And2(pattern) {
    function Group(value, index) {
      if (!IsOpenParen2(value, index))
        throw new TemplateLiteralParserError2(`TemplateLiteralParser: Index must point to open parens`);
      let count = 0;
      for (let scan = index;scan < value.length; scan++) {
        if (IsOpenParen2(value, scan))
          count += 1;
        if (IsCloseParen2(value, scan))
          count -= 1;
        if (count === 0)
          return [index, scan];
      }
      throw new TemplateLiteralParserError2(`TemplateLiteralParser: Unclosed group parens in expression`);
    }
    function Range(pattern2, index) {
      for (let scan = index;scan < pattern2.length; scan++) {
        if (IsOpenParen2(pattern2, scan))
          return [index, scan];
      }
      return [index, pattern2.length];
    }
    const expressions = [];
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen2(pattern, index)) {
        const [start, end] = Group(pattern, index);
        const range = pattern.slice(start, end + 1);
        expressions.push(TemplateLiteralParse2(range));
        index = end;
      } else {
        const [start, end] = Range(pattern, index);
        const range = pattern.slice(start, end);
        if (range.length > 0)
          expressions.push(TemplateLiteralParse2(range));
        index = end - 1;
      }
    }
    return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
  }
  function TemplateLiteralParse2(pattern) {
    return IsGroup2(pattern) ? TemplateLiteralParse2(InGroup2(pattern)) : IsPrecedenceOr2(pattern) ? Or2(pattern) : IsPrecedenceAnd2(pattern) ? And2(pattern) : { type: "const", const: Unescape2(pattern) };
  }
  function TemplateLiteralParseExact2(pattern) {
    return TemplateLiteralParse2(pattern.slice(1, pattern.length - 1));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/finite.js
var require_finite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralFiniteError = undefined;
  exports.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite2;
  exports.IsTemplateLiteralFinite = IsTemplateLiteralFinite2;
  var parse_1 = require_parse();
  var index_1 = require_error2();

  class TemplateLiteralFiniteError2 extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError2;
  function IsNumberExpression2(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
  }
  function IsBooleanExpression2(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
  }
  function IsStringExpression2(expression) {
    return expression.type === "const" && expression.const === ".*";
  }
  function IsTemplateLiteralExpressionFinite2(expression) {
    return IsNumberExpression2(expression) || IsStringExpression2(expression) ? false : IsBooleanExpression2(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "const" ? true : (() => {
      throw new TemplateLiteralFiniteError2(`Unknown expression type`);
    })();
  }
  function IsTemplateLiteralFinite2(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    return IsTemplateLiteralExpressionFinite2(expression);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/generate.js
var require_generate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralGenerateError = undefined;
  exports.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate2;
  exports.TemplateLiteralGenerate = TemplateLiteralGenerate2;
  var finite_1 = require_finite();
  var parse_1 = require_parse();
  var index_1 = require_error2();

  class TemplateLiteralGenerateError2 extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralGenerateError = TemplateLiteralGenerateError2;
  function* GenerateReduce2(buffer) {
    if (buffer.length === 1)
      return yield* buffer[0];
    for (const left of buffer[0]) {
      for (const right of GenerateReduce2(buffer.slice(1))) {
        yield `${left}${right}`;
      }
    }
  }
  function* GenerateAnd2(expression) {
    return yield* GenerateReduce2(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate2(expr)]));
  }
  function* GenerateOr2(expression) {
    for (const expr of expression.expr)
      yield* TemplateLiteralExpressionGenerate2(expr);
  }
  function* GenerateConst2(expression) {
    return yield expression.const;
  }
  function* TemplateLiteralExpressionGenerate2(expression) {
    return expression.type === "and" ? yield* GenerateAnd2(expression) : expression.type === "or" ? yield* GenerateOr2(expression) : expression.type === "const" ? yield* GenerateConst2(expression) : (() => {
      throw new TemplateLiteralGenerateError2("Unknown expression");
    })();
  }
  function TemplateLiteralGenerate2(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    return (0, finite_1.IsTemplateLiteralExpressionFinite)(expression) ? [...TemplateLiteralExpressionGenerate2(expression)] : [];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/literal.js
var require_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Literal = Literal2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Literal2(value, options) {
    return (0, type_1.CreateType)({
      [index_1.Kind]: "Literal",
      const: value,
      type: typeof value
    }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/index.js
var require_literal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_literal(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/boolean.js
var require_boolean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Boolean = Boolean3;
  var index_1 = require_symbols2();
  var index_2 = require_create();
  function Boolean3(options) {
    return (0, index_2.CreateType)({ [index_1.Kind]: "Boolean", type: "boolean" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/index.js
var require_boolean2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_boolean(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/bigint.js
var require_bigint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BigInt = BigInt3;
  var index_1 = require_symbols2();
  var index_2 = require_create();
  function BigInt3(options) {
    return (0, index_2.CreateType)({ [index_1.Kind]: "BigInt", type: "bigint" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/index.js
var require_bigint2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_bigint(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/number/number.js
var require_number = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Number = Number3;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Number3(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Number", type: "number" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/number/index.js
var require_number2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_number(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/string/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.String = String3;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function String3(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "String", type: "string" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/string/index.js
var require_string2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_string(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/syntax.js
var require_syntax = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralSyntax = TemplateLiteralSyntax2;
  var index_1 = require_literal2();
  var index_2 = require_boolean2();
  var index_3 = require_bigint2();
  var index_4 = require_number2();
  var index_5 = require_string2();
  var index_6 = require_union2();
  var index_7 = require_never2();
  function* FromUnion21(syntax) {
    const trim = syntax.trim().replace(/"|'/g, "");
    return trim === "boolean" ? yield (0, index_2.Boolean)() : trim === "number" ? yield (0, index_4.Number)() : trim === "bigint" ? yield (0, index_3.BigInt)() : trim === "string" ? yield (0, index_5.String)() : yield (() => {
      const literals = trim.split("|").map((literal) => (0, index_1.Literal)(literal.trim()));
      return literals.length === 0 ? (0, index_7.Never)() : literals.length === 1 ? literals[0] : (0, index_6.UnionEvaluated)(literals);
    })();
  }
  function* FromTerminal2(syntax) {
    if (syntax[1] !== "{") {
      const L = (0, index_1.Literal)("$");
      const R = FromSyntax2(syntax.slice(1));
      return yield* [L, ...R];
    }
    for (let i = 2;i < syntax.length; i++) {
      if (syntax[i] === "}") {
        const L = FromUnion21(syntax.slice(2, i));
        const R = FromSyntax2(syntax.slice(i + 1));
        return yield* [...L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax);
  }
  function* FromSyntax2(syntax) {
    for (let i = 0;i < syntax.length; i++) {
      if (syntax[i] === "$") {
        const L = (0, index_1.Literal)(syntax.slice(0, i));
        const R = FromTerminal2(syntax.slice(i));
        return yield* [L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax);
  }
  function TemplateLiteralSyntax2(syntax) {
    return [...FromSyntax2(syntax)];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralPatternError = undefined;
  exports.TemplateLiteralPattern = TemplateLiteralPattern2;
  var index_1 = require_patterns2();
  var index_2 = require_symbols2();
  var index_3 = require_error2();
  var kind_1 = require_kind();

  class TemplateLiteralPatternError2 extends index_3.TypeBoxError {
  }
  exports.TemplateLiteralPatternError = TemplateLiteralPatternError2;
  function Escape3(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function Visit17(schema, acc) {
    return (0, kind_1.IsTemplateLiteral)(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : (0, kind_1.IsUnion)(schema) ? `(${schema.anyOf.map((schema2) => Visit17(schema2, acc)).join("|")})` : (0, kind_1.IsNumber)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsInteger)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsBigInt)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsString)(schema) ? `${acc}${index_1.PatternString}` : (0, kind_1.IsLiteral)(schema) ? `${acc}${Escape3(schema.const.toString())}` : (0, kind_1.IsBoolean)(schema) ? `${acc}${index_1.PatternBoolean}` : (() => {
      throw new TemplateLiteralPatternError2(`Unexpected Kind '${schema[index_2.Kind]}'`);
    })();
  }
  function TemplateLiteralPattern2(kinds) {
    return `^${kinds.map((schema) => Visit17(schema, "")).join("")}$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/union.js
var require_union3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralToUnion = TemplateLiteralToUnion2;
  var index_1 = require_union2();
  var index_2 = require_literal2();
  var generate_1 = require_generate();
  function TemplateLiteralToUnion2(schema) {
    const R = (0, generate_1.TemplateLiteralGenerate)(schema);
    const L = R.map((S) => (0, index_2.Literal)(S));
    return (0, index_1.UnionEvaluated)(L);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/template-literal.js
var require_template_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteral = TemplateLiteral2;
  var type_1 = require_type2();
  var syntax_1 = require_syntax();
  var pattern_1 = require_pattern();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  function TemplateLiteral2(unresolved, options) {
    const pattern = (0, value_1.IsString)(unresolved) ? (0, pattern_1.TemplateLiteralPattern)((0, syntax_1.TemplateLiteralSyntax)(unresolved)) : (0, pattern_1.TemplateLiteralPattern)(unresolved);
    return (0, type_1.CreateType)({ [index_1.Kind]: "TemplateLiteral", type: "string", pattern }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/index.js
var require_template_literal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_finite(), exports);
  __exportStar(require_generate(), exports);
  __exportStar(require_syntax(), exports);
  __exportStar(require_parse(), exports);
  __exportStar(require_pattern(), exports);
  __exportStar(require_union3(), exports);
  __exportStar(require_template_literal(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-property-keys.js
var require_indexed_property_keys = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexPropertyKeys = IndexPropertyKeys2;
  var index_1 = require_template_literal2();
  var kind_1 = require_kind();
  function FromTemplateLiteral7(templateLiteral) {
    const keys = (0, index_1.TemplateLiteralGenerate)(templateLiteral);
    return keys.map((key) => key.toString());
  }
  function FromUnion21(types) {
    const result = [];
    for (const type2 of types)
      result.push(...IndexPropertyKeys2(type2));
    return result;
  }
  function FromLiteral7(literalValue) {
    return [literalValue.toString()];
  }
  function IndexPropertyKeys2(type2) {
    return [...new Set((0, kind_1.IsTemplateLiteral)(type2) ? FromTemplateLiteral7(type2) : (0, kind_1.IsUnion)(type2) ? FromUnion21(type2.anyOf) : (0, kind_1.IsLiteral)(type2) ? FromLiteral7(type2.const) : (0, kind_1.IsNumber)(type2) ? ["[number]"] : (0, kind_1.IsInteger)(type2) ? ["[number]"] : [])];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-result.js
var require_indexed_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromMappedResult = IndexFromMappedResult2;
  var index_1 = require_mapped2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var index_2 = require_indexed2();
  function FromProperties20(type2, properties, options) {
    const result = {};
    for (const K2 of Object.getOwnPropertyNames(properties)) {
      result[K2] = (0, index_2.Index)(type2, (0, indexed_property_keys_1.IndexPropertyKeys)(properties[K2]), options);
    }
    return result;
  }
  function FromMappedResult13(type2, mappedResult, options) {
    return FromProperties20(type2, mappedResult.properties, options);
  }
  function IndexFromMappedResult2(type2, mappedResult, options) {
    const properties = FromMappedResult13(type2, mappedResult, options);
    return (0, index_1.MappedResult)(properties);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed.js
var require_indexed = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromPropertyKey = IndexFromPropertyKey2;
  exports.IndexFromPropertyKeys = IndexFromPropertyKeys2;
  exports.IndexFromComputed = IndexFromComputed;
  exports.Index = Index2;
  var type_1 = require_type2();
  var index_1 = require_error2();
  var index_2 = require_computed2();
  var index_3 = require_never2();
  var index_4 = require_intersect2();
  var index_5 = require_union2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var indexed_from_mapped_key_1 = require_indexed_from_mapped_key();
  var indexed_from_mapped_result_1 = require_indexed_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest8(types, key) {
    return types.map((type2) => IndexFromPropertyKey2(type2, key));
  }
  function FromIntersectRest2(types) {
    return types.filter((type2) => !(0, kind_1.IsNever)(type2));
  }
  function FromIntersect19(types, key) {
    return (0, index_4.IntersectEvaluated)(FromIntersectRest2(FromRest8(types, key)));
  }
  function FromUnionRest2(types) {
    return types.some((L) => (0, kind_1.IsNever)(L)) ? [] : types;
  }
  function FromUnion21(types, key) {
    return (0, index_5.UnionEvaluated)(FromUnionRest2(FromRest8(types, key)));
  }
  function FromTuple16(types, key) {
    return key in types ? types[key] : key === "[number]" ? (0, index_5.UnionEvaluated)(types) : (0, index_3.Never)();
  }
  function FromArray18(type2, key) {
    return key === "[number]" ? type2 : (0, index_3.Never)();
  }
  function FromProperty4(properties, propertyKey) {
    return propertyKey in properties ? properties[propertyKey] : (0, index_3.Never)();
  }
  function IndexFromPropertyKey2(type2, propertyKey) {
    return (0, kind_1.IsIntersect)(type2) ? FromIntersect19(type2.allOf, propertyKey) : (0, kind_1.IsUnion)(type2) ? FromUnion21(type2.anyOf, propertyKey) : (0, kind_1.IsTuple)(type2) ? FromTuple16(type2.items ?? [], propertyKey) : (0, kind_1.IsArray)(type2) ? FromArray18(type2.items, propertyKey) : (0, kind_1.IsObject)(type2) ? FromProperty4(type2.properties, propertyKey) : (0, index_3.Never)();
  }
  function IndexFromPropertyKeys2(type2, propertyKeys) {
    return propertyKeys.map((propertyKey) => IndexFromPropertyKey2(type2, propertyKey));
  }
  function FromSchema2(type2, propertyKeys) {
    return (0, index_5.UnionEvaluated)(IndexFromPropertyKeys2(type2, propertyKeys));
  }
  function IndexFromComputed(type2, key) {
    return (0, index_2.Computed)("Index", [type2, key]);
  }
  function Index2(type2, key, options) {
    if ((0, kind_1.IsRef)(type2) || (0, kind_1.IsRef)(key)) {
      const error3 = `Index types using Ref parameters require both Type and Key to be of TSchema`;
      if (!(0, kind_1.IsSchema)(type2) || !(0, kind_1.IsSchema)(key))
        throw new index_1.TypeBoxError(error3);
      return (0, index_2.Computed)("Index", [type2, key]);
    }
    if ((0, kind_1.IsMappedResult)(key))
      return (0, indexed_from_mapped_result_1.IndexFromMappedResult)(type2, key, options);
    if ((0, kind_1.IsMappedKey)(key))
      return (0, indexed_from_mapped_key_1.IndexFromMappedKey)(type2, key, options);
    return (0, type_1.CreateType)((0, kind_1.IsSchema)(key) ? FromSchema2(type2, (0, indexed_property_keys_1.IndexPropertyKeys)(key)) : FromSchema2(type2, key), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-key.js
var require_indexed_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromMappedKey = IndexFromMappedKey2;
  var indexed_1 = require_indexed();
  var index_1 = require_mapped2();
  var value_1 = require_value2();
  function MappedIndexPropertyKey2(type2, key, options) {
    return { [key]: (0, indexed_1.Index)(type2, [key], (0, value_1.Clone)(options)) };
  }
  function MappedIndexPropertyKeys2(type2, propertyKeys, options) {
    return propertyKeys.reduce((result, left) => {
      return { ...result, ...MappedIndexPropertyKey2(type2, left, options) };
    }, {});
  }
  function MappedIndexProperties2(type2, mappedKey, options) {
    return MappedIndexPropertyKeys2(type2, mappedKey.keys, options);
  }
  function IndexFromMappedKey2(type2, mappedKey, options) {
    const properties = MappedIndexProperties2(type2, mappedKey, options);
    return (0, index_1.MappedResult)(properties);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/index.js
var require_indexed2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_indexed_from_mapped_key(), exports);
  __exportStar(require_indexed_from_mapped_result(), exports);
  __exportStar(require_indexed_property_keys(), exports);
  __exportStar(require_indexed(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/iterator.js
var require_iterator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Iterator = Iterator2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Iterator2(items, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Iterator", type: "Iterator", items }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/index.js
var require_iterator2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_iterator(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/object/object.js
var require_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Object = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var kind_1 = require_kind();
  function RequiredKeys2(properties) {
    const keys = [];
    for (let key in properties) {
      if (!(0, kind_1.IsOptional)(properties[key]))
        keys.push(key);
    }
    return keys;
  }
  function _Object2(properties, options) {
    const required = RequiredKeys2(properties);
    const schematic = required.length > 0 ? { [index_1.Kind]: "Object", type: "object", properties, required } : { [index_1.Kind]: "Object", type: "object", properties };
    return (0, type_1.CreateType)(schematic, options);
  }
  exports.Object = _Object2;
});

// node_modules/@sinclair/typebox/build/cjs/type/object/index.js
var require_object2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_object(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/promise.js
var require_promise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Promise = Promise3;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Promise3(item, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Promise", type: "Promise", item }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/index.js
var require_promise2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_promise(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly.js
var require_readonly = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Readonly = Readonly2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var index_2 = require_discard2();
  var readonly_from_mapped_result_1 = require_readonly_from_mapped_result();
  var kind_1 = require_kind();
  function RemoveReadonly2(schema) {
    return (0, type_1.CreateType)((0, index_2.Discard)(schema, [index_1.ReadonlyKind]));
  }
  function AddReadonly2(schema) {
    return (0, type_1.CreateType)({ ...schema, [index_1.ReadonlyKind]: "Readonly" });
  }
  function ReadonlyWithFlag2(schema, F) {
    return F === false ? RemoveReadonly2(schema) : AddReadonly2(schema);
  }
  function Readonly2(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, readonly_from_mapped_result_1.ReadonlyFromMappedResult)(schema, F) : ReadonlyWithFlag2(schema, F);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly-from-mapped-result.js
var require_readonly_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadonlyFromMappedResult = ReadonlyFromMappedResult2;
  var index_1 = require_mapped2();
  var readonly_1 = require_readonly();
  function FromProperties20(K, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, readonly_1.Readonly)(K[K2], F);
    return Acc;
  }
  function FromMappedResult13(R, F) {
    return FromProperties20(R.properties, F);
  }
  function ReadonlyFromMappedResult2(R, F) {
    const P = FromMappedResult13(R, F);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/index.js
var require_readonly2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_readonly_from_mapped_result(), exports);
  __exportStar(require_readonly(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/tuple.js
var require_tuple = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tuple = Tuple2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Tuple2(types, options) {
    return (0, type_1.CreateType)(types.length > 0 ? { [index_1.Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [index_1.Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/index.js
var require_tuple2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_tuple(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped.js
var require_mapped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedFunctionReturnType = MappedFunctionReturnType2;
  exports.Mapped = Mapped2;
  var index_1 = require_symbols2();
  var index_2 = require_discard2();
  var index_3 = require_array2();
  var index_4 = require_async_iterator2();
  var index_5 = require_constructor2();
  var index_6 = require_function2();
  var index_7 = require_indexed2();
  var index_8 = require_intersect2();
  var index_9 = require_iterator2();
  var index_10 = require_literal2();
  var index_11 = require_object2();
  var index_12 = require_optional2();
  var index_13 = require_promise2();
  var index_14 = require_readonly2();
  var index_15 = require_tuple2();
  var index_16 = require_union2();
  var index_17 = require_sets();
  var mapped_result_1 = require_mapped_result();
  var kind_1 = require_kind();
  function FromMappedResult13(K, P) {
    return K in P ? FromSchemaType2(K, P[K]) : (0, mapped_result_1.MappedResult)(P);
  }
  function MappedKeyToKnownMappedResultProperties2(K) {
    return { [K]: (0, index_10.Literal)(K) };
  }
  function MappedKeyToUnknownMappedResultProperties2(P) {
    const Acc = {};
    for (const L of P)
      Acc[L] = (0, index_10.Literal)(L);
    return Acc;
  }
  function MappedKeyToMappedResultProperties2(K, P) {
    return (0, index_17.SetIncludes)(P, K) ? MappedKeyToKnownMappedResultProperties2(K) : MappedKeyToUnknownMappedResultProperties2(P);
  }
  function FromMappedKey5(K, P) {
    const R = MappedKeyToMappedResultProperties2(K, P);
    return FromMappedResult13(K, R);
  }
  function FromRest8(K, T) {
    return T.map((L) => FromSchemaType2(K, L));
  }
  function FromProperties20(K, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(T))
      Acc[K2] = FromSchemaType2(K, T[K2]);
    return Acc;
  }
  function FromSchemaType2(K, T) {
    const options = { ...T };
    return (0, kind_1.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType2(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) : (0, kind_1.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType2(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) : (0, kind_1.IsMappedResult)(T) ? FromMappedResult13(K, T.properties) : (0, kind_1.IsMappedKey)(T) ? FromMappedKey5(K, T.keys) : (0, kind_1.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest8(K, T.parameters), FromSchemaType2(K, T.returns), options) : (0, kind_1.IsFunction)(T) ? (0, index_6.Function)(FromRest8(K, T.parameters), FromSchemaType2(K, T.returns), options) : (0, kind_1.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType2(K, T.items), options) : (0, kind_1.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType2(K, T.items), options) : (0, kind_1.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest8(K, T.allOf), options) : (0, kind_1.IsUnion)(T) ? (0, index_16.Union)(FromRest8(K, T.anyOf), options) : (0, kind_1.IsTuple)(T) ? (0, index_15.Tuple)(FromRest8(K, T.items ?? []), options) : (0, kind_1.IsObject)(T) ? (0, index_11.Object)(FromProperties20(K, T.properties), options) : (0, kind_1.IsArray)(T) ? (0, index_3.Array)(FromSchemaType2(K, T.items), options) : (0, kind_1.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType2(K, T.item), options) : T;
  }
  function MappedFunctionReturnType2(K, T) {
    const Acc = {};
    for (const L of K)
      Acc[L] = FromSchemaType2(L, T);
    return Acc;
  }
  function Mapped2(key, map3, options) {
    const K = (0, kind_1.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;
    const RT = map3({ [index_1.Kind]: "MappedKey", keys: K });
    const R = MappedFunctionReturnType2(K, RT);
    return (0, index_11.Object)(R, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/index.js
var require_mapped2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_mapped_key(), exports);
  __exportStar(require_mapped_result(), exports);
  __exportStar(require_mapped(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional.js
var require_optional = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Optional = Optional2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var index_2 = require_discard2();
  var optional_from_mapped_result_1 = require_optional_from_mapped_result();
  var kind_1 = require_kind();
  function RemoveOptional2(schema) {
    return (0, type_1.CreateType)((0, index_2.Discard)(schema, [index_1.OptionalKind]));
  }
  function AddOptional2(schema) {
    return (0, type_1.CreateType)({ ...schema, [index_1.OptionalKind]: "Optional" });
  }
  function OptionalWithFlag2(schema, F) {
    return F === false ? RemoveOptional2(schema) : AddOptional2(schema);
  }
  function Optional2(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, optional_from_mapped_result_1.OptionalFromMappedResult)(schema, F) : OptionalWithFlag2(schema, F);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional-from-mapped-result.js
var require_optional_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OptionalFromMappedResult = OptionalFromMappedResult2;
  var index_1 = require_mapped2();
  var optional_1 = require_optional();
  function FromProperties20(P, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, optional_1.Optional)(P[K2], F);
    return Acc;
  }
  function FromMappedResult13(R, F) {
    return FromProperties20(R.properties, F);
  }
  function OptionalFromMappedResult2(R, F) {
    const P = FromMappedResult13(R, F);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/index.js
var require_optional2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_optional_from_mapped_result(), exports);
  __exportStar(require_optional(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-create.js
var require_intersect_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntersectCreate = IntersectCreate2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var kind_1 = require_kind();
  function IntersectCreate2(T, options = {}) {
    const allObjects = T.every((schema) => (0, kind_1.IsObject)(schema));
    const clonedUnevaluatedProperties = (0, kind_1.IsSchema)(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
    return (0, type_1.CreateType)(options.unevaluatedProperties === false || (0, kind_1.IsSchema)(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", allOf: T }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-evaluated.js
var require_intersect_evaluated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntersectEvaluated = IntersectEvaluated2;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_never2();
  var index_4 = require_optional2();
  var intersect_create_1 = require_intersect_create();
  var kind_1 = require_kind();
  function IsIntersectOptional2(types) {
    return types.every((left) => (0, kind_1.IsOptional)(left));
  }
  function RemoveOptionalFromType3(type2) {
    return (0, index_2.Discard)(type2, [index_1.OptionalKind]);
  }
  function RemoveOptionalFromRest3(types) {
    return types.map((left) => (0, kind_1.IsOptional)(left) ? RemoveOptionalFromType3(left) : left);
  }
  function ResolveIntersect2(types, options) {
    return IsIntersectOptional2(types) ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest3(types), options)) : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest3(types), options);
  }
  function IntersectEvaluated2(types, options = {}) {
    if (types.length === 1)
      return (0, type_1.CreateType)(types[0], options);
    if (types.length === 0)
      return (0, index_3.Never)(options);
    if (types.some((schema) => (0, kind_1.IsTransform)(schema)))
      throw new Error("Cannot intersect transform types");
    return ResolveIntersect2(types, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-type.js
var require_intersect_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect.js
var require_intersect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Intersect = Intersect3;
  var type_1 = require_type2();
  var index_1 = require_never2();
  var intersect_create_1 = require_intersect_create();
  var kind_1 = require_kind();
  function Intersect3(types, options) {
    if (types.length === 1)
      return (0, type_1.CreateType)(types[0], options);
    if (types.length === 0)
      return (0, index_1.Never)(options);
    if (types.some((schema) => (0, kind_1.IsTransform)(schema)))
      throw new Error("Cannot intersect transform types");
    return (0, intersect_create_1.IntersectCreate)(types, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/index.js
var require_intersect2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_intersect_evaluated(), exports);
  __exportStar(require_intersect_type(), exports);
  __exportStar(require_intersect(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/ref.js
var require_ref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Ref = Ref2;
  var index_1 = require_error2();
  var type_1 = require_type2();
  var index_2 = require_symbols2();
  function Ref2(...args) {
    const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
    if (typeof $ref !== "string")
      throw new index_1.TypeBoxError("Ref: $ref must be a string");
    return (0, type_1.CreateType)({ [index_2.Kind]: "Ref", $ref }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/index.js
var require_ref2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_ref(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/awaited.js
var require_awaited = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Awaited = Awaited2;
  var type_1 = require_type2();
  var index_1 = require_computed2();
  var index_2 = require_intersect2();
  var index_3 = require_union2();
  var index_4 = require_ref2();
  var kind_1 = require_kind();
  function FromComputed6(target, parameters) {
    return (0, index_1.Computed)("Awaited", [(0, index_1.Computed)(target, parameters)]);
  }
  function FromRef15($ref) {
    return (0, index_1.Computed)("Awaited", [(0, index_4.Ref)($ref)]);
  }
  function FromIntersect19(types) {
    return (0, index_2.Intersect)(FromRest8(types));
  }
  function FromUnion21(types) {
    return (0, index_3.Union)(FromRest8(types));
  }
  function FromPromise8(type2) {
    return Awaited2(type2);
  }
  function FromRest8(types) {
    return types.map((type2) => Awaited2(type2));
  }
  function Awaited2(type2, options) {
    return (0, type_1.CreateType)((0, kind_1.IsComputed)(type2) ? FromComputed6(type2.target, type2.parameters) : (0, kind_1.IsIntersect)(type2) ? FromIntersect19(type2.allOf) : (0, kind_1.IsUnion)(type2) ? FromUnion21(type2.anyOf) : (0, kind_1.IsPromise)(type2) ? FromPromise8(type2.item) : (0, kind_1.IsRef)(type2) ? FromRef15(type2.$ref) : type2, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/index.js
var require_awaited2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_awaited(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-keys.js
var require_keyof_property_keys = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPropertyKeys = KeyOfPropertyKeys2;
  exports.KeyOfPattern = KeyOfPattern2;
  var index_1 = require_sets();
  var kind_1 = require_kind();
  function FromRest8(types) {
    const result = [];
    for (const L of types)
      result.push(KeyOfPropertyKeys2(L));
    return result;
  }
  function FromIntersect19(types) {
    const propertyKeysArray = FromRest8(types);
    const propertyKeys = (0, index_1.SetUnionMany)(propertyKeysArray);
    return propertyKeys;
  }
  function FromUnion21(types) {
    const propertyKeysArray = FromRest8(types);
    const propertyKeys = (0, index_1.SetIntersectMany)(propertyKeysArray);
    return propertyKeys;
  }
  function FromTuple16(types) {
    return types.map((_, indexer) => indexer.toString());
  }
  function FromArray18(_) {
    return ["[number]"];
  }
  function FromProperties20(T) {
    return globalThis.Object.getOwnPropertyNames(T);
  }
  function FromPatternProperties2(patternProperties) {
    if (!includePatternProperties2)
      return [];
    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
    return patternPropertyKeys.map((key) => {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    });
  }
  function KeyOfPropertyKeys2(type2) {
    return (0, kind_1.IsIntersect)(type2) ? FromIntersect19(type2.allOf) : (0, kind_1.IsUnion)(type2) ? FromUnion21(type2.anyOf) : (0, kind_1.IsTuple)(type2) ? FromTuple16(type2.items ?? []) : (0, kind_1.IsArray)(type2) ? FromArray18(type2.items) : (0, kind_1.IsObject)(type2) ? FromProperties20(type2.properties) : (0, kind_1.IsRecord)(type2) ? FromPatternProperties2(type2.patternProperties) : [];
  }
  var includePatternProperties2 = false;
  function KeyOfPattern2(schema) {
    includePatternProperties2 = true;
    const keys = KeyOfPropertyKeys2(schema);
    includePatternProperties2 = false;
    const pattern = keys.map((key) => `(${key})`);
    return `^(${pattern.join("|")})$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof.js
var require_keyof = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest2;
  exports.KeyOf = KeyOf2;
  var type_1 = require_type2();
  var index_1 = require_literal2();
  var index_2 = require_number2();
  var index_3 = require_computed2();
  var index_4 = require_ref2();
  var keyof_property_keys_1 = require_keyof_property_keys();
  var index_5 = require_union2();
  var keyof_from_mapped_result_1 = require_keyof_from_mapped_result();
  var kind_1 = require_kind();
  function FromComputed6(target, parameters) {
    return (0, index_3.Computed)("KeyOf", [(0, index_3.Computed)(target, parameters)]);
  }
  function FromRef15($ref) {
    return (0, index_3.Computed)("KeyOf", [(0, index_4.Ref)($ref)]);
  }
  function KeyOfFromType2(type2, options) {
    const propertyKeys = (0, keyof_property_keys_1.KeyOfPropertyKeys)(type2);
    const propertyKeyTypes = KeyOfPropertyKeysToRest2(propertyKeys);
    const result = (0, index_5.UnionEvaluated)(propertyKeyTypes);
    return (0, type_1.CreateType)(result, options);
  }
  function KeyOfPropertyKeysToRest2(propertyKeys) {
    return propertyKeys.map((L) => L === "[number]" ? (0, index_2.Number)() : (0, index_1.Literal)(L));
  }
  function KeyOf2(type2, options) {
    return (0, kind_1.IsComputed)(type2) ? FromComputed6(type2.target, type2.parameters) : (0, kind_1.IsRef)(type2) ? FromRef15(type2.$ref) : (0, kind_1.IsMappedResult)(type2) ? (0, keyof_from_mapped_result_1.KeyOfFromMappedResult)(type2, options) : KeyOfFromType2(type2, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-from-mapped-result.js
var require_keyof_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfFromMappedResult = KeyOfFromMappedResult2;
  var index_1 = require_mapped2();
  var keyof_1 = require_keyof();
  var value_1 = require_value2();
  function FromProperties20(properties, options) {
    const result = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
      result[K2] = (0, keyof_1.KeyOf)(properties[K2], (0, value_1.Clone)(options));
    return result;
  }
  function FromMappedResult13(mappedResult, options) {
    return FromProperties20(mappedResult.properties, options);
  }
  function KeyOfFromMappedResult2(mappedResult, options) {
    const properties = FromMappedResult13(mappedResult, options);
    return (0, index_1.MappedResult)(properties);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-entries.js
var require_keyof_property_entries = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPropertyEntries = KeyOfPropertyEntries2;
  var indexed_1 = require_indexed();
  var keyof_property_keys_1 = require_keyof_property_keys();
  function KeyOfPropertyEntries2(schema) {
    const keys = (0, keyof_property_keys_1.KeyOfPropertyKeys)(schema);
    const schemas = (0, indexed_1.IndexFromPropertyKeys)(schema, keys);
    return keys.map((_, index) => [keys[index], schemas[index]]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/index.js
var require_keyof2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_keyof_from_mapped_result(), exports);
  __exportStar(require_keyof_property_entries(), exports);
  __exportStar(require_keyof_property_keys(), exports);
  __exportStar(require_keyof(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/composite.js
var require_composite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Composite = Composite2;
  var index_1 = require_intersect2();
  var index_2 = require_indexed2();
  var index_3 = require_keyof2();
  var index_4 = require_object2();
  var index_5 = require_sets();
  var kind_1 = require_kind();
  function CompositeKeys2(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_3.KeyOfPropertyKeys)(L));
    return (0, index_5.SetDistinct)(Acc);
  }
  function FilterNever2(T) {
    return T.filter((L) => !(0, kind_1.IsNever)(L));
  }
  function CompositeProperty2(T, K) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_2.IndexFromPropertyKeys)(L, [K]));
    return FilterNever2(Acc);
  }
  function CompositeProperties2(T, K) {
    const Acc = {};
    for (const L of K) {
      Acc[L] = (0, index_1.IntersectEvaluated)(CompositeProperty2(T, L));
    }
    return Acc;
  }
  function Composite2(T, options) {
    const K = CompositeKeys2(T);
    const P = CompositeProperties2(T, K);
    const R = (0, index_4.Object)(P, options);
    return R;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/index.js
var require_composite2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_composite(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/date/date.js
var require_date = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Date = Date3;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  function Date3(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Date", type: "Date" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/date/index.js
var require_date2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_date(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/null/null.js
var require_null = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Null = Null2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Null2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Null", type: "null" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/null/index.js
var require_null2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_null(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Symbol = Symbol3;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Symbol3(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Symbol", type: "symbol" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/index.js
var require_symbol2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_symbol(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/undefined.js
var require_undefined = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Undefined = Undefined2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Undefined2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Undefined", type: "undefined" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/index.js
var require_undefined2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_undefined(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/uint8array.js
var require_uint8array = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uint8Array = Uint8Array3;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Uint8Array3(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Uint8Array", type: "Uint8Array" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/index.js
var require_uint8array2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_uint8array(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/unknown.js
var require_unknown = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unknown = Unknown2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Unknown2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Unknown" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/index.js
var require_unknown2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_unknown(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/const/const.js
var require_const = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Const = Const2;
  var index_1 = require_any2();
  var index_2 = require_bigint2();
  var index_3 = require_date2();
  var index_4 = require_function2();
  var index_5 = require_literal2();
  var index_6 = require_null2();
  var index_7 = require_object2();
  var index_8 = require_symbol2();
  var index_9 = require_tuple2();
  var index_10 = require_readonly2();
  var index_11 = require_undefined2();
  var index_12 = require_uint8array2();
  var index_13 = require_unknown2();
  var index_14 = require_create();
  var value_1 = require_value();
  function FromArray18(T) {
    return T.map((L) => FromValue3(L, false));
  }
  function FromProperties20(value) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(value))
      Acc[K] = (0, index_10.Readonly)(FromValue3(value[K], false));
    return Acc;
  }
  function ConditionalReadonly2(T, root) {
    return root === true ? T : (0, index_10.Readonly)(T);
  }
  function FromValue3(value, root) {
    return (0, value_1.IsAsyncIterator)(value) ? ConditionalReadonly2((0, index_1.Any)(), root) : (0, value_1.IsIterator)(value) ? ConditionalReadonly2((0, index_1.Any)(), root) : (0, value_1.IsArray)(value) ? (0, index_10.Readonly)((0, index_9.Tuple)(FromArray18(value))) : (0, value_1.IsUint8Array)(value) ? (0, index_12.Uint8Array)() : (0, value_1.IsDate)(value) ? (0, index_3.Date)() : (0, value_1.IsObject)(value) ? ConditionalReadonly2((0, index_7.Object)(FromProperties20(value)), root) : (0, value_1.IsFunction)(value) ? ConditionalReadonly2((0, index_4.Function)([], (0, index_13.Unknown)()), root) : (0, value_1.IsUndefined)(value) ? (0, index_11.Undefined)() : (0, value_1.IsNull)(value) ? (0, index_6.Null)() : (0, value_1.IsSymbol)(value) ? (0, index_8.Symbol)() : (0, value_1.IsBigInt)(value) ? (0, index_2.BigInt)() : (0, value_1.IsNumber)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsBoolean)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsString)(value) ? (0, index_5.Literal)(value) : (0, index_7.Object)({});
  }
  function Const2(T, options) {
    return (0, index_14.CreateType)(FromValue3(T, true), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/const/index.js
var require_const2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_const(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/constructor-parameters.js
var require_constructor_parameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConstructorParameters = ConstructorParameters2;
  var index_1 = require_tuple2();
  var index_2 = require_never2();
  var KindGuard = require_kind();
  function ConstructorParameters2(schema, options) {
    return KindGuard.IsConstructor(schema) ? (0, index_1.Tuple)(schema.parameters, options) : (0, index_2.Never)(options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/index.js
var require_constructor_parameters2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_constructor_parameters(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Enum = Enum2;
  var index_1 = require_literal2();
  var index_2 = require_symbols2();
  var index_3 = require_union2();
  var value_1 = require_value();
  function Enum2(item, options) {
    if ((0, value_1.IsUndefined)(item))
      throw new Error("Enum undefined or empty");
    const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
    const values2 = [...new Set(values1)];
    const anyOf = values2.map((value) => (0, index_1.Literal)(value));
    return (0, index_3.Union)(anyOf, { ...options, [index_2.Hint]: "Enum" });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/index.js
var require_enum2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_enum(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-check.js
var require_extends_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsResult = exports.ExtendsResolverError = undefined;
  exports.ExtendsCheck = ExtendsCheck2;
  var index_1 = require_any2();
  var index_2 = require_function2();
  var index_3 = require_number2();
  var index_4 = require_string2();
  var index_5 = require_unknown2();
  var index_6 = require_template_literal2();
  var index_7 = require_patterns2();
  var index_8 = require_symbols2();
  var index_9 = require_error2();
  var index_10 = require_guard3();

  class ExtendsResolverError2 extends index_9.TypeBoxError {
  }
  exports.ExtendsResolverError = ExtendsResolverError2;
  var ExtendsResult2;
  (function(ExtendsResult3) {
    ExtendsResult3[ExtendsResult3["Union"] = 0] = "Union";
    ExtendsResult3[ExtendsResult3["True"] = 1] = "True";
    ExtendsResult3[ExtendsResult3["False"] = 2] = "False";
  })(ExtendsResult2 || (exports.ExtendsResult = ExtendsResult2 = {}));
  function IntoBooleanResult2(result) {
    return result === ExtendsResult2.False ? result : ExtendsResult2.True;
  }
  function Throw2(message) {
    throw new ExtendsResolverError2(message);
  }
  function IsStructuralRight2(right) {
    return index_10.TypeGuard.IsNever(right) || index_10.TypeGuard.IsIntersect(right) || index_10.TypeGuard.IsUnion(right) || index_10.TypeGuard.IsUnknown(right) || index_10.TypeGuard.IsAny(right);
  }
  function StructuralRight2(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight2(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight2(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight2(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight2(left, right) : Throw2("StructuralRight");
  }
  function FromAnyRight2(left, right) {
    return ExtendsResult2.True;
  }
  function FromAny5(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) && right.anyOf.some((schema) => index_10.TypeGuard.IsAny(schema) || index_10.TypeGuard.IsUnknown(schema)) ? ExtendsResult2.True : index_10.TypeGuard.IsUnion(right) ? ExtendsResult2.Union : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult2.True : index_10.TypeGuard.IsAny(right) ? ExtendsResult2.True : ExtendsResult2.Union;
  }
  function FromArrayRight2(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult2.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult2.Union : index_10.TypeGuard.IsNever(left) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromArray18(left, right) {
    return index_10.TypeGuard.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : !index_10.TypeGuard.IsArray(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.items, right.items));
  }
  function FromAsyncIterator8(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : !index_10.TypeGuard.IsAsyncIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.items, right.items));
  }
  function FromBigInt6(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsBigInt(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromBooleanRight2(left, right) {
    return index_10.TypeGuard.IsLiteralBoolean(left) ? ExtendsResult2.True : index_10.TypeGuard.IsBoolean(left) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromBoolean6(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsBoolean(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromConstructor9(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : !index_10.TypeGuard.IsConstructor(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit17(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.returns, right.returns));
  }
  function FromDate8(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsDate(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromFunction8(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : !index_10.TypeGuard.IsFunction(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit17(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.returns, right.returns));
  }
  function FromIntegerRight2(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsNumber(left.const) ? ExtendsResult2.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromInteger6(left, right) {
    return index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : ExtendsResult2.False;
  }
  function FromIntersectRight2(left, right) {
    return right.allOf.every((schema) => Visit17(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromIntersect19(left, right) {
    return left.allOf.some((schema) => Visit17(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromIterator8(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : !index_10.TypeGuard.IsIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.items, right.items));
  }
  function FromLiteral7(left, right) {
    return index_10.TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight2(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight2(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight2(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight2(left, right) : ExtendsResult2.False;
  }
  function FromNeverRight2(left, right) {
    return ExtendsResult2.False;
  }
  function FromNever6(left, right) {
    return ExtendsResult2.True;
  }
  function UnwrapTNot2(schema) {
    let [current, depth] = [schema, 0];
    while (true) {
      if (!index_10.TypeGuard.IsNot(current))
        break;
      current = current.not;
      depth += 1;
    }
    return depth % 2 === 0 ? current : (0, index_5.Unknown)();
  }
  function FromNot8(left, right) {
    return index_10.TypeGuard.IsNot(left) ? Visit17(UnwrapTNot2(left), right) : index_10.TypeGuard.IsNot(right) ? Visit17(left, UnwrapTNot2(right)) : Throw2("Invalid fallthrough for Not");
  }
  function FromNull6(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsNull(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromNumberRight2(left, right) {
    return index_10.TypeGuard.IsLiteralNumber(left) ? ExtendsResult2.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromNumber6(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function IsObjectPropertyCount2(schema, count) {
    return Object.getOwnPropertyNames(schema.properties).length === count;
  }
  function IsObjectStringLike2(schema) {
    return IsObjectArrayLike2(schema);
  }
  function IsObjectSymbolLike2(schema) {
    return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "description" in schema.properties && index_10.TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (index_10.TypeGuard.IsString(schema.properties.description.anyOf[0]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[1]) || index_10.TypeGuard.IsString(schema.properties.description.anyOf[1]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[0]));
  }
  function IsObjectNumberLike2(schema) {
    return IsObjectPropertyCount2(schema, 0);
  }
  function IsObjectBooleanLike2(schema) {
    return IsObjectPropertyCount2(schema, 0);
  }
  function IsObjectBigIntLike2(schema) {
    return IsObjectPropertyCount2(schema, 0);
  }
  function IsObjectDateLike2(schema) {
    return IsObjectPropertyCount2(schema, 0);
  }
  function IsObjectUint8ArrayLike2(schema) {
    return IsObjectArrayLike2(schema);
  }
  function IsObjectFunctionLike2(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit17(schema.properties["length"], length)) === ExtendsResult2.True;
  }
  function IsObjectConstructorLike2(schema) {
    return IsObjectPropertyCount2(schema, 0);
  }
  function IsObjectArrayLike2(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit17(schema.properties["length"], length)) === ExtendsResult2.True;
  }
  function IsObjectPromiseLike2(schema) {
    const then = (0, index_2.Function)([(0, index_1.Any)()], (0, index_1.Any)());
    return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "then" in schema.properties && IntoBooleanResult2(Visit17(schema.properties["then"], then)) === ExtendsResult2.True;
  }
  function Property2(left, right) {
    return Visit17(left, right) === ExtendsResult2.False ? ExtendsResult2.False : index_10.TypeGuard.IsOptional(left) && !index_10.TypeGuard.IsOptional(right) ? ExtendsResult2.False : ExtendsResult2.True;
  }
  function FromObjectRight2(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult2.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult2.Union : index_10.TypeGuard.IsNever(left) || index_10.TypeGuard.IsLiteralString(left) && IsObjectStringLike2(right) || index_10.TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike2(right) || index_10.TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike2(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike2(right) || index_10.TypeGuard.IsBigInt(left) && IsObjectBigIntLike2(right) || index_10.TypeGuard.IsString(left) && IsObjectStringLike2(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike2(right) || index_10.TypeGuard.IsNumber(left) && IsObjectNumberLike2(right) || index_10.TypeGuard.IsInteger(left) && IsObjectNumberLike2(right) || index_10.TypeGuard.IsBoolean(left) && IsObjectBooleanLike2(right) || index_10.TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike2(right) || index_10.TypeGuard.IsDate(left) && IsObjectDateLike2(right) || index_10.TypeGuard.IsConstructor(left) && IsObjectConstructorLike2(right) || index_10.TypeGuard.IsFunction(left) && IsObjectFunctionLike2(right) ? ExtendsResult2.True : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsString(RecordKey3(left)) ? (() => {
      return right[index_8.Hint] === "Record" ? ExtendsResult2.True : ExtendsResult2.False;
    })() : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsNumber(RecordKey3(left)) ? (() => {
      return IsObjectPropertyCount2(right, 0) ? ExtendsResult2.True : ExtendsResult2.False;
    })() : ExtendsResult2.False;
  }
  function FromObject19(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : !index_10.TypeGuard.IsObject(right) ? ExtendsResult2.False : (() => {
      for (const key of Object.getOwnPropertyNames(right.properties)) {
        if (!(key in left.properties) && !index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult2.False;
        }
        if (index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult2.True;
        }
        if (Property2(left.properties[key], right.properties[key]) === ExtendsResult2.False) {
          return ExtendsResult2.False;
        }
      }
      return ExtendsResult2.True;
    })();
  }
  function FromPromise8(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectPromiseLike2(right) ? ExtendsResult2.True : !index_10.TypeGuard.IsPromise(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.item, right.item));
  }
  function RecordKey3(schema) {
    return index_7.PatternNumberExact in schema.patternProperties ? (0, index_3.Number)() : (index_7.PatternStringExact in schema.patternProperties) ? (0, index_4.String)() : Throw2("Unknown record key pattern");
  }
  function RecordValue3(schema) {
    return index_7.PatternNumberExact in schema.patternProperties ? schema.patternProperties[index_7.PatternNumberExact] : (index_7.PatternStringExact in schema.patternProperties) ? schema.patternProperties[index_7.PatternStringExact] : Throw2("Unable to get record value schema");
  }
  function FromRecordRight2(left, right) {
    const [Key, Value] = [RecordKey3(right), RecordValue3(right)];
    return index_10.TypeGuard.IsLiteralString(left) && index_10.TypeGuard.IsNumber(Key) && IntoBooleanResult2(Visit17(left, Value)) === ExtendsResult2.True ? ExtendsResult2.True : index_10.TypeGuard.IsUint8Array(left) && index_10.TypeGuard.IsNumber(Key) ? Visit17(left, Value) : index_10.TypeGuard.IsString(left) && index_10.TypeGuard.IsNumber(Key) ? Visit17(left, Value) : index_10.TypeGuard.IsArray(left) && index_10.TypeGuard.IsNumber(Key) ? Visit17(left, Value) : index_10.TypeGuard.IsObject(left) ? (() => {
      for (const key of Object.getOwnPropertyNames(left.properties)) {
        if (Property2(Value, left.properties[key]) === ExtendsResult2.False) {
          return ExtendsResult2.False;
        }
      }
      return ExtendsResult2.True;
    })() : ExtendsResult2.False;
  }
  function FromRecord14(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : !index_10.TypeGuard.IsRecord(right) ? ExtendsResult2.False : Visit17(RecordValue3(left), RecordValue3(right));
  }
  function FromRegExp5(left, right) {
    const L = index_10.TypeGuard.IsRegExp(left) ? (0, index_4.String)() : left;
    const R = index_10.TypeGuard.IsRegExp(right) ? (0, index_4.String)() : right;
    return Visit17(L, R);
  }
  function FromStringRight2(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsString(left.const) ? ExtendsResult2.True : index_10.TypeGuard.IsString(left) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromString6(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsString(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromSymbol6(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsSymbol(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromTemplateLiteral7(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) ? Visit17((0, index_6.TemplateLiteralToUnion)(left), right) : index_10.TypeGuard.IsTemplateLiteral(right) ? Visit17(left, (0, index_6.TemplateLiteralToUnion)(right)) : Throw2("Invalid fallthrough for TemplateLiteral");
  }
  function IsArrayOfTuple2(left, right) {
    return index_10.TypeGuard.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit17(schema, right.items) === ExtendsResult2.True);
  }
  function FromTupleRight2(left, right) {
    return index_10.TypeGuard.IsNever(left) ? ExtendsResult2.True : index_10.TypeGuard.IsUnknown(left) ? ExtendsResult2.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult2.Union : ExtendsResult2.False;
  }
  function FromTuple16(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : index_10.TypeGuard.IsArray(right) && IsArrayOfTuple2(left, right) ? ExtendsResult2.True : !index_10.TypeGuard.IsTuple(right) ? ExtendsResult2.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) || !index_10.ValueGuard.IsUndefined(left.items) && index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult2.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult2.True : left.items.every((schema, index) => Visit17(schema, right.items[index]) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromUint8Array5(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsUint8Array(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromUndefined6(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsVoid(right) ? FromVoidRight2(left, right) : index_10.TypeGuard.IsUndefined(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromUnionRight2(left, right) {
    return right.anyOf.some((schema) => Visit17(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromUnion21(left, right) {
    return left.anyOf.every((schema) => Visit17(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromUnknownRight2(left, right) {
    return ExtendsResult2.True;
  }
  function FromUnknown5(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight2(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight2(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight2(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight2(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight2(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight2(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight2(left, right) : index_10.TypeGuard.IsArray(right) ? FromArrayRight2(left, right) : index_10.TypeGuard.IsTuple(right) ? FromTupleRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromVoidRight2(left, right) {
    return index_10.TypeGuard.IsUndefined(left) ? ExtendsResult2.True : index_10.TypeGuard.IsUndefined(left) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function FromVoid5(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight2(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight2(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsVoid(right) ? ExtendsResult2.True : ExtendsResult2.False;
  }
  function Visit17(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) || index_10.TypeGuard.IsTemplateLiteral(right) ? FromTemplateLiteral7(left, right) : index_10.TypeGuard.IsRegExp(left) || index_10.TypeGuard.IsRegExp(right) ? FromRegExp5(left, right) : index_10.TypeGuard.IsNot(left) || index_10.TypeGuard.IsNot(right) ? FromNot8(left, right) : index_10.TypeGuard.IsAny(left) ? FromAny5(left, right) : index_10.TypeGuard.IsArray(left) ? FromArray18(left, right) : index_10.TypeGuard.IsBigInt(left) ? FromBigInt6(left, right) : index_10.TypeGuard.IsBoolean(left) ? FromBoolean6(left, right) : index_10.TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator8(left, right) : index_10.TypeGuard.IsConstructor(left) ? FromConstructor9(left, right) : index_10.TypeGuard.IsDate(left) ? FromDate8(left, right) : index_10.TypeGuard.IsFunction(left) ? FromFunction8(left, right) : index_10.TypeGuard.IsInteger(left) ? FromInteger6(left, right) : index_10.TypeGuard.IsIntersect(left) ? FromIntersect19(left, right) : index_10.TypeGuard.IsIterator(left) ? FromIterator8(left, right) : index_10.TypeGuard.IsLiteral(left) ? FromLiteral7(left, right) : index_10.TypeGuard.IsNever(left) ? FromNever6(left, right) : index_10.TypeGuard.IsNull(left) ? FromNull6(left, right) : index_10.TypeGuard.IsNumber(left) ? FromNumber6(left, right) : index_10.TypeGuard.IsObject(left) ? FromObject19(left, right) : index_10.TypeGuard.IsRecord(left) ? FromRecord14(left, right) : index_10.TypeGuard.IsString(left) ? FromString6(left, right) : index_10.TypeGuard.IsSymbol(left) ? FromSymbol6(left, right) : index_10.TypeGuard.IsTuple(left) ? FromTuple16(left, right) : index_10.TypeGuard.IsPromise(left) ? FromPromise8(left, right) : index_10.TypeGuard.IsUint8Array(left) ? FromUint8Array5(left, right) : index_10.TypeGuard.IsUndefined(left) ? FromUndefined6(left, right) : index_10.TypeGuard.IsUnion(left) ? FromUnion21(left, right) : index_10.TypeGuard.IsUnknown(left) ? FromUnknown5(left, right) : index_10.TypeGuard.IsVoid(left) ? FromVoid5(left, right) : Throw2(`Unknown left type operand '${left[index_8.Kind]}'`);
  }
  function ExtendsCheck2(left, right) {
    return Visit17(left, right);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-result.js
var require_extends_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsFromMappedResult = ExtendsFromMappedResult2;
  var index_1 = require_mapped2();
  var extends_1 = require_extends();
  var value_1 = require_value2();
  function FromProperties20(P, Right, True, False, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extends_1.Extends)(P[K2], Right, True, False, (0, value_1.Clone)(options));
    return Acc;
  }
  function FromMappedResult13(Left, Right, True, False, options) {
    return FromProperties20(Left.properties, Right, True, False, options);
  }
  function ExtendsFromMappedResult2(Left, Right, True, False, options) {
    const P = FromMappedResult13(Left, Right, True, False, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends.js
var require_extends = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Extends = Extends2;
  var type_1 = require_type2();
  var index_1 = require_union2();
  var extends_check_1 = require_extends_check();
  var extends_from_mapped_key_1 = require_extends_from_mapped_key();
  var extends_from_mapped_result_1 = require_extends_from_mapped_result();
  var kind_1 = require_kind();
  function ExtendsResolve2(left, right, trueType, falseType) {
    const R = (0, extends_check_1.ExtendsCheck)(left, right);
    return R === extends_check_1.ExtendsResult.Union ? (0, index_1.Union)([trueType, falseType]) : R === extends_check_1.ExtendsResult.True ? trueType : falseType;
  }
  function Extends2(L, R, T, F, options) {
    return (0, kind_1.IsMappedResult)(L) ? (0, extends_from_mapped_result_1.ExtendsFromMappedResult)(L, R, T, F, options) : (0, kind_1.IsMappedKey)(L) ? (0, type_1.CreateType)((0, extends_from_mapped_key_1.ExtendsFromMappedKey)(L, R, T, F, options)) : (0, type_1.CreateType)(ExtendsResolve2(L, R, T, F), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-key.js
var require_extends_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsFromMappedKey = ExtendsFromMappedKey2;
  var index_1 = require_mapped2();
  var index_2 = require_literal2();
  var extends_1 = require_extends();
  var value_1 = require_value2();
  function FromPropertyKey4(K, U, L, R, options) {
    return {
      [K]: (0, extends_1.Extends)((0, index_2.Literal)(K), U, L, R, (0, value_1.Clone)(options))
    };
  }
  function FromPropertyKeys4(K, U, L, R, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey4(LK, U, L, R, options) };
    }, {});
  }
  function FromMappedKey5(K, U, L, R, options) {
    return FromPropertyKeys4(K.keys, U, L, R, options);
  }
  function ExtendsFromMappedKey2(T, U, L, R, options) {
    const P = FromMappedKey5(T, U, L, R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-undefined.js
var require_extends_undefined = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsUndefinedCheck = ExtendsUndefinedCheck2;
  var index_1 = require_symbols2();
  function Intersect3(schema) {
    return schema.allOf.every((schema2) => ExtendsUndefinedCheck2(schema2));
  }
  function Union3(schema) {
    return schema.anyOf.some((schema2) => ExtendsUndefinedCheck2(schema2));
  }
  function Not3(schema) {
    return !ExtendsUndefinedCheck2(schema.not);
  }
  function ExtendsUndefinedCheck2(schema) {
    return schema[index_1.Kind] === "Intersect" ? Intersect3(schema) : schema[index_1.Kind] === "Union" ? Union3(schema) : schema[index_1.Kind] === "Not" ? Not3(schema) : schema[index_1.Kind] === "Undefined" ? true : false;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/index.js
var require_extends2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_extends_check(), exports);
  __exportStar(require_extends_from_mapped_key(), exports);
  __exportStar(require_extends_from_mapped_result(), exports);
  __exportStar(require_extends_undefined(), exports);
  __exportStar(require_extends(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-template-literal.js
var require_exclude_from_template_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral2;
  var exclude_1 = require_exclude();
  var index_1 = require_template_literal2();
  function ExcludeFromTemplateLiteral2(L, R) {
    return (0, exclude_1.Exclude)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude.js
var require_exclude = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Exclude = Exclude2;
  var type_1 = require_type2();
  var index_1 = require_union2();
  var index_2 = require_never2();
  var index_3 = require_extends2();
  var exclude_from_mapped_result_1 = require_exclude_from_mapped_result();
  var exclude_from_template_literal_1 = require_exclude_from_template_literal();
  var kind_1 = require_kind();
  function ExcludeRest2(L, R) {
    const excluded = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) === index_3.ExtendsResult.False);
    return excluded.length === 1 ? excluded[0] : (0, index_1.Union)(excluded);
  }
  function Exclude2(L, R, options = {}) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CreateType)((0, exclude_from_template_literal_1.ExcludeFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CreateType)((0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(L, R), options);
    return (0, type_1.CreateType)((0, kind_1.IsUnion)(L) ? ExcludeRest2(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? (0, index_2.Never)() : L, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-mapped-result.js
var require_exclude_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExcludeFromMappedResult = ExcludeFromMappedResult2;
  var index_1 = require_mapped2();
  var exclude_1 = require_exclude();
  function FromProperties20(P, U) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, exclude_1.Exclude)(P[K2], U);
    return Acc;
  }
  function FromMappedResult13(R, T) {
    return FromProperties20(R.properties, T);
  }
  function ExcludeFromMappedResult2(R, T) {
    const P = FromMappedResult13(R, T);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/index.js
var require_exclude2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_exclude_from_mapped_result(), exports);
  __exportStar(require_exclude_from_template_literal(), exports);
  __exportStar(require_exclude(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-template-literal.js
var require_extract_from_template_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral2;
  var extract_1 = require_extract();
  var index_1 = require_template_literal2();
  function ExtractFromTemplateLiteral2(L, R) {
    return (0, extract_1.Extract)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract.js
var require_extract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Extract = Extract2;
  var type_1 = require_type2();
  var index_1 = require_union2();
  var index_2 = require_never2();
  var index_3 = require_extends2();
  var extract_from_mapped_result_1 = require_extract_from_mapped_result();
  var extract_from_template_literal_1 = require_extract_from_template_literal();
  var kind_1 = require_kind();
  function ExtractRest2(L, R) {
    const extracted = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) !== index_3.ExtendsResult.False);
    return extracted.length === 1 ? extracted[0] : (0, index_1.Union)(extracted);
  }
  function Extract2(L, R, options) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CreateType)((0, extract_from_template_literal_1.ExtractFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CreateType)((0, extract_from_mapped_result_1.ExtractFromMappedResult)(L, R), options);
    return (0, type_1.CreateType)((0, kind_1.IsUnion)(L) ? ExtractRest2(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? L : (0, index_2.Never)(), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-mapped-result.js
var require_extract_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtractFromMappedResult = ExtractFromMappedResult2;
  var index_1 = require_mapped2();
  var extract_1 = require_extract();
  function FromProperties20(P, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extract_1.Extract)(P[K2], T);
    return Acc;
  }
  function FromMappedResult13(R, T) {
    return FromProperties20(R.properties, T);
  }
  function ExtractFromMappedResult2(R, T) {
    const P = FromMappedResult13(R, T);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/index.js
var require_extract2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_extract_from_mapped_result(), exports);
  __exportStar(require_extract_from_template_literal(), exports);
  __exportStar(require_extract(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/instance-type.js
var require_instance_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstanceType = InstanceType2;
  var type_1 = require_type2();
  var index_1 = require_never2();
  var KindGuard = require_kind();
  function InstanceType2(schema, options) {
    return KindGuard.IsConstructor(schema) ? (0, type_1.CreateType)(schema.returns, options) : (0, index_1.Never)(options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/index.js
var require_instance_type2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instance_type(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/readonly-optional.js
var require_readonly_optional = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadonlyOptional = ReadonlyOptional2;
  var index_1 = require_readonly2();
  var index_2 = require_optional2();
  function ReadonlyOptional2(schema) {
    return (0, index_1.Readonly)((0, index_2.Optional)(schema));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/index.js
var require_readonly_optional2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_readonly_optional(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/record/record.js
var require_record = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Record = Record2;
  exports.RecordPattern = RecordPattern2;
  exports.RecordKey = RecordKey3;
  exports.RecordValue = RecordValue3;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var index_2 = require_never2();
  var index_3 = require_number2();
  var index_4 = require_object2();
  var index_5 = require_string2();
  var index_6 = require_union2();
  var index_7 = require_template_literal2();
  var index_8 = require_patterns2();
  var index_9 = require_indexed2();
  var value_1 = require_value();
  var kind_1 = require_kind();
  function RecordCreateFromPattern2(pattern, T, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
  }
  function RecordCreateFromKeys2(K, T, options) {
    const result = {};
    for (const K2 of K)
      result[K2] = T;
    return (0, index_4.Object)(result, { ...options, [index_1.Hint]: "Record" });
  }
  function FromTemplateLiteralKey2(K, T, options) {
    return (0, index_7.IsTemplateLiteralFinite)(K) ? RecordCreateFromKeys2((0, index_9.IndexPropertyKeys)(K), T, options) : RecordCreateFromPattern2(K.pattern, T, options);
  }
  function FromUnionKey2(key, type2, options) {
    return RecordCreateFromKeys2((0, index_9.IndexPropertyKeys)((0, index_6.Union)(key)), type2, options);
  }
  function FromLiteralKey2(key, type2, options) {
    return RecordCreateFromKeys2([key.toString()], type2, options);
  }
  function FromRegExpKey2(key, type2, options) {
    return RecordCreateFromPattern2(key.source, type2, options);
  }
  function FromStringKey2(key, type2, options) {
    const pattern = (0, value_1.IsUndefined)(key.pattern) ? index_8.PatternStringExact : key.pattern;
    return RecordCreateFromPattern2(pattern, type2, options);
  }
  function FromAnyKey2(_, type2, options) {
    return RecordCreateFromPattern2(index_8.PatternStringExact, type2, options);
  }
  function FromNeverKey2(_key, type2, options) {
    return RecordCreateFromPattern2(index_8.PatternNeverExact, type2, options);
  }
  function FromBooleanKey2(_key, type2, options) {
    return (0, index_4.Object)({ true: type2, false: type2 }, options);
  }
  function FromIntegerKey2(_key, type2, options) {
    return RecordCreateFromPattern2(index_8.PatternNumberExact, type2, options);
  }
  function FromNumberKey2(_, type2, options) {
    return RecordCreateFromPattern2(index_8.PatternNumberExact, type2, options);
  }
  function Record2(key, type2, options = {}) {
    return (0, kind_1.IsUnion)(key) ? FromUnionKey2(key.anyOf, type2, options) : (0, kind_1.IsTemplateLiteral)(key) ? FromTemplateLiteralKey2(key, type2, options) : (0, kind_1.IsLiteral)(key) ? FromLiteralKey2(key.const, type2, options) : (0, kind_1.IsBoolean)(key) ? FromBooleanKey2(key, type2, options) : (0, kind_1.IsInteger)(key) ? FromIntegerKey2(key, type2, options) : (0, kind_1.IsNumber)(key) ? FromNumberKey2(key, type2, options) : (0, kind_1.IsRegExp)(key) ? FromRegExpKey2(key, type2, options) : (0, kind_1.IsString)(key) ? FromStringKey2(key, type2, options) : (0, kind_1.IsAny)(key) ? FromAnyKey2(key, type2, options) : (0, kind_1.IsNever)(key) ? FromNeverKey2(key, type2, options) : (0, index_2.Never)(options);
  }
  function RecordPattern2(record) {
    return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
  }
  function RecordKey3(type2) {
    const pattern = RecordPattern2(type2);
    return pattern === index_8.PatternStringExact ? (0, index_5.String)() : pattern === index_8.PatternNumberExact ? (0, index_3.Number)() : (0, index_5.String)({ pattern });
  }
  function RecordValue3(type2) {
    return type2.patternProperties[RecordPattern2(type2)];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/record/index.js
var require_record2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_record(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/instantiate/instantiate.js
var require_instantiate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FromTypes = FromTypes3;
  exports.Instantiate = Instantiate2;
  var type_1 = require_type();
  var index_1 = require_unknown2();
  var index_2 = require_readonly_optional2();
  var index_3 = require_readonly2();
  var index_4 = require_optional2();
  var index_5 = require_object2();
  var index_6 = require_record2();
  var ValueGuard = require_value();
  var KindGuard = require_kind();
  function FromConstructor9(args, type2) {
    type2.parameters = FromTypes3(args, type2.parameters);
    type2.returns = FromType3(args, type2.returns);
    return type2;
  }
  function FromFunction8(args, type2) {
    type2.parameters = FromTypes3(args, type2.parameters);
    type2.returns = FromType3(args, type2.returns);
    return type2;
  }
  function FromIntersect19(args, type2) {
    type2.allOf = FromTypes3(args, type2.allOf);
    return type2;
  }
  function FromUnion21(args, type2) {
    type2.anyOf = FromTypes3(args, type2.anyOf);
    return type2;
  }
  function FromTuple16(args, type2) {
    if (ValueGuard.IsUndefined(type2.items))
      return type2;
    type2.items = FromTypes3(args, type2.items);
    return type2;
  }
  function FromArray18(args, type2) {
    type2.items = FromType3(args, type2.items);
    return type2;
  }
  function FromAsyncIterator8(args, type2) {
    type2.items = FromType3(args, type2.items);
    return type2;
  }
  function FromIterator8(args, type2) {
    type2.items = FromType3(args, type2.items);
    return type2;
  }
  function FromPromise8(args, type2) {
    type2.item = FromType3(args, type2.item);
    return type2;
  }
  function FromObject19(args, type2) {
    const mappedProperties = FromProperties20(args, type2.properties);
    return { ...type2, ...(0, index_5.Object)(mappedProperties) };
  }
  function FromRecord14(args, type2) {
    const mappedKey = FromType3(args, (0, index_6.RecordKey)(type2));
    const mappedValue = FromType3(args, (0, index_6.RecordValue)(type2));
    const result = (0, index_6.Record)(mappedKey, mappedValue);
    return { ...type2, ...result };
  }
  function FromArgument5(args, argument) {
    return argument.index in args ? args[argument.index] : (0, index_1.Unknown)();
  }
  function FromProperty4(args, type2) {
    const isReadonly = KindGuard.IsReadonly(type2);
    const isOptional2 = KindGuard.IsOptional(type2);
    const mapped = FromType3(args, type2);
    return isReadonly && isOptional2 ? (0, index_2.ReadonlyOptional)(mapped) : isReadonly && !isOptional2 ? (0, index_3.Readonly)(mapped) : !isReadonly && isOptional2 ? (0, index_4.Optional)(mapped) : mapped;
  }
  function FromProperties20(args, properties) {
    return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
      return { ...result, [key]: FromProperty4(args, properties[key]) };
    }, {});
  }
  function FromTypes3(args, types) {
    return types.map((type2) => FromType3(args, type2));
  }
  function FromType3(args, type2) {
    return KindGuard.IsConstructor(type2) ? FromConstructor9(args, type2) : KindGuard.IsFunction(type2) ? FromFunction8(args, type2) : KindGuard.IsIntersect(type2) ? FromIntersect19(args, type2) : KindGuard.IsUnion(type2) ? FromUnion21(args, type2) : KindGuard.IsTuple(type2) ? FromTuple16(args, type2) : KindGuard.IsArray(type2) ? FromArray18(args, type2) : KindGuard.IsAsyncIterator(type2) ? FromAsyncIterator8(args, type2) : KindGuard.IsIterator(type2) ? FromIterator8(args, type2) : KindGuard.IsPromise(type2) ? FromPromise8(args, type2) : KindGuard.IsObject(type2) ? FromObject19(args, type2) : KindGuard.IsRecord(type2) ? FromRecord14(args, type2) : KindGuard.IsArgument(type2) ? FromArgument5(args, type2) : type2;
  }
  function Instantiate2(type2, args) {
    return FromType3(args, (0, type_1.CloneType)(type2));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/instantiate/index.js
var require_instantiate2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instantiate(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/integer.js
var require_integer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Integer = Integer2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Integer2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Integer", type: "integer" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/index.js
var require_integer2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_integer(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic-from-mapped-key.js
var require_intrinsic_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntrinsicFromMappedKey = IntrinsicFromMappedKey2;
  var index_1 = require_mapped2();
  var intrinsic_1 = require_intrinsic();
  var index_2 = require_literal2();
  var value_1 = require_value2();
  function MappedIntrinsicPropertyKey2(K, M, options) {
    return {
      [K]: (0, intrinsic_1.Intrinsic)((0, index_2.Literal)(K), M, (0, value_1.Clone)(options))
    };
  }
  function MappedIntrinsicPropertyKeys2(K, M, options) {
    const result = K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIntrinsicPropertyKey2(L, M, options) };
    }, {});
    return result;
  }
  function MappedIntrinsicProperties2(T, M, options) {
    return MappedIntrinsicPropertyKeys2(T["keys"], M, options);
  }
  function IntrinsicFromMappedKey2(T, M, options) {
    const P = MappedIntrinsicProperties2(T, M, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic.js
var require_intrinsic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Intrinsic = Intrinsic2;
  var type_1 = require_type2();
  var index_1 = require_template_literal2();
  var intrinsic_from_mapped_key_1 = require_intrinsic_from_mapped_key();
  var index_2 = require_literal2();
  var index_3 = require_union2();
  var kind_1 = require_kind();
  function ApplyUncapitalize2(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toLowerCase(), rest].join("");
  }
  function ApplyCapitalize2(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toUpperCase(), rest].join("");
  }
  function ApplyUppercase2(value) {
    return value.toUpperCase();
  }
  function ApplyLowercase2(value) {
    return value.toLowerCase();
  }
  function FromTemplateLiteral7(schema, mode, options) {
    const expression = (0, index_1.TemplateLiteralParseExact)(schema.pattern);
    const finite = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);
    if (!finite)
      return { ...schema, pattern: FromLiteralValue2(schema.pattern, mode) };
    const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];
    const literals = strings.map((value) => (0, index_2.Literal)(value));
    const mapped = FromRest8(literals, mode);
    const union = (0, index_3.Union)(mapped);
    return (0, index_1.TemplateLiteral)([union], options);
  }
  function FromLiteralValue2(value, mode) {
    return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize2(value) : mode === "Capitalize" ? ApplyCapitalize2(value) : mode === "Uppercase" ? ApplyUppercase2(value) : mode === "Lowercase" ? ApplyLowercase2(value) : value : value.toString();
  }
  function FromRest8(T, M) {
    return T.map((L) => Intrinsic2(L, M));
  }
  function Intrinsic2(schema, mode, options = {}) {
    return (0, kind_1.IsMappedKey)(schema) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema, mode, options) : (0, kind_1.IsTemplateLiteral)(schema) ? FromTemplateLiteral7(schema, mode, options) : (0, kind_1.IsUnion)(schema) ? (0, index_3.Union)(FromRest8(schema.anyOf, mode), options) : (0, kind_1.IsLiteral)(schema) ? (0, index_2.Literal)(FromLiteralValue2(schema.const, mode), options) : (0, type_1.CreateType)(schema, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/capitalize.js
var require_capitalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Capitalize = Capitalize2;
  var intrinsic_1 = require_intrinsic();
  function Capitalize2(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Capitalize", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/lowercase.js
var require_lowercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Lowercase = Lowercase2;
  var intrinsic_1 = require_intrinsic();
  function Lowercase2(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Lowercase", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uncapitalize.js
var require_uncapitalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uncapitalize = Uncapitalize2;
  var intrinsic_1 = require_intrinsic();
  function Uncapitalize2(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uncapitalize", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uppercase.js
var require_uppercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uppercase = Uppercase2;
  var intrinsic_1 = require_intrinsic();
  function Uppercase2(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uppercase", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/index.js
var require_intrinsic2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_capitalize(), exports);
  __exportStar(require_intrinsic_from_mapped_key(), exports);
  __exportStar(require_intrinsic(), exports);
  __exportStar(require_lowercase(), exports);
  __exportStar(require_uncapitalize(), exports);
  __exportStar(require_uppercase(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-result.js
var require_omit_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OmitFromMappedResult = OmitFromMappedResult2;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  var value_1 = require_value2();
  function FromProperties20(properties, propertyKeys, options) {
    const result = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
      result[K2] = (0, omit_1.Omit)(properties[K2], propertyKeys, (0, value_1.Clone)(options));
    return result;
  }
  function FromMappedResult13(mappedResult, propertyKeys, options) {
    return FromProperties20(mappedResult.properties, propertyKeys, options);
  }
  function OmitFromMappedResult2(mappedResult, propertyKeys, options) {
    const properties = FromMappedResult13(mappedResult, propertyKeys, options);
    return (0, index_1.MappedResult)(properties);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit.js
var require_omit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Omit = Omit2;
  var type_1 = require_type2();
  var discard_1 = require_discard();
  var symbols_1 = require_symbols();
  var index_1 = require_computed2();
  var index_2 = require_literal2();
  var index_3 = require_indexed2();
  var index_4 = require_intersect2();
  var index_5 = require_union2();
  var index_6 = require_object2();
  var omit_from_mapped_key_1 = require_omit_from_mapped_key();
  var omit_from_mapped_result_1 = require_omit_from_mapped_result();
  var kind_1 = require_kind();
  var value_1 = require_value();
  function FromIntersect19(types, propertyKeys) {
    return types.map((type2) => OmitResolve2(type2, propertyKeys));
  }
  function FromUnion21(types, propertyKeys) {
    return types.map((type2) => OmitResolve2(type2, propertyKeys));
  }
  function FromProperty4(properties, key) {
    const { [key]: _, ...R } = properties;
    return R;
  }
  function FromProperties20(properties, propertyKeys) {
    return propertyKeys.reduce((T, K2) => FromProperty4(T, K2), properties);
  }
  function FromObject19(properties, propertyKeys) {
    const options = (0, discard_1.Discard)(properties, [symbols_1.TransformKind, "$id", "required", "properties"]);
    const omittedProperties = FromProperties20(properties["properties"], propertyKeys);
    return (0, index_6.Object)(omittedProperties, options);
  }
  function UnionFromPropertyKeys3(propertyKeys) {
    const result = propertyKeys.reduce((result2, key) => (0, kind_1.IsLiteralValue)(key) ? [...result2, (0, index_2.Literal)(key)] : result2, []);
    return (0, index_5.Union)(result);
  }
  function OmitResolve2(properties, propertyKeys) {
    return (0, kind_1.IsIntersect)(properties) ? (0, index_4.Intersect)(FromIntersect19(properties.allOf, propertyKeys)) : (0, kind_1.IsUnion)(properties) ? (0, index_5.Union)(FromUnion21(properties.anyOf, propertyKeys)) : (0, kind_1.IsObject)(properties) ? FromObject19(properties, propertyKeys) : (0, index_6.Object)({});
  }
  function Omit2(type2, key, options) {
    const typeKey = (0, value_1.IsArray)(key) ? UnionFromPropertyKeys3(key) : key;
    const propertyKeys = (0, kind_1.IsSchema)(key) ? (0, index_3.IndexPropertyKeys)(key) : key;
    const isTypeRef = (0, kind_1.IsRef)(type2);
    const isKeyRef = (0, kind_1.IsRef)(key);
    return (0, kind_1.IsMappedResult)(type2) ? (0, omit_from_mapped_result_1.OmitFromMappedResult)(type2, propertyKeys, options) : (0, kind_1.IsMappedKey)(key) ? (0, omit_from_mapped_key_1.OmitFromMappedKey)(type2, key, options) : isTypeRef && isKeyRef ? (0, index_1.Computed)("Omit", [type2, typeKey], options) : !isTypeRef && isKeyRef ? (0, index_1.Computed)("Omit", [type2, typeKey], options) : isTypeRef && !isKeyRef ? (0, index_1.Computed)("Omit", [type2, typeKey], options) : (0, type_1.CreateType)({ ...OmitResolve2(type2, propertyKeys), ...options });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-key.js
var require_omit_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OmitFromMappedKey = OmitFromMappedKey2;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  var value_1 = require_value2();
  function FromPropertyKey4(type2, key, options) {
    return { [key]: (0, omit_1.Omit)(type2, [key], (0, value_1.Clone)(options)) };
  }
  function FromPropertyKeys4(type2, propertyKeys, options) {
    return propertyKeys.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey4(type2, LK, options) };
    }, {});
  }
  function FromMappedKey5(type2, mappedKey, options) {
    return FromPropertyKeys4(type2, mappedKey.keys, options);
  }
  function OmitFromMappedKey2(type2, mappedKey, options) {
    const properties = FromMappedKey5(type2, mappedKey, options);
    return (0, index_1.MappedResult)(properties);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/index.js
var require_omit2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_omit_from_mapped_key(), exports);
  __exportStar(require_omit_from_mapped_result(), exports);
  __exportStar(require_omit(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-result.js
var require_pick_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PickFromMappedResult = PickFromMappedResult2;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  var value_1 = require_value2();
  function FromProperties20(properties, propertyKeys, options) {
    const result = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
      result[K2] = (0, pick_1.Pick)(properties[K2], propertyKeys, (0, value_1.Clone)(options));
    return result;
  }
  function FromMappedResult13(mappedResult, propertyKeys, options) {
    return FromProperties20(mappedResult.properties, propertyKeys, options);
  }
  function PickFromMappedResult2(mappedResult, propertyKeys, options) {
    const properties = FromMappedResult13(mappedResult, propertyKeys, options);
    return (0, index_1.MappedResult)(properties);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick.js
var require_pick = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pick = Pick2;
  var type_1 = require_type2();
  var discard_1 = require_discard();
  var index_1 = require_computed2();
  var index_2 = require_intersect2();
  var index_3 = require_literal2();
  var index_4 = require_object2();
  var index_5 = require_union2();
  var index_6 = require_indexed2();
  var symbols_1 = require_symbols();
  var kind_1 = require_kind();
  var value_1 = require_value();
  var pick_from_mapped_key_1 = require_pick_from_mapped_key();
  var pick_from_mapped_result_1 = require_pick_from_mapped_result();
  function FromIntersect19(types, propertyKeys) {
    return types.map((type2) => PickResolve2(type2, propertyKeys));
  }
  function FromUnion21(types, propertyKeys) {
    return types.map((type2) => PickResolve2(type2, propertyKeys));
  }
  function FromProperties20(properties, propertyKeys) {
    const result = {};
    for (const K2 of propertyKeys)
      if (K2 in properties)
        result[K2] = properties[K2];
    return result;
  }
  function FromObject19(T, K) {
    const options = (0, discard_1.Discard)(T, [symbols_1.TransformKind, "$id", "required", "properties"]);
    const properties = FromProperties20(T["properties"], K);
    return (0, index_4.Object)(properties, options);
  }
  function UnionFromPropertyKeys3(propertyKeys) {
    const result = propertyKeys.reduce((result2, key) => (0, kind_1.IsLiteralValue)(key) ? [...result2, (0, index_3.Literal)(key)] : result2, []);
    return (0, index_5.Union)(result);
  }
  function PickResolve2(properties, propertyKeys) {
    return (0, kind_1.IsIntersect)(properties) ? (0, index_2.Intersect)(FromIntersect19(properties.allOf, propertyKeys)) : (0, kind_1.IsUnion)(properties) ? (0, index_5.Union)(FromUnion21(properties.anyOf, propertyKeys)) : (0, kind_1.IsObject)(properties) ? FromObject19(properties, propertyKeys) : (0, index_4.Object)({});
  }
  function Pick2(type2, key, options) {
    const typeKey = (0, value_1.IsArray)(key) ? UnionFromPropertyKeys3(key) : key;
    const propertyKeys = (0, kind_1.IsSchema)(key) ? (0, index_6.IndexPropertyKeys)(key) : key;
    const isTypeRef = (0, kind_1.IsRef)(type2);
    const isKeyRef = (0, kind_1.IsRef)(key);
    return (0, kind_1.IsMappedResult)(type2) ? (0, pick_from_mapped_result_1.PickFromMappedResult)(type2, propertyKeys, options) : (0, kind_1.IsMappedKey)(key) ? (0, pick_from_mapped_key_1.PickFromMappedKey)(type2, key, options) : isTypeRef && isKeyRef ? (0, index_1.Computed)("Pick", [type2, typeKey], options) : !isTypeRef && isKeyRef ? (0, index_1.Computed)("Pick", [type2, typeKey], options) : isTypeRef && !isKeyRef ? (0, index_1.Computed)("Pick", [type2, typeKey], options) : (0, type_1.CreateType)({ ...PickResolve2(type2, propertyKeys), ...options });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-key.js
var require_pick_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PickFromMappedKey = PickFromMappedKey2;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  var value_1 = require_value2();
  function FromPropertyKey4(type2, key, options) {
    return {
      [key]: (0, pick_1.Pick)(type2, [key], (0, value_1.Clone)(options))
    };
  }
  function FromPropertyKeys4(type2, propertyKeys, options) {
    return propertyKeys.reduce((result, leftKey) => {
      return { ...result, ...FromPropertyKey4(type2, leftKey, options) };
    }, {});
  }
  function FromMappedKey5(type2, mappedKey, options) {
    return FromPropertyKeys4(type2, mappedKey.keys, options);
  }
  function PickFromMappedKey2(type2, mappedKey, options) {
    const properties = FromMappedKey5(type2, mappedKey, options);
    return (0, index_1.MappedResult)(properties);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/index.js
var require_pick2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_pick_from_mapped_key(), exports);
  __exportStar(require_pick_from_mapped_result(), exports);
  __exportStar(require_pick(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial.js
var require_partial = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Partial = Partial2;
  var type_1 = require_type2();
  var index_1 = require_computed2();
  var index_2 = require_optional2();
  var index_3 = require_object2();
  var index_4 = require_intersect2();
  var index_5 = require_union2();
  var index_6 = require_ref2();
  var index_7 = require_discard2();
  var index_8 = require_symbols2();
  var partial_from_mapped_result_1 = require_partial_from_mapped_result();
  var KindGuard = require_kind();
  function FromComputed6(target, parameters) {
    return (0, index_1.Computed)("Partial", [(0, index_1.Computed)(target, parameters)]);
  }
  function FromRef15($ref) {
    return (0, index_1.Computed)("Partial", [(0, index_6.Ref)($ref)]);
  }
  function FromProperties20(properties) {
    const partialProperties = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties))
      partialProperties[K] = (0, index_2.Optional)(properties[K]);
    return partialProperties;
  }
  function FromObject19(type2) {
    const options = (0, index_7.Discard)(type2, [index_8.TransformKind, "$id", "required", "properties"]);
    const properties = FromProperties20(type2["properties"]);
    return (0, index_3.Object)(properties, options);
  }
  function FromRest8(types) {
    return types.map((type2) => PartialResolve2(type2));
  }
  function PartialResolve2(type2) {
    return KindGuard.IsComputed(type2) ? FromComputed6(type2.target, type2.parameters) : KindGuard.IsRef(type2) ? FromRef15(type2.$ref) : KindGuard.IsIntersect(type2) ? (0, index_4.Intersect)(FromRest8(type2.allOf)) : KindGuard.IsUnion(type2) ? (0, index_5.Union)(FromRest8(type2.anyOf)) : KindGuard.IsObject(type2) ? FromObject19(type2) : KindGuard.IsBigInt(type2) ? type2 : KindGuard.IsBoolean(type2) ? type2 : KindGuard.IsInteger(type2) ? type2 : KindGuard.IsLiteral(type2) ? type2 : KindGuard.IsNull(type2) ? type2 : KindGuard.IsNumber(type2) ? type2 : KindGuard.IsString(type2) ? type2 : KindGuard.IsSymbol(type2) ? type2 : KindGuard.IsUndefined(type2) ? type2 : (0, index_3.Object)({});
  }
  function Partial2(type2, options) {
    if (KindGuard.IsMappedResult(type2)) {
      return (0, partial_from_mapped_result_1.PartialFromMappedResult)(type2, options);
    } else {
      return (0, type_1.CreateType)({ ...PartialResolve2(type2), ...options });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial-from-mapped-result.js
var require_partial_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PartialFromMappedResult = PartialFromMappedResult2;
  var index_1 = require_mapped2();
  var partial_1 = require_partial();
  var value_1 = require_value2();
  function FromProperties20(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, partial_1.Partial)(K[K2], (0, value_1.Clone)(options));
    return Acc;
  }
  function FromMappedResult13(R, options) {
    return FromProperties20(R.properties, options);
  }
  function PartialFromMappedResult2(R, options) {
    const P = FromMappedResult13(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/index.js
var require_partial2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_partial_from_mapped_result(), exports);
  __exportStar(require_partial(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required.js
var require_required = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Required = Required2;
  var type_1 = require_type2();
  var index_1 = require_computed2();
  var index_2 = require_object2();
  var index_3 = require_intersect2();
  var index_4 = require_union2();
  var index_5 = require_ref2();
  var index_6 = require_symbols2();
  var index_7 = require_discard2();
  var required_from_mapped_result_1 = require_required_from_mapped_result();
  var KindGuard = require_kind();
  function FromComputed6(target, parameters) {
    return (0, index_1.Computed)("Required", [(0, index_1.Computed)(target, parameters)]);
  }
  function FromRef15($ref) {
    return (0, index_1.Computed)("Required", [(0, index_5.Ref)($ref)]);
  }
  function FromProperties20(properties) {
    const requiredProperties = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties))
      requiredProperties[K] = (0, index_7.Discard)(properties[K], [index_6.OptionalKind]);
    return requiredProperties;
  }
  function FromObject19(type2) {
    const options = (0, index_7.Discard)(type2, [index_6.TransformKind, "$id", "required", "properties"]);
    const properties = FromProperties20(type2["properties"]);
    return (0, index_2.Object)(properties, options);
  }
  function FromRest8(types) {
    return types.map((type2) => RequiredResolve2(type2));
  }
  function RequiredResolve2(type2) {
    return KindGuard.IsComputed(type2) ? FromComputed6(type2.target, type2.parameters) : KindGuard.IsRef(type2) ? FromRef15(type2.$ref) : KindGuard.IsIntersect(type2) ? (0, index_3.Intersect)(FromRest8(type2.allOf)) : KindGuard.IsUnion(type2) ? (0, index_4.Union)(FromRest8(type2.anyOf)) : KindGuard.IsObject(type2) ? FromObject19(type2) : KindGuard.IsBigInt(type2) ? type2 : KindGuard.IsBoolean(type2) ? type2 : KindGuard.IsInteger(type2) ? type2 : KindGuard.IsLiteral(type2) ? type2 : KindGuard.IsNull(type2) ? type2 : KindGuard.IsNumber(type2) ? type2 : KindGuard.IsString(type2) ? type2 : KindGuard.IsSymbol(type2) ? type2 : KindGuard.IsUndefined(type2) ? type2 : (0, index_2.Object)({});
  }
  function Required2(type2, options) {
    if (KindGuard.IsMappedResult(type2)) {
      return (0, required_from_mapped_result_1.RequiredFromMappedResult)(type2, options);
    } else {
      return (0, type_1.CreateType)({ ...RequiredResolve2(type2), ...options });
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required-from-mapped-result.js
var require_required_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequiredFromMappedResult = RequiredFromMappedResult2;
  var index_1 = require_mapped2();
  var required_1 = require_required();
  function FromProperties20(P, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, required_1.Required)(P[K2], options);
    return Acc;
  }
  function FromMappedResult13(R, options) {
    return FromProperties20(R.properties, options);
  }
  function RequiredFromMappedResult2(R, options) {
    const P = FromMappedResult13(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/index.js
var require_required2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_required_from_mapped_result(), exports);
  __exportStar(require_required(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/module/compute.js
var require_compute = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FromType = FromType3;
  exports.ComputeType = ComputeType2;
  exports.ComputeModuleProperties = ComputeModuleProperties2;
  var index_1 = require_create();
  var index_2 = require_clone2();
  var index_3 = require_discard2();
  var index_4 = require_array2();
  var index_5 = require_awaited2();
  var index_6 = require_async_iterator2();
  var index_7 = require_constructor2();
  var index_8 = require_indexed2();
  var index_9 = require_function2();
  var index_10 = require_intersect2();
  var index_11 = require_iterator2();
  var index_12 = require_keyof2();
  var index_13 = require_object2();
  var index_14 = require_omit2();
  var index_15 = require_pick2();
  var index_16 = require_never2();
  var index_17 = require_partial2();
  var index_18 = require_record2();
  var index_19 = require_required2();
  var index_20 = require_tuple2();
  var index_21 = require_union2();
  var index_22 = require_symbols2();
  var KindGuard = require_kind();
  function DereferenceParameters2(moduleProperties, types) {
    return types.map((type2) => {
      return KindGuard.IsRef(type2) ? Dereference2(moduleProperties, type2.$ref) : FromType3(moduleProperties, type2);
    });
  }
  function Dereference2(moduleProperties, ref) {
    return ref in moduleProperties ? KindGuard.IsRef(moduleProperties[ref]) ? Dereference2(moduleProperties, moduleProperties[ref].$ref) : FromType3(moduleProperties, moduleProperties[ref]) : (0, index_16.Never)();
  }
  function FromAwaited2(parameters) {
    return (0, index_5.Awaited)(parameters[0]);
  }
  function FromIndex2(parameters) {
    return (0, index_8.Index)(parameters[0], parameters[1]);
  }
  function FromKeyOf2(parameters) {
    return (0, index_12.KeyOf)(parameters[0]);
  }
  function FromPartial2(parameters) {
    return (0, index_17.Partial)(parameters[0]);
  }
  function FromOmit2(parameters) {
    return (0, index_14.Omit)(parameters[0], parameters[1]);
  }
  function FromPick2(parameters) {
    return (0, index_15.Pick)(parameters[0], parameters[1]);
  }
  function FromRequired2(parameters) {
    return (0, index_19.Required)(parameters[0]);
  }
  function FromComputed6(moduleProperties, target, parameters) {
    const dereferenced = DereferenceParameters2(moduleProperties, parameters);
    return target === "Awaited" ? FromAwaited2(dereferenced) : target === "Index" ? FromIndex2(dereferenced) : target === "KeyOf" ? FromKeyOf2(dereferenced) : target === "Partial" ? FromPartial2(dereferenced) : target === "Omit" ? FromOmit2(dereferenced) : target === "Pick" ? FromPick2(dereferenced) : target === "Required" ? FromRequired2(dereferenced) : (0, index_16.Never)();
  }
  function FromArray18(moduleProperties, type2) {
    return (0, index_4.Array)(FromType3(moduleProperties, type2));
  }
  function FromAsyncIterator8(moduleProperties, type2) {
    return (0, index_6.AsyncIterator)(FromType3(moduleProperties, type2));
  }
  function FromConstructor9(moduleProperties, parameters, instanceType) {
    return (0, index_7.Constructor)(FromTypes3(moduleProperties, parameters), FromType3(moduleProperties, instanceType));
  }
  function FromFunction8(moduleProperties, parameters, returnType) {
    return (0, index_9.Function)(FromTypes3(moduleProperties, parameters), FromType3(moduleProperties, returnType));
  }
  function FromIntersect19(moduleProperties, types) {
    return (0, index_10.Intersect)(FromTypes3(moduleProperties, types));
  }
  function FromIterator8(moduleProperties, type2) {
    return (0, index_11.Iterator)(FromType3(moduleProperties, type2));
  }
  function FromObject19(moduleProperties, properties) {
    return (0, index_13.Object)(globalThis.Object.keys(properties).reduce((result, key) => {
      return { ...result, [key]: FromType3(moduleProperties, properties[key]) };
    }, {}));
  }
  function FromRecord14(moduleProperties, type2) {
    const [value, pattern] = [FromType3(moduleProperties, (0, index_18.RecordValue)(type2)), (0, index_18.RecordPattern)(type2)];
    const result = (0, index_2.CloneType)(type2);
    result.patternProperties[pattern] = value;
    return result;
  }
  function FromTransform2(moduleProperties, transform2) {
    return KindGuard.IsRef(transform2) ? { ...Dereference2(moduleProperties, transform2.$ref), [index_22.TransformKind]: transform2[index_22.TransformKind] } : transform2;
  }
  function FromTuple16(moduleProperties, types) {
    return (0, index_20.Tuple)(FromTypes3(moduleProperties, types));
  }
  function FromUnion21(moduleProperties, types) {
    return (0, index_21.Union)(FromTypes3(moduleProperties, types));
  }
  function FromTypes3(moduleProperties, types) {
    return types.map((type2) => FromType3(moduleProperties, type2));
  }
  function FromType3(moduleProperties, type2) {
    return KindGuard.IsOptional(type2) ? (0, index_1.CreateType)(FromType3(moduleProperties, (0, index_3.Discard)(type2, [index_22.OptionalKind])), type2) : KindGuard.IsReadonly(type2) ? (0, index_1.CreateType)(FromType3(moduleProperties, (0, index_3.Discard)(type2, [index_22.ReadonlyKind])), type2) : KindGuard.IsTransform(type2) ? (0, index_1.CreateType)(FromTransform2(moduleProperties, type2), type2) : KindGuard.IsArray(type2) ? (0, index_1.CreateType)(FromArray18(moduleProperties, type2.items), type2) : KindGuard.IsAsyncIterator(type2) ? (0, index_1.CreateType)(FromAsyncIterator8(moduleProperties, type2.items), type2) : KindGuard.IsComputed(type2) ? (0, index_1.CreateType)(FromComputed6(moduleProperties, type2.target, type2.parameters)) : KindGuard.IsConstructor(type2) ? (0, index_1.CreateType)(FromConstructor9(moduleProperties, type2.parameters, type2.returns), type2) : KindGuard.IsFunction(type2) ? (0, index_1.CreateType)(FromFunction8(moduleProperties, type2.parameters, type2.returns), type2) : KindGuard.IsIntersect(type2) ? (0, index_1.CreateType)(FromIntersect19(moduleProperties, type2.allOf), type2) : KindGuard.IsIterator(type2) ? (0, index_1.CreateType)(FromIterator8(moduleProperties, type2.items), type2) : KindGuard.IsObject(type2) ? (0, index_1.CreateType)(FromObject19(moduleProperties, type2.properties), type2) : KindGuard.IsRecord(type2) ? (0, index_1.CreateType)(FromRecord14(moduleProperties, type2)) : KindGuard.IsTuple(type2) ? (0, index_1.CreateType)(FromTuple16(moduleProperties, type2.items || []), type2) : KindGuard.IsUnion(type2) ? (0, index_1.CreateType)(FromUnion21(moduleProperties, type2.anyOf), type2) : type2;
  }
  function ComputeType2(moduleProperties, key) {
    return key in moduleProperties ? FromType3(moduleProperties, moduleProperties[key]) : (0, index_16.Never)();
  }
  function ComputeModuleProperties2(moduleProperties) {
    return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
      return { ...result, [key]: ComputeType2(moduleProperties, key) };
    }, {});
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/module/module.js
var require_module = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TModule = undefined;
  exports.Module = Module2;
  var index_1 = require_create();
  var index_2 = require_symbols2();
  var compute_1 = require_compute();

  class TModule2 {
    constructor($defs) {
      const computed = (0, compute_1.ComputeModuleProperties)($defs);
      const identified = this.WithIdentifiers(computed);
      this.$defs = identified;
    }
    Import(key, options) {
      const $defs = { ...this.$defs, [key]: (0, index_1.CreateType)(this.$defs[key], options) };
      return (0, index_1.CreateType)({ [index_2.Kind]: "Import", $defs, $ref: key });
    }
    WithIdentifiers($defs) {
      return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
        return { ...result, [key]: { ...$defs[key], $id: key } };
      }, {});
    }
  }
  exports.TModule = TModule2;
  function Module2(properties) {
    return new TModule2(properties);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/module/index.js
var require_module2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_module(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/not/not.js
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Not = Not3;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Not3(type2, options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Not", not: type2 }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/not/index.js
var require_not2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_not(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/parameters.js
var require_parameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parameters = Parameters2;
  var index_1 = require_tuple2();
  var index_2 = require_never2();
  var KindGuard = require_kind();
  function Parameters2(schema, options) {
    return KindGuard.IsFunction(schema) ? (0, index_1.Tuple)(schema.parameters, options) : (0, index_2.Never)();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/index.js
var require_parameters2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_parameters(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/recursive.js
var require_recursive = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Recursive = Recursive2;
  var type_1 = require_type();
  var type_2 = require_type2();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  var Ordinal2 = 0;
  function Recursive2(callback, options = {}) {
    if ((0, value_1.IsUndefined)(options.$id))
      options.$id = `T${Ordinal2++}`;
    const thisType = (0, type_1.CloneType)(callback({ [index_1.Kind]: "This", $ref: `${options.$id}` }));
    thisType.$id = options.$id;
    return (0, type_2.CreateType)({ [index_1.Hint]: "Recursive", ...thisType }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/index.js
var require_recursive2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_recursive(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/regexp.js
var require_regexp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RegExp = RegExp3;
  var type_1 = require_type2();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  function RegExp3(unresolved, options) {
    const expr = (0, value_1.IsString)(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
    return (0, type_1.CreateType)({ [index_1.Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/index.js
var require_regexp2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_regexp(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/rest.js
var require_rest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Rest = Rest2;
  var kind_1 = require_kind();
  function RestResolve2(T) {
    return (0, kind_1.IsIntersect)(T) ? T.allOf : (0, kind_1.IsUnion)(T) ? T.anyOf : (0, kind_1.IsTuple)(T) ? T.items ?? [] : [];
  }
  function Rest2(T) {
    return RestResolve2(T);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/index.js
var require_rest2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_rest(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/return-type.js
var require_return_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReturnType = ReturnType2;
  var type_1 = require_type2();
  var index_1 = require_never2();
  var KindGuard = require_kind();
  function ReturnType2(schema, options) {
    return KindGuard.IsFunction(schema) ? (0, type_1.CreateType)(schema.returns, options) : (0, index_1.Never)(options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/index.js
var require_return_type2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_return_type(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/anyschema.js
var require_anyschema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/schema.js
var require_schema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/index.js
var require_schema2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_anyschema(), exports);
  __exportStar(require_schema(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/static/static.js
var require_static = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/cjs/type/static/index.js
var require_static2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_static(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/transform.js
var require_transform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = undefined;
  exports.Transform = Transform2;
  var index_1 = require_symbols2();
  var kind_1 = require_kind();

  class TransformDecodeBuilder2 {
    constructor(schema) {
      this.schema = schema;
    }
    Decode(decode3) {
      return new TransformEncodeBuilder2(this.schema, decode3);
    }
  }
  exports.TransformDecodeBuilder = TransformDecodeBuilder2;

  class TransformEncodeBuilder2 {
    constructor(schema, decode3) {
      this.schema = schema;
      this.decode = decode3;
    }
    EncodeTransform(encode2, schema) {
      const Encode2 = (value) => schema[index_1.TransformKind].Encode(encode2(value));
      const Decode2 = (value) => this.decode(schema[index_1.TransformKind].Decode(value));
      const Codec = { Encode: Encode2, Decode: Decode2 };
      return { ...schema, [index_1.TransformKind]: Codec };
    }
    EncodeSchema(encode2, schema) {
      const Codec = { Decode: this.decode, Encode: encode2 };
      return { ...schema, [index_1.TransformKind]: Codec };
    }
    Encode(encode2) {
      return (0, kind_1.IsTransform)(this.schema) ? this.EncodeTransform(encode2, this.schema) : this.EncodeSchema(encode2, this.schema);
    }
  }
  exports.TransformEncodeBuilder = TransformEncodeBuilder2;
  function Transform2(schema) {
    return new TransformDecodeBuilder2(schema);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/index.js
var require_transform2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_transform(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/unsafe.js
var require_unsafe = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unsafe = Unsafe2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Unsafe2(options = {}) {
    return (0, type_1.CreateType)({ [index_1.Kind]: options[index_1.Kind] ?? "Unsafe" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/index.js
var require_unsafe2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_unsafe(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/void/void.js
var require_void = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Void = Void2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Void2(options) {
    return (0, type_1.CreateType)({ [index_1.Kind]: "Void", type: "void" }, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/void/index.js
var require_void2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_void(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/type/json.js
var require_json = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonTypeBuilder = undefined;
  var index_1 = require_any2();
  var index_2 = require_array2();
  var index_3 = require_boolean2();
  var index_4 = require_composite2();
  var index_5 = require_const2();
  var index_6 = require_enum2();
  var index_7 = require_exclude2();
  var index_8 = require_extends2();
  var index_9 = require_extract2();
  var index_10 = require_indexed2();
  var index_11 = require_integer2();
  var index_12 = require_intersect2();
  var index_13 = require_intrinsic2();
  var index_14 = require_keyof2();
  var index_15 = require_literal2();
  var index_16 = require_mapped2();
  var index_17 = require_never2();
  var index_18 = require_not2();
  var index_19 = require_null2();
  var index_20 = require_module2();
  var index_21 = require_number2();
  var index_22 = require_object2();
  var index_23 = require_omit2();
  var index_24 = require_optional2();
  var index_25 = require_partial2();
  var index_26 = require_pick2();
  var index_27 = require_readonly2();
  var index_28 = require_readonly_optional2();
  var index_29 = require_record2();
  var index_30 = require_recursive2();
  var index_31 = require_ref2();
  var index_32 = require_required2();
  var index_33 = require_rest2();
  var index_34 = require_string2();
  var index_35 = require_template_literal2();
  var index_36 = require_transform2();
  var index_37 = require_tuple2();
  var index_38 = require_union2();
  var index_39 = require_unknown2();
  var index_40 = require_unsafe2();

  class JsonTypeBuilder {
    ReadonlyOptional(type2) {
      return (0, index_28.ReadonlyOptional)(type2);
    }
    Readonly(type2, enable) {
      return (0, index_27.Readonly)(type2, enable ?? true);
    }
    Optional(type2, enable) {
      return (0, index_24.Optional)(type2, enable ?? true);
    }
    Any(options) {
      return (0, index_1.Any)(options);
    }
    Array(items, options) {
      return (0, index_2.Array)(items, options);
    }
    Boolean(options) {
      return (0, index_3.Boolean)(options);
    }
    Capitalize(schema, options) {
      return (0, index_13.Capitalize)(schema, options);
    }
    Composite(schemas, options) {
      return (0, index_4.Composite)(schemas, options);
    }
    Const(value, options) {
      return (0, index_5.Const)(value, options);
    }
    Enum(item, options) {
      return (0, index_6.Enum)(item, options);
    }
    Exclude(unionType, excludedMembers, options) {
      return (0, index_7.Exclude)(unionType, excludedMembers, options);
    }
    Extends(L, R, T, F, options) {
      return (0, index_8.Extends)(L, R, T, F, options);
    }
    Extract(type2, union, options) {
      return (0, index_9.Extract)(type2, union, options);
    }
    Index(type2, key, options) {
      return (0, index_10.Index)(type2, key, options);
    }
    Integer(options) {
      return (0, index_11.Integer)(options);
    }
    Intersect(types, options) {
      return (0, index_12.Intersect)(types, options);
    }
    KeyOf(type2, options) {
      return (0, index_14.KeyOf)(type2, options);
    }
    Literal(literalValue, options) {
      return (0, index_15.Literal)(literalValue, options);
    }
    Lowercase(type2, options) {
      return (0, index_13.Lowercase)(type2, options);
    }
    Mapped(key, map3, options) {
      return (0, index_16.Mapped)(key, map3, options);
    }
    Module(properties) {
      return (0, index_20.Module)(properties);
    }
    Never(options) {
      return (0, index_17.Never)(options);
    }
    Not(type2, options) {
      return (0, index_18.Not)(type2, options);
    }
    Null(options) {
      return (0, index_19.Null)(options);
    }
    Number(options) {
      return (0, index_21.Number)(options);
    }
    Object(properties, options) {
      return (0, index_22.Object)(properties, options);
    }
    Omit(schema, selector, options) {
      return (0, index_23.Omit)(schema, selector, options);
    }
    Partial(type2, options) {
      return (0, index_25.Partial)(type2, options);
    }
    Pick(type2, key, options) {
      return (0, index_26.Pick)(type2, key, options);
    }
    Record(key, value, options) {
      return (0, index_29.Record)(key, value, options);
    }
    Recursive(callback, options) {
      return (0, index_30.Recursive)(callback, options);
    }
    Ref(...args) {
      return (0, index_31.Ref)(args[0], args[1]);
    }
    Required(type2, options) {
      return (0, index_32.Required)(type2, options);
    }
    Rest(type2) {
      return (0, index_33.Rest)(type2);
    }
    String(options) {
      return (0, index_34.String)(options);
    }
    TemplateLiteral(unresolved, options) {
      return (0, index_35.TemplateLiteral)(unresolved, options);
    }
    Transform(type2) {
      return (0, index_36.Transform)(type2);
    }
    Tuple(types, options) {
      return (0, index_37.Tuple)(types, options);
    }
    Uncapitalize(type2, options) {
      return (0, index_13.Uncapitalize)(type2, options);
    }
    Union(types, options) {
      return (0, index_38.Union)(types, options);
    }
    Unknown(options) {
      return (0, index_39.Unknown)(options);
    }
    Unsafe(options) {
      return (0, index_40.Unsafe)(options);
    }
    Uppercase(schema, options) {
      return (0, index_13.Uppercase)(schema, options);
    }
  }
  exports.JsonTypeBuilder = JsonTypeBuilder;
});

// node_modules/@sinclair/typebox/build/cjs/type/type/type.js
var require_type5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Rest = exports.Required = exports.RegExp = exports.Ref = exports.Recursive = exports.Record = exports.ReadonlyOptional = exports.Readonly = exports.Promise = exports.Pick = exports.Partial = exports.Parameters = exports.Optional = exports.Omit = exports.Object = exports.Number = exports.Null = exports.Not = exports.Never = exports.Module = exports.Mapped = exports.Literal = exports.KeyOf = exports.Iterator = exports.Uppercase = exports.Lowercase = exports.Uncapitalize = exports.Capitalize = exports.Intersect = exports.Integer = exports.Instantiate = exports.InstanceType = exports.Index = exports.Function = exports.Extract = exports.Extends = exports.Exclude = exports.Enum = exports.Date = exports.ConstructorParameters = exports.Constructor = exports.Const = exports.Composite = exports.Boolean = exports.BigInt = exports.Awaited = exports.AsyncIterator = exports.Array = exports.Argument = exports.Any = undefined;
  exports.Void = exports.Unsafe = exports.Unknown = exports.Union = exports.Undefined = exports.Uint8Array = exports.Tuple = exports.Transform = exports.TemplateLiteral = exports.Symbol = exports.String = exports.ReturnType = undefined;
  var index_1 = require_any2();
  Object.defineProperty(exports, "Any", { enumerable: true, get: function() {
    return index_1.Any;
  } });
  var index_2 = require_argument2();
  Object.defineProperty(exports, "Argument", { enumerable: true, get: function() {
    return index_2.Argument;
  } });
  var index_3 = require_array2();
  Object.defineProperty(exports, "Array", { enumerable: true, get: function() {
    return index_3.Array;
  } });
  var index_4 = require_async_iterator2();
  Object.defineProperty(exports, "AsyncIterator", { enumerable: true, get: function() {
    return index_4.AsyncIterator;
  } });
  var index_5 = require_awaited2();
  Object.defineProperty(exports, "Awaited", { enumerable: true, get: function() {
    return index_5.Awaited;
  } });
  var index_6 = require_bigint2();
  Object.defineProperty(exports, "BigInt", { enumerable: true, get: function() {
    return index_6.BigInt;
  } });
  var index_7 = require_boolean2();
  Object.defineProperty(exports, "Boolean", { enumerable: true, get: function() {
    return index_7.Boolean;
  } });
  var index_8 = require_composite2();
  Object.defineProperty(exports, "Composite", { enumerable: true, get: function() {
    return index_8.Composite;
  } });
  var index_9 = require_const2();
  Object.defineProperty(exports, "Const", { enumerable: true, get: function() {
    return index_9.Const;
  } });
  var index_10 = require_constructor2();
  Object.defineProperty(exports, "Constructor", { enumerable: true, get: function() {
    return index_10.Constructor;
  } });
  var index_11 = require_constructor_parameters2();
  Object.defineProperty(exports, "ConstructorParameters", { enumerable: true, get: function() {
    return index_11.ConstructorParameters;
  } });
  var index_12 = require_date2();
  Object.defineProperty(exports, "Date", { enumerable: true, get: function() {
    return index_12.Date;
  } });
  var index_13 = require_enum2();
  Object.defineProperty(exports, "Enum", { enumerable: true, get: function() {
    return index_13.Enum;
  } });
  var index_14 = require_exclude2();
  Object.defineProperty(exports, "Exclude", { enumerable: true, get: function() {
    return index_14.Exclude;
  } });
  var index_15 = require_extends2();
  Object.defineProperty(exports, "Extends", { enumerable: true, get: function() {
    return index_15.Extends;
  } });
  var index_16 = require_extract2();
  Object.defineProperty(exports, "Extract", { enumerable: true, get: function() {
    return index_16.Extract;
  } });
  var index_17 = require_function2();
  Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
    return index_17.Function;
  } });
  var index_18 = require_indexed2();
  Object.defineProperty(exports, "Index", { enumerable: true, get: function() {
    return index_18.Index;
  } });
  var index_19 = require_instance_type2();
  Object.defineProperty(exports, "InstanceType", { enumerable: true, get: function() {
    return index_19.InstanceType;
  } });
  var index_20 = require_instantiate2();
  Object.defineProperty(exports, "Instantiate", { enumerable: true, get: function() {
    return index_20.Instantiate;
  } });
  var index_21 = require_integer2();
  Object.defineProperty(exports, "Integer", { enumerable: true, get: function() {
    return index_21.Integer;
  } });
  var index_22 = require_intersect2();
  Object.defineProperty(exports, "Intersect", { enumerable: true, get: function() {
    return index_22.Intersect;
  } });
  var index_23 = require_intrinsic2();
  Object.defineProperty(exports, "Capitalize", { enumerable: true, get: function() {
    return index_23.Capitalize;
  } });
  Object.defineProperty(exports, "Uncapitalize", { enumerable: true, get: function() {
    return index_23.Uncapitalize;
  } });
  Object.defineProperty(exports, "Lowercase", { enumerable: true, get: function() {
    return index_23.Lowercase;
  } });
  Object.defineProperty(exports, "Uppercase", { enumerable: true, get: function() {
    return index_23.Uppercase;
  } });
  var index_24 = require_iterator2();
  Object.defineProperty(exports, "Iterator", { enumerable: true, get: function() {
    return index_24.Iterator;
  } });
  var index_25 = require_keyof2();
  Object.defineProperty(exports, "KeyOf", { enumerable: true, get: function() {
    return index_25.KeyOf;
  } });
  var index_26 = require_literal2();
  Object.defineProperty(exports, "Literal", { enumerable: true, get: function() {
    return index_26.Literal;
  } });
  var index_27 = require_mapped2();
  Object.defineProperty(exports, "Mapped", { enumerable: true, get: function() {
    return index_27.Mapped;
  } });
  var index_28 = require_module2();
  Object.defineProperty(exports, "Module", { enumerable: true, get: function() {
    return index_28.Module;
  } });
  var index_29 = require_never2();
  Object.defineProperty(exports, "Never", { enumerable: true, get: function() {
    return index_29.Never;
  } });
  var index_30 = require_not2();
  Object.defineProperty(exports, "Not", { enumerable: true, get: function() {
    return index_30.Not;
  } });
  var index_31 = require_null2();
  Object.defineProperty(exports, "Null", { enumerable: true, get: function() {
    return index_31.Null;
  } });
  var index_32 = require_number2();
  Object.defineProperty(exports, "Number", { enumerable: true, get: function() {
    return index_32.Number;
  } });
  var index_33 = require_object2();
  Object.defineProperty(exports, "Object", { enumerable: true, get: function() {
    return index_33.Object;
  } });
  var index_34 = require_omit2();
  Object.defineProperty(exports, "Omit", { enumerable: true, get: function() {
    return index_34.Omit;
  } });
  var index_35 = require_optional2();
  Object.defineProperty(exports, "Optional", { enumerable: true, get: function() {
    return index_35.Optional;
  } });
  var index_36 = require_parameters2();
  Object.defineProperty(exports, "Parameters", { enumerable: true, get: function() {
    return index_36.Parameters;
  } });
  var index_37 = require_partial2();
  Object.defineProperty(exports, "Partial", { enumerable: true, get: function() {
    return index_37.Partial;
  } });
  var index_38 = require_pick2();
  Object.defineProperty(exports, "Pick", { enumerable: true, get: function() {
    return index_38.Pick;
  } });
  var index_39 = require_promise2();
  Object.defineProperty(exports, "Promise", { enumerable: true, get: function() {
    return index_39.Promise;
  } });
  var index_40 = require_readonly2();
  Object.defineProperty(exports, "Readonly", { enumerable: true, get: function() {
    return index_40.Readonly;
  } });
  var index_41 = require_readonly_optional2();
  Object.defineProperty(exports, "ReadonlyOptional", { enumerable: true, get: function() {
    return index_41.ReadonlyOptional;
  } });
  var index_42 = require_record2();
  Object.defineProperty(exports, "Record", { enumerable: true, get: function() {
    return index_42.Record;
  } });
  var index_43 = require_recursive2();
  Object.defineProperty(exports, "Recursive", { enumerable: true, get: function() {
    return index_43.Recursive;
  } });
  var index_44 = require_ref2();
  Object.defineProperty(exports, "Ref", { enumerable: true, get: function() {
    return index_44.Ref;
  } });
  var index_45 = require_regexp2();
  Object.defineProperty(exports, "RegExp", { enumerable: true, get: function() {
    return index_45.RegExp;
  } });
  var index_46 = require_required2();
  Object.defineProperty(exports, "Required", { enumerable: true, get: function() {
    return index_46.Required;
  } });
  var index_47 = require_rest2();
  Object.defineProperty(exports, "Rest", { enumerable: true, get: function() {
    return index_47.Rest;
  } });
  var index_48 = require_return_type2();
  Object.defineProperty(exports, "ReturnType", { enumerable: true, get: function() {
    return index_48.ReturnType;
  } });
  var index_49 = require_string2();
  Object.defineProperty(exports, "String", { enumerable: true, get: function() {
    return index_49.String;
  } });
  var index_50 = require_symbol2();
  Object.defineProperty(exports, "Symbol", { enumerable: true, get: function() {
    return index_50.Symbol;
  } });
  var index_51 = require_template_literal2();
  Object.defineProperty(exports, "TemplateLiteral", { enumerable: true, get: function() {
    return index_51.TemplateLiteral;
  } });
  var index_52 = require_transform2();
  Object.defineProperty(exports, "Transform", { enumerable: true, get: function() {
    return index_52.Transform;
  } });
  var index_53 = require_tuple2();
  Object.defineProperty(exports, "Tuple", { enumerable: true, get: function() {
    return index_53.Tuple;
  } });
  var index_54 = require_uint8array2();
  Object.defineProperty(exports, "Uint8Array", { enumerable: true, get: function() {
    return index_54.Uint8Array;
  } });
  var index_55 = require_undefined2();
  Object.defineProperty(exports, "Undefined", { enumerable: true, get: function() {
    return index_55.Undefined;
  } });
  var index_56 = require_union2();
  Object.defineProperty(exports, "Union", { enumerable: true, get: function() {
    return index_56.Union;
  } });
  var index_57 = require_unknown2();
  Object.defineProperty(exports, "Unknown", { enumerable: true, get: function() {
    return index_57.Unknown;
  } });
  var index_58 = require_unsafe2();
  Object.defineProperty(exports, "Unsafe", { enumerable: true, get: function() {
    return index_58.Unsafe;
  } });
  var index_59 = require_void2();
  Object.defineProperty(exports, "Void", { enumerable: true, get: function() {
    return index_59.Void;
  } });
});

// node_modules/@sinclair/typebox/build/cjs/type/type/javascript.js
var require_javascript = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JavaScriptTypeBuilder = undefined;
  var json_1 = require_json();
  var index_1 = require_argument2();
  var index_2 = require_async_iterator2();
  var index_3 = require_awaited2();
  var index_4 = require_bigint2();
  var index_5 = require_constructor2();
  var index_6 = require_constructor_parameters2();
  var index_7 = require_date2();
  var index_8 = require_function2();
  var index_9 = require_instance_type2();
  var index_10 = require_instantiate2();
  var index_11 = require_iterator2();
  var index_12 = require_parameters2();
  var index_13 = require_promise2();
  var index_14 = require_regexp2();
  var index_15 = require_return_type2();
  var index_16 = require_symbol2();
  var index_17 = require_uint8array2();
  var index_18 = require_undefined2();
  var index_19 = require_void2();

  class JavaScriptTypeBuilder extends json_1.JsonTypeBuilder {
    Argument(index) {
      return (0, index_1.Argument)(index);
    }
    AsyncIterator(items, options) {
      return (0, index_2.AsyncIterator)(items, options);
    }
    Awaited(schema, options) {
      return (0, index_3.Awaited)(schema, options);
    }
    BigInt(options) {
      return (0, index_4.BigInt)(options);
    }
    ConstructorParameters(schema, options) {
      return (0, index_6.ConstructorParameters)(schema, options);
    }
    Constructor(parameters, instanceType, options) {
      return (0, index_5.Constructor)(parameters, instanceType, options);
    }
    Date(options = {}) {
      return (0, index_7.Date)(options);
    }
    Function(parameters, returnType, options) {
      return (0, index_8.Function)(parameters, returnType, options);
    }
    InstanceType(schema, options) {
      return (0, index_9.InstanceType)(schema, options);
    }
    Instantiate(schema, parameters) {
      return (0, index_10.Instantiate)(schema, parameters);
    }
    Iterator(items, options) {
      return (0, index_11.Iterator)(items, options);
    }
    Parameters(schema, options) {
      return (0, index_12.Parameters)(schema, options);
    }
    Promise(item, options) {
      return (0, index_13.Promise)(item, options);
    }
    RegExp(unresolved, options) {
      return (0, index_14.RegExp)(unresolved, options);
    }
    ReturnType(type2, options) {
      return (0, index_15.ReturnType)(type2, options);
    }
    Symbol(options) {
      return (0, index_16.Symbol)(options);
    }
    Undefined(options) {
      return (0, index_18.Undefined)(options);
    }
    Uint8Array(options) {
      return (0, index_17.Uint8Array)(options);
    }
    Void(options) {
      return (0, index_19.Void)(options);
    }
  }
  exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
});

// node_modules/@sinclair/typebox/build/cjs/type/type/index.js
var require_type6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Type = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = undefined;
  var json_1 = require_json();
  Object.defineProperty(exports, "JsonTypeBuilder", { enumerable: true, get: function() {
    return json_1.JsonTypeBuilder;
  } });
  var TypeBuilder = require_type5();
  var javascript_1 = require_javascript();
  Object.defineProperty(exports, "JavaScriptTypeBuilder", { enumerable: true, get: function() {
    return javascript_1.JavaScriptTypeBuilder;
  } });
  var Type2 = TypeBuilder;
  exports.Type = Type2;
});

// node_modules/@sinclair/typebox/build/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clone2(), exports);
  __exportStar(require_create(), exports);
  __exportStar(require_error2(), exports);
  __exportStar(require_guard3(), exports);
  __exportStar(require_helpers2(), exports);
  __exportStar(require_patterns2(), exports);
  __exportStar(require_registry(), exports);
  __exportStar(require_sets(), exports);
  __exportStar(require_symbols2(), exports);
  __exportStar(require_any2(), exports);
  __exportStar(require_array2(), exports);
  __exportStar(require_argument2(), exports);
  __exportStar(require_async_iterator2(), exports);
  __exportStar(require_awaited2(), exports);
  __exportStar(require_bigint2(), exports);
  __exportStar(require_boolean2(), exports);
  __exportStar(require_composite2(), exports);
  __exportStar(require_const2(), exports);
  __exportStar(require_constructor2(), exports);
  __exportStar(require_constructor_parameters2(), exports);
  __exportStar(require_date2(), exports);
  __exportStar(require_enum2(), exports);
  __exportStar(require_exclude2(), exports);
  __exportStar(require_extends2(), exports);
  __exportStar(require_extract2(), exports);
  __exportStar(require_function2(), exports);
  __exportStar(require_indexed2(), exports);
  __exportStar(require_instance_type2(), exports);
  __exportStar(require_instantiate2(), exports);
  __exportStar(require_integer2(), exports);
  __exportStar(require_intersect2(), exports);
  __exportStar(require_iterator2(), exports);
  __exportStar(require_intrinsic2(), exports);
  __exportStar(require_keyof2(), exports);
  __exportStar(require_literal2(), exports);
  __exportStar(require_module2(), exports);
  __exportStar(require_mapped2(), exports);
  __exportStar(require_never2(), exports);
  __exportStar(require_not2(), exports);
  __exportStar(require_null2(), exports);
  __exportStar(require_number2(), exports);
  __exportStar(require_object2(), exports);
  __exportStar(require_omit2(), exports);
  __exportStar(require_optional2(), exports);
  __exportStar(require_parameters2(), exports);
  __exportStar(require_partial2(), exports);
  __exportStar(require_pick2(), exports);
  __exportStar(require_promise2(), exports);
  __exportStar(require_readonly2(), exports);
  __exportStar(require_readonly_optional2(), exports);
  __exportStar(require_record2(), exports);
  __exportStar(require_recursive2(), exports);
  __exportStar(require_ref2(), exports);
  __exportStar(require_regexp2(), exports);
  __exportStar(require_required2(), exports);
  __exportStar(require_rest2(), exports);
  __exportStar(require_return_type2(), exports);
  __exportStar(require_schema2(), exports);
  __exportStar(require_static2(), exports);
  __exportStar(require_string2(), exports);
  __exportStar(require_symbol2(), exports);
  __exportStar(require_template_literal2(), exports);
  __exportStar(require_transform2(), exports);
  __exportStar(require_tuple2(), exports);
  __exportStar(require_uint8array2(), exports);
  __exportStar(require_undefined2(), exports);
  __exportStar(require_union2(), exports);
  __exportStar(require_unknown2(), exports);
  __exportStar(require_unsafe2(), exports);
  __exportStar(require_void2(), exports);
  __exportStar(require_type6(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/system/system.js
var require_system = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = undefined;
  var index_1 = require_registry();
  var index_2 = require_unsafe2();
  var index_3 = require_symbols2();
  var index_4 = require_error2();

  class TypeSystemDuplicateTypeKind2 extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind2;

  class TypeSystemDuplicateFormat2 extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat2;
  var TypeSystem2;
  (function(TypeSystem3) {
    function Type2(kind, check2) {
      if (index_1.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind2(kind);
      index_1.TypeRegistry.Set(kind, check2);
      return (options = {}) => (0, index_2.Unsafe)({ ...options, [index_3.Kind]: kind });
    }
    TypeSystem3.Type = Type2;
    function Format2(format, check2) {
      if (index_1.FormatRegistry.Has(format))
        throw new TypeSystemDuplicateFormat2(format);
      index_1.FormatRegistry.Set(format, check2);
      return format;
    }
    TypeSystem3.Format = Format2;
  })(TypeSystem2 || (exports.TypeSystem = TypeSystem2 = {}));
});

// node_modules/@sinclair/typebox/build/cjs/system/index.js
var require_system2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_policy(), exports);
  __exportStar(require_system(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/errors/function.js
var require_function3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultErrorFunction = DefaultErrorFunction2;
  exports.SetErrorFunction = SetErrorFunction;
  exports.GetErrorFunction = GetErrorFunction2;
  var index_1 = require_symbols2();
  var errors_1 = require_errors();
  function DefaultErrorFunction2(error3) {
    switch (error3.errorType) {
      case errors_1.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_1.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${error3.schema.maxContains} matching values`;
      case errors_1.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${error3.schema.minContains} matching values`;
      case errors_1.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${error3.schema.maxItems}`;
      case errors_1.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${error3.schema.minItems}`;
      case errors_1.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_1.ValueErrorType.Array:
        return "Expected array";
      case errors_1.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_1.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${error3.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${error3.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${error3.schema.maximum}`;
      case errors_1.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${error3.schema.minimum}`;
      case errors_1.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${error3.schema.multipleOf}`;
      case errors_1.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_1.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${error3.schema.exclusiveMinimumTimestamp}`;
      case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${error3.schema.exclusiveMaximumTimestamp}`;
      case errors_1.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${error3.schema.minimumTimestamp}`;
      case errors_1.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${error3.schema.maximumTimestamp}`;
      case errors_1.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${error3.schema.multipleOfTimestamp}`;
      case errors_1.ValueErrorType.Date:
        return "Expected Date";
      case errors_1.ValueErrorType.Function:
        return "Expected function";
      case errors_1.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${error3.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${error3.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${error3.schema.maximum}`;
      case errors_1.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${error3.schema.minimum}`;
      case errors_1.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${error3.schema.multipleOf}`;
      case errors_1.ValueErrorType.Integer:
        return "Expected integer";
      case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_1.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_1.ValueErrorType.Literal:
        return `Expected ${typeof error3.schema.const === "string" ? `'${error3.schema.const}'` : error3.schema.const}`;
      case errors_1.ValueErrorType.Never:
        return "Never";
      case errors_1.ValueErrorType.Not:
        return "Value should not match";
      case errors_1.ValueErrorType.Null:
        return "Expected null";
      case errors_1.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${error3.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${error3.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${error3.schema.maximum}`;
      case errors_1.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${error3.schema.minimum}`;
      case errors_1.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${error3.schema.multipleOf}`;
      case errors_1.ValueErrorType.Number:
        return "Expected number";
      case errors_1.ValueErrorType.Object:
        return "Expected object";
      case errors_1.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${error3.schema.maxProperties} properties`;
      case errors_1.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${error3.schema.minProperties} properties`;
      case errors_1.ValueErrorType.ObjectRequiredProperty:
        return "Expected required property";
      case errors_1.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_1.ValueErrorType.RegExp:
        return "Expected string to match regular expression";
      case errors_1.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${error3.schema.format}'`;
      case errors_1.ValueErrorType.StringFormat:
        return `Expected string to match '${error3.schema.format}' format`;
      case errors_1.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${error3.schema.maxLength}`;
      case errors_1.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${error3.schema.minLength}`;
      case errors_1.ValueErrorType.StringPattern:
        return `Expected string to match '${error3.schema.pattern}'`;
      case errors_1.ValueErrorType.String:
        return "Expected string";
      case errors_1.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_1.ValueErrorType.TupleLength:
        return `Expected tuple to have ${error3.schema.maxItems || 0} elements`;
      case errors_1.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${error3.schema.maxByteLength}`;
      case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${error3.schema.minByteLength}`;
      case errors_1.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_1.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_1.ValueErrorType.Union:
        return "Expected union value";
      case errors_1.ValueErrorType.Void:
        return "Expected void";
      case errors_1.ValueErrorType.Kind:
        return `Expected kind '${error3.schema[index_1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  }
  var errorFunction2 = DefaultErrorFunction2;
  function SetErrorFunction(callback) {
    errorFunction2 = callback;
  }
  function GetErrorFunction2() {
    return errorFunction2;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/deref.js
var require_deref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeDereferenceError = undefined;
  exports.Pushref = Pushref2;
  exports.Deref = Deref2;
  var index_1 = require_error2();
  var index_2 = require_symbols2();
  var guard_1 = require_guard();

  class TypeDereferenceError2 extends index_1.TypeBoxError {
    constructor(schema) {
      super(`Unable to dereference schema with $id '${schema.$ref}'`);
      this.schema = schema;
    }
  }
  exports.TypeDereferenceError = TypeDereferenceError2;
  function Resolve2(schema, references) {
    const target = references.find((target2) => target2.$id === schema.$ref);
    if (target === undefined)
      throw new TypeDereferenceError2(schema);
    return Deref2(target, references);
  }
  function Pushref2(schema, references) {
    if (!(0, guard_1.IsString)(schema.$id) || references.some((target) => target.$id === schema.$id))
      return references;
    references.push(schema);
    return references;
  }
  function Deref2(schema, references) {
    return schema[index_2.Kind] === "This" || schema[index_2.Kind] === "Ref" ? Resolve2(schema, references) : schema;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/index.js
var require_deref2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_deref(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/hash.js
var require_hash = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueHashError = undefined;
  exports.Hash = Hash2;
  var index_1 = require_guard2();
  var index_2 = require_error2();

  class ValueHashError2 extends index_2.TypeBoxError {
    constructor(value) {
      super(`Unable to hash value`);
      this.value = value;
    }
  }
  exports.ValueHashError = ValueHashError2;
  var ByteMarker2;
  (function(ByteMarker3) {
    ByteMarker3[ByteMarker3["Undefined"] = 0] = "Undefined";
    ByteMarker3[ByteMarker3["Null"] = 1] = "Null";
    ByteMarker3[ByteMarker3["Boolean"] = 2] = "Boolean";
    ByteMarker3[ByteMarker3["Number"] = 3] = "Number";
    ByteMarker3[ByteMarker3["String"] = 4] = "String";
    ByteMarker3[ByteMarker3["Object"] = 5] = "Object";
    ByteMarker3[ByteMarker3["Array"] = 6] = "Array";
    ByteMarker3[ByteMarker3["Date"] = 7] = "Date";
    ByteMarker3[ByteMarker3["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker3[ByteMarker3["Symbol"] = 9] = "Symbol";
    ByteMarker3[ByteMarker3["BigInt"] = 10] = "BigInt";
  })(ByteMarker2 || (ByteMarker2 = {}));
  var Accumulator2 = BigInt("14695981039346656037");
  var [Prime2, Size2] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
  var Bytes2 = Array.from({ length: 256 }).map((_, i) => BigInt(i));
  var F642 = new Float64Array(1);
  var F64In2 = new DataView(F642.buffer);
  var F64Out2 = new Uint8Array(F642.buffer);
  function* NumberToBytes2(value) {
    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
    for (let i = 0;i < byteCount; i++) {
      yield value >> 8 * (byteCount - 1 - i) & 255;
    }
  }
  function ArrayType6(value) {
    FNV1A642(ByteMarker2.Array);
    for (const item of value) {
      Visit17(item);
    }
  }
  function BooleanType2(value) {
    FNV1A642(ByteMarker2.Boolean);
    FNV1A642(value ? 1 : 0);
  }
  function BigIntType2(value) {
    FNV1A642(ByteMarker2.BigInt);
    F64In2.setBigInt64(0, value);
    for (const byte2 of F64Out2) {
      FNV1A642(byte2);
    }
  }
  function DateType4(value) {
    FNV1A642(ByteMarker2.Date);
    Visit17(value.getTime());
  }
  function NullType2(value) {
    FNV1A642(ByteMarker2.Null);
  }
  function NumberType2(value) {
    FNV1A642(ByteMarker2.Number);
    F64In2.setFloat64(0, value);
    for (const byte2 of F64Out2) {
      FNV1A642(byte2);
    }
  }
  function ObjectType6(value) {
    FNV1A642(ByteMarker2.Object);
    for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
      Visit17(key);
      Visit17(value[key]);
    }
  }
  function StringType2(value) {
    FNV1A642(ByteMarker2.String);
    for (let i = 0;i < value.length; i++) {
      for (const byte2 of NumberToBytes2(value.charCodeAt(i))) {
        FNV1A642(byte2);
      }
    }
  }
  function SymbolType2(value) {
    FNV1A642(ByteMarker2.Symbol);
    Visit17(value.description);
  }
  function Uint8ArrayType3(value) {
    FNV1A642(ByteMarker2.Uint8Array);
    for (let i = 0;i < value.length; i++) {
      FNV1A642(value[i]);
    }
  }
  function UndefinedType2(value) {
    return FNV1A642(ByteMarker2.Undefined);
  }
  function Visit17(value) {
    if ((0, index_1.IsArray)(value))
      return ArrayType6(value);
    if ((0, index_1.IsBoolean)(value))
      return BooleanType2(value);
    if ((0, index_1.IsBigInt)(value))
      return BigIntType2(value);
    if ((0, index_1.IsDate)(value))
      return DateType4(value);
    if ((0, index_1.IsNull)(value))
      return NullType2(value);
    if ((0, index_1.IsNumber)(value))
      return NumberType2(value);
    if ((0, index_1.IsObject)(value))
      return ObjectType6(value);
    if ((0, index_1.IsString)(value))
      return StringType2(value);
    if ((0, index_1.IsSymbol)(value))
      return SymbolType2(value);
    if ((0, index_1.IsUint8Array)(value))
      return Uint8ArrayType3(value);
    if ((0, index_1.IsUndefined)(value))
      return UndefinedType2(value);
    throw new ValueHashError2(value);
  }
  function FNV1A642(byte2) {
    Accumulator2 = Accumulator2 ^ Bytes2[byte2];
    Accumulator2 = Accumulator2 * Prime2 % Size2;
  }
  function Hash2(value) {
    Accumulator2 = BigInt("14695981039346656037");
    Visit17(value);
    return Accumulator2;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/index.js
var require_hash2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_hash(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/check/check.js
var require_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueCheckUnknownTypeError = undefined;
  exports.Check = Check2;
  var index_1 = require_system2();
  var index_2 = require_deref2();
  var index_3 = require_hash2();
  var index_4 = require_symbols2();
  var index_5 = require_keyof2();
  var index_6 = require_extends2();
  var index_7 = require_registry();
  var index_8 = require_error2();
  var index_9 = require_never2();
  var index_10 = require_guard2();
  var kind_1 = require_kind();

  class ValueCheckUnknownTypeError2 extends index_8.TypeBoxError {
    constructor(schema) {
      super(`Unknown type`);
      this.schema = schema;
    }
  }
  exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError2;
  function IsAnyOrUnknown2(schema) {
    return schema[index_4.Kind] === "Any" || schema[index_4.Kind] === "Unknown";
  }
  function IsDefined3(value) {
    return value !== undefined;
  }
  function FromAny5(schema, references, value) {
    return true;
  }
  function FromArgument5(schema, references, value) {
    return true;
  }
  function FromArray18(schema, references, value) {
    if (!(0, index_10.IsArray)(value))
      return false;
    if (IsDefined3(schema.minItems) && !(value.length >= schema.minItems)) {
      return false;
    }
    if (IsDefined3(schema.maxItems) && !(value.length <= schema.maxItems)) {
      return false;
    }
    if (!value.every((value2) => Visit17(schema.items, references, value2))) {
      return false;
    }
    if (schema.uniqueItems === true && !function() {
      const set2 = new Set;
      for (const element of value) {
        const hashed = (0, index_3.Hash)(element);
        if (set2.has(hashed)) {
          return false;
        } else {
          set2.add(hashed);
        }
      }
      return true;
    }()) {
      return false;
    }
    if (!(IsDefined3(schema.contains) || (0, index_10.IsNumber)(schema.minContains) || (0, index_10.IsNumber)(schema.maxContains))) {
      return true;
    }
    const containsSchema = IsDefined3(schema.contains) ? schema.contains : (0, index_9.Never)();
    const containsCount = value.reduce((acc, value2) => Visit17(containsSchema, references, value2) ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      return false;
    }
    return true;
  }
  function FromAsyncIterator8(schema, references, value) {
    return (0, index_10.IsAsyncIterator)(value);
  }
  function FromBigInt6(schema, references, value) {
    if (!(0, index_10.IsBigInt)(value))
      return false;
    if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      return false;
    }
    return true;
  }
  function FromBoolean6(schema, references, value) {
    return (0, index_10.IsBoolean)(value);
  }
  function FromConstructor9(schema, references, value) {
    return Visit17(schema.returns, references, value.prototype);
  }
  function FromDate8(schema, references, value) {
    if (!(0, index_10.IsDate)(value))
      return false;
    if (IsDefined3(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      return false;
    }
    if (IsDefined3(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      return false;
    }
    if (IsDefined3(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      return false;
    }
    if (IsDefined3(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      return false;
    }
    if (IsDefined3(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      return false;
    }
    return true;
  }
  function FromFunction8(schema, references, value) {
    return (0, index_10.IsFunction)(value);
  }
  function FromImport11(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit17(target, [...references, ...definitions], value);
  }
  function FromInteger6(schema, references, value) {
    if (!(0, index_10.IsInteger)(value)) {
      return false;
    }
    if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromIntersect19(schema, references, value) {
    const check1 = schema.allOf.every((schema2) => Visit17(schema2, references, value));
    if (schema.unevaluatedProperties === false) {
      const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
      return check1 && check2;
    } else if ((0, kind_1.IsSchema)(schema.unevaluatedProperties)) {
      const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit17(schema.unevaluatedProperties, references, value[key]));
      return check1 && check2;
    } else {
      return check1;
    }
  }
  function FromIterator8(schema, references, value) {
    return (0, index_10.IsIterator)(value);
  }
  function FromLiteral7(schema, references, value) {
    return value === schema.const;
  }
  function FromNever6(schema, references, value) {
    return false;
  }
  function FromNot8(schema, references, value) {
    return !Visit17(schema.not, references, value);
  }
  function FromNull6(schema, references, value) {
    return (0, index_10.IsNull)(value);
  }
  function FromNumber6(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return false;
    if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromObject19(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return false;
    if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        if (!Visit17(property, references, value[knownKey])) {
          return false;
        }
        if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown2(property)) && !(knownKey in value)) {
          return false;
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit17(property, references, value[knownKey])) {
          return false;
        }
      }
    }
    if (schema.additionalProperties === false) {
      const valueKeys = Object.getOwnPropertyNames(value);
      if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
        return true;
      } else {
        return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
      }
    } else if (typeof schema.additionalProperties === "object") {
      const valueKeys = Object.getOwnPropertyNames(value);
      return valueKeys.every((key) => knownKeys.includes(key) || Visit17(schema.additionalProperties, references, value[key]));
    } else {
      return true;
    }
  }
  function FromPromise8(schema, references, value) {
    return (0, index_10.IsPromise)(value);
  }
  function FromRecord14(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
      return false;
    }
    if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex2 = new RegExp(patternKey);
    const check1 = Object.entries(value).every(([key, value2]) => {
      return regex2.test(key) ? Visit17(patternSchema, references, value2) : true;
    });
    const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
      return !regex2.test(key) ? Visit17(schema.additionalProperties, references, value2) : true;
    }) : true;
    const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
      return regex2.test(key);
    }) : true;
    return check1 && check2 && check3;
  }
  function FromRef15(schema, references, value) {
    return Visit17((0, index_2.Deref)(schema, references), references, value);
  }
  function FromRegExp5(schema, references, value) {
    const regex2 = new RegExp(schema.source, schema.flags);
    if (IsDefined3(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined3(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    return regex2.test(value);
  }
  function FromString6(schema, references, value) {
    if (!(0, index_10.IsString)(value)) {
      return false;
    }
    if (IsDefined3(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined3(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    if (IsDefined3(schema.pattern)) {
      const regex2 = new RegExp(schema.pattern);
      if (!regex2.test(value))
        return false;
    }
    if (IsDefined3(schema.format)) {
      if (!index_7.FormatRegistry.Has(schema.format))
        return false;
      const func = index_7.FormatRegistry.Get(schema.format);
      return func(value);
    }
    return true;
  }
  function FromSymbol6(schema, references, value) {
    return (0, index_10.IsSymbol)(value);
  }
  function FromTemplateLiteral7(schema, references, value) {
    return (0, index_10.IsString)(value) && new RegExp(schema.pattern).test(value);
  }
  function FromThis11(schema, references, value) {
    return Visit17((0, index_2.Deref)(schema, references), references, value);
  }
  function FromTuple16(schema, references, value) {
    if (!(0, index_10.IsArray)(value)) {
      return false;
    }
    if (schema.items === undefined && !(value.length === 0)) {
      return false;
    }
    if (!(value.length === schema.maxItems)) {
      return false;
    }
    if (!schema.items) {
      return true;
    }
    for (let i = 0;i < schema.items.length; i++) {
      if (!Visit17(schema.items[i], references, value[i]))
        return false;
    }
    return true;
  }
  function FromUndefined6(schema, references, value) {
    return (0, index_10.IsUndefined)(value);
  }
  function FromUnion21(schema, references, value) {
    return schema.anyOf.some((inner) => Visit17(inner, references, value));
  }
  function FromUint8Array5(schema, references, value) {
    if (!(0, index_10.IsUint8Array)(value)) {
      return false;
    }
    if (IsDefined3(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      return false;
    }
    if (IsDefined3(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      return false;
    }
    return true;
  }
  function FromUnknown5(schema, references, value) {
    return true;
  }
  function FromVoid5(schema, references, value) {
    return index_1.TypeSystemPolicy.IsVoidLike(value);
  }
  function FromKind4(schema, references, value) {
    if (!index_7.TypeRegistry.Has(schema[index_4.Kind]))
      return false;
    const func = index_7.TypeRegistry.Get(schema[index_4.Kind]);
    return func(schema, value);
  }
  function Visit17(schema, references, value) {
    const references_ = IsDefined3(schema.$id) ? (0, index_2.Pushref)(schema, references) : references;
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
      case "Any":
        return FromAny5(schema_, references_, value);
      case "Argument":
        return FromArgument5(schema_, references_, value);
      case "Array":
        return FromArray18(schema_, references_, value);
      case "AsyncIterator":
        return FromAsyncIterator8(schema_, references_, value);
      case "BigInt":
        return FromBigInt6(schema_, references_, value);
      case "Boolean":
        return FromBoolean6(schema_, references_, value);
      case "Constructor":
        return FromConstructor9(schema_, references_, value);
      case "Date":
        return FromDate8(schema_, references_, value);
      case "Function":
        return FromFunction8(schema_, references_, value);
      case "Import":
        return FromImport11(schema_, references_, value);
      case "Integer":
        return FromInteger6(schema_, references_, value);
      case "Intersect":
        return FromIntersect19(schema_, references_, value);
      case "Iterator":
        return FromIterator8(schema_, references_, value);
      case "Literal":
        return FromLiteral7(schema_, references_, value);
      case "Never":
        return FromNever6(schema_, references_, value);
      case "Not":
        return FromNot8(schema_, references_, value);
      case "Null":
        return FromNull6(schema_, references_, value);
      case "Number":
        return FromNumber6(schema_, references_, value);
      case "Object":
        return FromObject19(schema_, references_, value);
      case "Promise":
        return FromPromise8(schema_, references_, value);
      case "Record":
        return FromRecord14(schema_, references_, value);
      case "Ref":
        return FromRef15(schema_, references_, value);
      case "RegExp":
        return FromRegExp5(schema_, references_, value);
      case "String":
        return FromString6(schema_, references_, value);
      case "Symbol":
        return FromSymbol6(schema_, references_, value);
      case "TemplateLiteral":
        return FromTemplateLiteral7(schema_, references_, value);
      case "This":
        return FromThis11(schema_, references_, value);
      case "Tuple":
        return FromTuple16(schema_, references_, value);
      case "Undefined":
        return FromUndefined6(schema_, references_, value);
      case "Union":
        return FromUnion21(schema_, references_, value);
      case "Uint8Array":
        return FromUint8Array5(schema_, references_, value);
      case "Unknown":
        return FromUnknown5(schema_, references_, value);
      case "Void":
        return FromVoid5(schema_, references_, value);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_4.Kind]))
          throw new ValueCheckUnknownTypeError2(schema_);
        return FromKind4(schema_, references_, value);
    }
  }
  function Check2(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/check/index.js
var require_check2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_check(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/errors/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = undefined;
  exports.Errors = Errors2;
  var index_1 = require_system2();
  var index_2 = require_keyof2();
  var index_3 = require_registry();
  var extends_undefined_1 = require_extends_undefined();
  var function_1 = require_function3();
  var index_4 = require_error2();
  var index_5 = require_deref2();
  var index_6 = require_hash2();
  var index_7 = require_check2();
  var index_8 = require_symbols2();
  var index_9 = require_never2();
  var index_10 = require_guard2();
  var ValueErrorType2;
  (function(ValueErrorType3) {
    ValueErrorType3[ValueErrorType3["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType3[ValueErrorType3["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType3[ValueErrorType3["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType3[ValueErrorType3["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType3[ValueErrorType3["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType3[ValueErrorType3["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType3[ValueErrorType3["Array"] = 6] = "Array";
    ValueErrorType3[ValueErrorType3["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType3[ValueErrorType3["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType3[ValueErrorType3["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType3[ValueErrorType3["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType3[ValueErrorType3["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType3[ValueErrorType3["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType3[ValueErrorType3["BigInt"] = 13] = "BigInt";
    ValueErrorType3[ValueErrorType3["Boolean"] = 14] = "Boolean";
    ValueErrorType3[ValueErrorType3["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType3[ValueErrorType3["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType3[ValueErrorType3["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType3[ValueErrorType3["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType3[ValueErrorType3["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType3[ValueErrorType3["Date"] = 20] = "Date";
    ValueErrorType3[ValueErrorType3["Function"] = 21] = "Function";
    ValueErrorType3[ValueErrorType3["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType3[ValueErrorType3["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType3[ValueErrorType3["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType3[ValueErrorType3["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType3[ValueErrorType3["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType3[ValueErrorType3["Integer"] = 27] = "Integer";
    ValueErrorType3[ValueErrorType3["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType3[ValueErrorType3["Intersect"] = 29] = "Intersect";
    ValueErrorType3[ValueErrorType3["Iterator"] = 30] = "Iterator";
    ValueErrorType3[ValueErrorType3["Kind"] = 31] = "Kind";
    ValueErrorType3[ValueErrorType3["Literal"] = 32] = "Literal";
    ValueErrorType3[ValueErrorType3["Never"] = 33] = "Never";
    ValueErrorType3[ValueErrorType3["Not"] = 34] = "Not";
    ValueErrorType3[ValueErrorType3["Null"] = 35] = "Null";
    ValueErrorType3[ValueErrorType3["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType3[ValueErrorType3["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType3[ValueErrorType3["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType3[ValueErrorType3["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType3[ValueErrorType3["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType3[ValueErrorType3["Number"] = 41] = "Number";
    ValueErrorType3[ValueErrorType3["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType3[ValueErrorType3["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType3[ValueErrorType3["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType3[ValueErrorType3["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType3[ValueErrorType3["Object"] = 46] = "Object";
    ValueErrorType3[ValueErrorType3["Promise"] = 47] = "Promise";
    ValueErrorType3[ValueErrorType3["RegExp"] = 48] = "RegExp";
    ValueErrorType3[ValueErrorType3["StringFormatUnknown"] = 49] = "StringFormatUnknown";
    ValueErrorType3[ValueErrorType3["StringFormat"] = 50] = "StringFormat";
    ValueErrorType3[ValueErrorType3["StringMaxLength"] = 51] = "StringMaxLength";
    ValueErrorType3[ValueErrorType3["StringMinLength"] = 52] = "StringMinLength";
    ValueErrorType3[ValueErrorType3["StringPattern"] = 53] = "StringPattern";
    ValueErrorType3[ValueErrorType3["String"] = 54] = "String";
    ValueErrorType3[ValueErrorType3["Symbol"] = 55] = "Symbol";
    ValueErrorType3[ValueErrorType3["TupleLength"] = 56] = "TupleLength";
    ValueErrorType3[ValueErrorType3["Tuple"] = 57] = "Tuple";
    ValueErrorType3[ValueErrorType3["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
    ValueErrorType3[ValueErrorType3["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
    ValueErrorType3[ValueErrorType3["Uint8Array"] = 60] = "Uint8Array";
    ValueErrorType3[ValueErrorType3["Undefined"] = 61] = "Undefined";
    ValueErrorType3[ValueErrorType3["Union"] = 62] = "Union";
    ValueErrorType3[ValueErrorType3["Void"] = 63] = "Void";
  })(ValueErrorType2 || (exports.ValueErrorType = ValueErrorType2 = {}));

  class ValueErrorsUnknownTypeError2 extends index_4.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError2;
  function EscapeKey2(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function IsDefined3(value) {
    return value !== undefined;
  }

  class ValueErrorIterator2 {
    constructor(iterator) {
      this.iterator = iterator;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const next2 = this.iterator.next();
      return next2.done ? undefined : next2.value;
    }
  }
  exports.ValueErrorIterator = ValueErrorIterator2;
  function Create3(errorType, schema, path, value, errors = []) {
    return {
      type: errorType,
      schema,
      path,
      value,
      message: (0, function_1.GetErrorFunction)()({ errorType, path, schema, value, errors }),
      errors
    };
  }
  function* FromAny5(schema, references, path, value) {}
  function* FromArgument5(schema, references, path, value) {}
  function* FromArray18(schema, references, path, value) {
    if (!(0, index_10.IsArray)(value)) {
      return yield Create3(ValueErrorType2.Array, schema, path, value);
    }
    if (IsDefined3(schema.minItems) && !(value.length >= schema.minItems)) {
      yield Create3(ValueErrorType2.ArrayMinItems, schema, path, value);
    }
    if (IsDefined3(schema.maxItems) && !(value.length <= schema.maxItems)) {
      yield Create3(ValueErrorType2.ArrayMaxItems, schema, path, value);
    }
    for (let i = 0;i < value.length; i++) {
      yield* Visit17(schema.items, references, `${path}/${i}`, value[i]);
    }
    if (schema.uniqueItems === true && !function() {
      const set2 = new Set;
      for (const element of value) {
        const hashed = (0, index_6.Hash)(element);
        if (set2.has(hashed)) {
          return false;
        } else {
          set2.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create3(ValueErrorType2.ArrayUniqueItems, schema, path, value);
    }
    if (!(IsDefined3(schema.contains) || IsDefined3(schema.minContains) || IsDefined3(schema.maxContains))) {
      return;
    }
    const containsSchema = IsDefined3(schema.contains) ? schema.contains : (0, index_9.Never)();
    const containsCount = value.reduce((acc, value2, index) => Visit17(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create3(ValueErrorType2.ArrayContains, schema, path, value);
    }
    if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      yield Create3(ValueErrorType2.ArrayMinContains, schema, path, value);
    }
    if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      yield Create3(ValueErrorType2.ArrayMaxContains, schema, path, value);
    }
  }
  function* FromAsyncIterator8(schema, references, path, value) {
    if (!(0, index_10.IsAsyncIterator)(value))
      yield Create3(ValueErrorType2.AsyncIterator, schema, path, value);
  }
  function* FromBigInt6(schema, references, path, value) {
    if (!(0, index_10.IsBigInt)(value))
      return yield Create3(ValueErrorType2.BigInt, schema, path, value);
    if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create3(ValueErrorType2.BigIntExclusiveMaximum, schema, path, value);
    }
    if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create3(ValueErrorType2.BigIntExclusiveMinimum, schema, path, value);
    }
    if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
      yield Create3(ValueErrorType2.BigIntMaximum, schema, path, value);
    }
    if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
      yield Create3(ValueErrorType2.BigIntMinimum, schema, path, value);
    }
    if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      yield Create3(ValueErrorType2.BigIntMultipleOf, schema, path, value);
    }
  }
  function* FromBoolean6(schema, references, path, value) {
    if (!(0, index_10.IsBoolean)(value))
      yield Create3(ValueErrorType2.Boolean, schema, path, value);
  }
  function* FromConstructor9(schema, references, path, value) {
    yield* Visit17(schema.returns, references, path, value.prototype);
  }
  function* FromDate8(schema, references, path, value) {
    if (!(0, index_10.IsDate)(value))
      return yield Create3(ValueErrorType2.Date, schema, path, value);
    if (IsDefined3(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      yield Create3(ValueErrorType2.DateExclusiveMaximumTimestamp, schema, path, value);
    }
    if (IsDefined3(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      yield Create3(ValueErrorType2.DateExclusiveMinimumTimestamp, schema, path, value);
    }
    if (IsDefined3(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      yield Create3(ValueErrorType2.DateMaximumTimestamp, schema, path, value);
    }
    if (IsDefined3(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      yield Create3(ValueErrorType2.DateMinimumTimestamp, schema, path, value);
    }
    if (IsDefined3(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      yield Create3(ValueErrorType2.DateMultipleOfTimestamp, schema, path, value);
    }
  }
  function* FromFunction8(schema, references, path, value) {
    if (!(0, index_10.IsFunction)(value))
      yield Create3(ValueErrorType2.Function, schema, path, value);
  }
  function* FromImport11(schema, references, path, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    yield* Visit17(target, [...references, ...definitions], path, value);
  }
  function* FromInteger6(schema, references, path, value) {
    if (!(0, index_10.IsInteger)(value))
      return yield Create3(ValueErrorType2.Integer, schema, path, value);
    if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create3(ValueErrorType2.IntegerExclusiveMaximum, schema, path, value);
    }
    if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create3(ValueErrorType2.IntegerExclusiveMinimum, schema, path, value);
    }
    if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
      yield Create3(ValueErrorType2.IntegerMaximum, schema, path, value);
    }
    if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
      yield Create3(ValueErrorType2.IntegerMinimum, schema, path, value);
    }
    if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create3(ValueErrorType2.IntegerMultipleOf, schema, path, value);
    }
  }
  function* FromIntersect19(schema, references, path, value) {
    let hasError = false;
    for (const inner of schema.allOf) {
      for (const error3 of Visit17(inner, references, path, value)) {
        hasError = true;
        yield error3;
      }
    }
    if (hasError) {
      return yield Create3(ValueErrorType2.Intersect, schema, path, value);
    }
    if (schema.unevaluatedProperties === false) {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          yield Create3(ValueErrorType2.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
        }
      }
    }
    if (typeof schema.unevaluatedProperties === "object") {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          const next2 = Visit17(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
          if (!next2.done)
            yield next2.value;
        }
      }
    }
  }
  function* FromIterator8(schema, references, path, value) {
    if (!(0, index_10.IsIterator)(value))
      yield Create3(ValueErrorType2.Iterator, schema, path, value);
  }
  function* FromLiteral7(schema, references, path, value) {
    if (!(value === schema.const))
      yield Create3(ValueErrorType2.Literal, schema, path, value);
  }
  function* FromNever6(schema, references, path, value) {
    yield Create3(ValueErrorType2.Never, schema, path, value);
  }
  function* FromNot8(schema, references, path, value) {
    if (Visit17(schema.not, references, path, value).next().done === true)
      yield Create3(ValueErrorType2.Not, schema, path, value);
  }
  function* FromNull6(schema, references, path, value) {
    if (!(0, index_10.IsNull)(value))
      yield Create3(ValueErrorType2.Null, schema, path, value);
  }
  function* FromNumber6(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return yield Create3(ValueErrorType2.Number, schema, path, value);
    if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create3(ValueErrorType2.NumberExclusiveMaximum, schema, path, value);
    }
    if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create3(ValueErrorType2.NumberExclusiveMinimum, schema, path, value);
    }
    if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
      yield Create3(ValueErrorType2.NumberMaximum, schema, path, value);
    }
    if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
      yield Create3(ValueErrorType2.NumberMinimum, schema, path, value);
    }
    if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create3(ValueErrorType2.NumberMultipleOf, schema, path, value);
    }
  }
  function* FromObject19(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return yield Create3(ValueErrorType2.Object, schema, path, value);
    if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create3(ValueErrorType2.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create3(ValueErrorType2.ObjectMaxProperties, schema, path, value);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create3(ValueErrorType2.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey2(requiredKey)}`, undefined);
    }
    if (schema.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create3(ValueErrorType2.ObjectAdditionalProperties, schema, `${path}/${EscapeKey2(valueKey)}`, value[valueKey]);
        }
      }
    }
    if (typeof schema.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit17(schema.additionalProperties, references, `${path}/${EscapeKey2(valueKey)}`, value[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, `${path}/${EscapeKey2(knownKey)}`, value[knownKey]);
        if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {
          yield Create3(ValueErrorType2.ObjectRequiredProperty, property, `${path}/${EscapeKey2(knownKey)}`, undefined);
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
          yield* Visit17(property, references, `${path}/${EscapeKey2(knownKey)}`, value[knownKey]);
        }
      }
    }
  }
  function* FromPromise8(schema, references, path, value) {
    if (!(0, index_10.IsPromise)(value))
      yield Create3(ValueErrorType2.Promise, schema, path, value);
  }
  function* FromRecord14(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value))
      return yield Create3(ValueErrorType2.Object, schema, path, value);
    if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create3(ValueErrorType2.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create3(ValueErrorType2.ObjectMaxProperties, schema, path, value);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex2 = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex2.test(propertyKey))
        yield* Visit17(patternSchema, references, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
    }
    if (typeof schema.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (!regex2.test(propertyKey))
          yield* Visit17(schema.additionalProperties, references, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
      }
    }
    if (schema.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex2.test(propertyKey))
          continue;
        return yield Create3(ValueErrorType2.ObjectAdditionalProperties, schema, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
      }
    }
  }
  function* FromRef15(schema, references, path, value) {
    yield* Visit17((0, index_5.Deref)(schema, references), references, path, value);
  }
  function* FromRegExp5(schema, references, path, value) {
    if (!(0, index_10.IsString)(value))
      return yield Create3(ValueErrorType2.String, schema, path, value);
    if (IsDefined3(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create3(ValueErrorType2.StringMinLength, schema, path, value);
    }
    if (IsDefined3(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create3(ValueErrorType2.StringMaxLength, schema, path, value);
    }
    const regex2 = new RegExp(schema.source, schema.flags);
    if (!regex2.test(value)) {
      return yield Create3(ValueErrorType2.RegExp, schema, path, value);
    }
  }
  function* FromString6(schema, references, path, value) {
    if (!(0, index_10.IsString)(value))
      return yield Create3(ValueErrorType2.String, schema, path, value);
    if (IsDefined3(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create3(ValueErrorType2.StringMinLength, schema, path, value);
    }
    if (IsDefined3(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create3(ValueErrorType2.StringMaxLength, schema, path, value);
    }
    if ((0, index_10.IsString)(schema.pattern)) {
      const regex2 = new RegExp(schema.pattern);
      if (!regex2.test(value)) {
        yield Create3(ValueErrorType2.StringPattern, schema, path, value);
      }
    }
    if ((0, index_10.IsString)(schema.format)) {
      if (!index_3.FormatRegistry.Has(schema.format)) {
        yield Create3(ValueErrorType2.StringFormatUnknown, schema, path, value);
      } else {
        const format = index_3.FormatRegistry.Get(schema.format);
        if (!format(value)) {
          yield Create3(ValueErrorType2.StringFormat, schema, path, value);
        }
      }
    }
  }
  function* FromSymbol6(schema, references, path, value) {
    if (!(0, index_10.IsSymbol)(value))
      yield Create3(ValueErrorType2.Symbol, schema, path, value);
  }
  function* FromTemplateLiteral7(schema, references, path, value) {
    if (!(0, index_10.IsString)(value))
      return yield Create3(ValueErrorType2.String, schema, path, value);
    const regex2 = new RegExp(schema.pattern);
    if (!regex2.test(value)) {
      yield Create3(ValueErrorType2.StringPattern, schema, path, value);
    }
  }
  function* FromThis11(schema, references, path, value) {
    yield* Visit17((0, index_5.Deref)(schema, references), references, path, value);
  }
  function* FromTuple16(schema, references, path, value) {
    if (!(0, index_10.IsArray)(value))
      return yield Create3(ValueErrorType2.Tuple, schema, path, value);
    if (schema.items === undefined && !(value.length === 0)) {
      return yield Create3(ValueErrorType2.TupleLength, schema, path, value);
    }
    if (!(value.length === schema.maxItems)) {
      return yield Create3(ValueErrorType2.TupleLength, schema, path, value);
    }
    if (!schema.items) {
      return;
    }
    for (let i = 0;i < schema.items.length; i++) {
      yield* Visit17(schema.items[i], references, `${path}/${i}`, value[i]);
    }
  }
  function* FromUndefined6(schema, references, path, value) {
    if (!(0, index_10.IsUndefined)(value))
      yield Create3(ValueErrorType2.Undefined, schema, path, value);
  }
  function* FromUnion21(schema, references, path, value) {
    if ((0, index_7.Check)(schema, references, value))
      return;
    const errors = schema.anyOf.map((variant) => new ValueErrorIterator2(Visit17(variant, references, path, value)));
    yield Create3(ValueErrorType2.Union, schema, path, value, errors);
  }
  function* FromUint8Array5(schema, references, path, value) {
    if (!(0, index_10.IsUint8Array)(value))
      return yield Create3(ValueErrorType2.Uint8Array, schema, path, value);
    if (IsDefined3(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      yield Create3(ValueErrorType2.Uint8ArrayMaxByteLength, schema, path, value);
    }
    if (IsDefined3(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      yield Create3(ValueErrorType2.Uint8ArrayMinByteLength, schema, path, value);
    }
  }
  function* FromUnknown5(schema, references, path, value) {}
  function* FromVoid5(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsVoidLike(value))
      yield Create3(ValueErrorType2.Void, schema, path, value);
  }
  function* FromKind4(schema, references, path, value) {
    const check2 = index_3.TypeRegistry.Get(schema[index_8.Kind]);
    if (!check2(schema, value))
      yield Create3(ValueErrorType2.Kind, schema, path, value);
  }
  function* Visit17(schema, references, path, value) {
    const references_ = IsDefined3(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_8.Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, path, value);
      case "Argument":
        return yield* FromArgument5(schema_, references_, path, value);
      case "Array":
        return yield* FromArray18(schema_, references_, path, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator8(schema_, references_, path, value);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, path, value);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, path, value);
      case "Constructor":
        return yield* FromConstructor9(schema_, references_, path, value);
      case "Date":
        return yield* FromDate8(schema_, references_, path, value);
      case "Function":
        return yield* FromFunction8(schema_, references_, path, value);
      case "Import":
        return yield* FromImport11(schema_, references_, path, value);
      case "Integer":
        return yield* FromInteger6(schema_, references_, path, value);
      case "Intersect":
        return yield* FromIntersect19(schema_, references_, path, value);
      case "Iterator":
        return yield* FromIterator8(schema_, references_, path, value);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, path, value);
      case "Never":
        return yield* FromNever6(schema_, references_, path, value);
      case "Not":
        return yield* FromNot8(schema_, references_, path, value);
      case "Null":
        return yield* FromNull6(schema_, references_, path, value);
      case "Number":
        return yield* FromNumber6(schema_, references_, path, value);
      case "Object":
        return yield* FromObject19(schema_, references_, path, value);
      case "Promise":
        return yield* FromPromise8(schema_, references_, path, value);
      case "Record":
        return yield* FromRecord14(schema_, references_, path, value);
      case "Ref":
        return yield* FromRef15(schema_, references_, path, value);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, path, value);
      case "String":
        return yield* FromString6(schema_, references_, path, value);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, path, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, path, value);
      case "This":
        return yield* FromThis11(schema_, references_, path, value);
      case "Tuple":
        return yield* FromTuple16(schema_, references_, path, value);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, path, value);
      case "Union":
        return yield* FromUnion21(schema_, references_, path, value);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, path, value);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, path, value);
      case "Void":
        return yield* FromVoid5(schema_, references_, path, value);
      default:
        if (!index_3.TypeRegistry.Has(schema_[index_8.Kind]))
          throw new ValueErrorsUnknownTypeError2(schema);
        return yield* FromKind4(schema_, references_, path, value);
    }
  }
  function Errors2(...args) {
    const iterator = args.length === 3 ? Visit17(args[0], args[1], "", args[2]) : Visit17(args[0], [], "", args[1]);
    return new ValueErrorIterator2(iterator);
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/index.js
var require_errors2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_errors(), exports);
  __exportStar(require_function3(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/decode.js
var require_decode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformDecodeError = exports.TransformDecodeCheckError = undefined;
  exports.TransformDecode = TransformDecode2;
  var policy_1 = require_policy();
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_deref2();
  var index_5 = require_check2();
  var index_6 = require_guard2();
  var kind_1 = require_kind();

  class TransformDecodeCheckError2 extends index_2.TypeBoxError {
    constructor(schema, value, error3) {
      super(`Unable to decode value as it does not match the expected schema`);
      this.schema = schema;
      this.value = value;
      this.error = error3;
    }
  }
  exports.TransformDecodeCheckError = TransformDecodeCheckError2;

  class TransformDecodeError2 extends index_2.TypeBoxError {
    constructor(schema, path, value, error3) {
      super(error3 instanceof Error ? error3.message : "Unknown error");
      this.schema = schema;
      this.path = path;
      this.value = value;
      this.error = error3;
    }
  }
  exports.TransformDecodeError = TransformDecodeError2;
  function Default6(schema, path, value) {
    try {
      return (0, kind_1.IsTransform)(schema) ? schema[index_1.TransformKind].Decode(value) : value;
    } catch (error3) {
      throw new TransformDecodeError2(schema, path, value, error3);
    }
  }
  function FromArray18(schema, references, path, value) {
    return (0, index_6.IsArray)(value) ? Default6(schema, path, value.map((value2, index) => Visit17(schema.items, references, `${path}/${index}`, value2))) : Default6(schema, path, value);
  }
  function FromIntersect19(schema, references, path, value) {
    if (!(0, index_6.IsObject)(value) || (0, index_6.IsValueType)(value))
      return Default6(schema, path, value);
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map((entry) => entry[0]);
    const knownProperties = { ...value };
    for (const [knownKey, knownSchema] of knownEntries)
      if (knownKey in knownProperties) {
        knownProperties[knownKey] = Visit17(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
      }
    if (!(0, kind_1.IsTransform)(schema.unevaluatedProperties)) {
      return Default6(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        unknownProperties[key] = Default6(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default6(schema, path, unknownProperties);
  }
  function FromImport11(schema, references, path, value) {
    const additional = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    const result = Visit17(target, [...references, ...additional], path, value);
    return Default6(schema, path, result);
  }
  function FromNot8(schema, references, path, value) {
    return Default6(schema, path, Visit17(schema.not, references, path, value));
  }
  function FromObject19(schema, references, path, value) {
    if (!(0, index_6.IsObject)(value))
      return Default6(schema, path, value);
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...value };
    for (const key of knownKeys) {
      if (!(0, index_6.HasPropertyKey)(knownProperties, key))
        continue;
      if ((0, index_6.IsUndefined)(knownProperties[key]) && (!(0, kind_1.IsUndefined)(schema.properties[key]) || policy_1.TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
        continue;
      knownProperties[key] = Visit17(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
    if (!(0, kind_1.IsSchema)(schema.additionalProperties)) {
      return Default6(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        unknownProperties[key] = Default6(additionalProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default6(schema, path, unknownProperties);
  }
  function FromRecord14(schema, references, path, value) {
    if (!(0, index_6.IsObject)(value))
      return Default6(schema, path, value);
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...value };
    for (const key of Object.getOwnPropertyNames(value))
      if (knownKeys.test(key)) {
        knownProperties[key] = Visit17(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, kind_1.IsSchema)(schema.additionalProperties)) {
      return Default6(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.test(key)) {
        unknownProperties[key] = Default6(additionalProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default6(schema, path, unknownProperties);
  }
  function FromRef15(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default6(schema, path, Visit17(target, references, path, value));
  }
  function FromThis11(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default6(schema, path, Visit17(target, references, path, value));
  }
  function FromTuple16(schema, references, path, value) {
    return (0, index_6.IsArray)(value) && (0, index_6.IsArray)(schema.items) ? Default6(schema, path, schema.items.map((schema2, index) => Visit17(schema2, references, `${path}/${index}`, value[index]))) : Default6(schema, path, value);
  }
  function FromUnion21(schema, references, path, value) {
    for (const subschema of schema.anyOf) {
      if (!(0, index_5.Check)(subschema, references, value))
        continue;
      const decoded = Visit17(subschema, references, path, value);
      return Default6(schema, path, decoded);
    }
    return Default6(schema, path, value);
  }
  function Visit17(schema, references, path, value) {
    const references_ = (0, index_4.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
      case "Array":
        return FromArray18(schema_, references_, path, value);
      case "Import":
        return FromImport11(schema_, references_, path, value);
      case "Intersect":
        return FromIntersect19(schema_, references_, path, value);
      case "Not":
        return FromNot8(schema_, references_, path, value);
      case "Object":
        return FromObject19(schema_, references_, path, value);
      case "Record":
        return FromRecord14(schema_, references_, path, value);
      case "Ref":
        return FromRef15(schema_, references_, path, value);
      case "Symbol":
        return Default6(schema_, path, value);
      case "This":
        return FromThis11(schema_, references_, path, value);
      case "Tuple":
        return FromTuple16(schema_, references_, path, value);
      case "Union":
        return FromUnion21(schema_, references_, path, value);
      default:
        return Default6(schema_, path, value);
    }
  }
  function TransformDecode2(schema, references, value) {
    return Visit17(schema, references, "", value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/encode.js
var require_encode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformEncodeError = exports.TransformEncodeCheckError = undefined;
  exports.TransformEncode = TransformEncode2;
  var policy_1 = require_policy();
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_deref2();
  var index_5 = require_check2();
  var index_6 = require_guard2();
  var kind_1 = require_kind();

  class TransformEncodeCheckError2 extends index_2.TypeBoxError {
    constructor(schema, value, error3) {
      super(`The encoded value does not match the expected schema`);
      this.schema = schema;
      this.value = value;
      this.error = error3;
    }
  }
  exports.TransformEncodeCheckError = TransformEncodeCheckError2;

  class TransformEncodeError2 extends index_2.TypeBoxError {
    constructor(schema, path, value, error3) {
      super(`${error3 instanceof Error ? error3.message : "Unknown error"}`);
      this.schema = schema;
      this.path = path;
      this.value = value;
      this.error = error3;
    }
  }
  exports.TransformEncodeError = TransformEncodeError2;
  function Default6(schema, path, value) {
    try {
      return (0, kind_1.IsTransform)(schema) ? schema[index_1.TransformKind].Encode(value) : value;
    } catch (error3) {
      throw new TransformEncodeError2(schema, path, value, error3);
    }
  }
  function FromArray18(schema, references, path, value) {
    const defaulted = Default6(schema, path, value);
    return (0, index_6.IsArray)(defaulted) ? defaulted.map((value2, index) => Visit17(schema.items, references, `${path}/${index}`, value2)) : defaulted;
  }
  function FromImport11(schema, references, path, value) {
    const additional = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    const result = Default6(schema, path, value);
    return Visit17(target, [...references, ...additional], path, result);
  }
  function FromIntersect19(schema, references, path, value) {
    const defaulted = Default6(schema, path, value);
    if (!(0, index_6.IsObject)(value) || (0, index_6.IsValueType)(value))
      return defaulted;
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map((entry) => entry[0]);
    const knownProperties = { ...defaulted };
    for (const [knownKey, knownSchema] of knownEntries)
      if (knownKey in knownProperties) {
        knownProperties[knownKey] = Visit17(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
      }
    if (!(0, kind_1.IsTransform)(schema.unevaluatedProperties)) {
      return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        properties[key] = Default6(unevaluatedProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromNot8(schema, references, path, value) {
    return Default6(schema.not, path, Default6(schema, path, value));
  }
  function FromObject19(schema, references, path, value) {
    const defaulted = Default6(schema, path, value);
    if (!(0, index_6.IsObject)(defaulted))
      return defaulted;
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...defaulted };
    for (const key of knownKeys) {
      if (!(0, index_6.HasPropertyKey)(knownProperties, key))
        continue;
      if ((0, index_6.IsUndefined)(knownProperties[key]) && (!(0, kind_1.IsUndefined)(schema.properties[key]) || policy_1.TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
        continue;
      knownProperties[key] = Visit17(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
    if (!(0, kind_1.IsSchema)(schema.additionalProperties)) {
      return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        properties[key] = Default6(additionalProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromRecord14(schema, references, path, value) {
    const defaulted = Default6(schema, path, value);
    if (!(0, index_6.IsObject)(value))
      return defaulted;
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...defaulted };
    for (const key of Object.getOwnPropertyNames(value))
      if (knownKeys.test(key)) {
        knownProperties[key] = Visit17(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, kind_1.IsSchema)(schema.additionalProperties)) {
      return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.test(key)) {
        properties[key] = Default6(additionalProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromRef15(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit17(target, references, path, value);
    return Default6(schema, path, resolved);
  }
  function FromThis11(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit17(target, references, path, value);
    return Default6(schema, path, resolved);
  }
  function FromTuple16(schema, references, path, value) {
    const value1 = Default6(schema, path, value);
    return (0, index_6.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit17(schema2, references, `${path}/${index}`, value1[index])) : [];
  }
  function FromUnion21(schema, references, path, value) {
    for (const subschema of schema.anyOf) {
      if (!(0, index_5.Check)(subschema, references, value))
        continue;
      const value1 = Visit17(subschema, references, path, value);
      return Default6(schema, path, value1);
    }
    for (const subschema of schema.anyOf) {
      const value1 = Visit17(subschema, references, path, value);
      if (!(0, index_5.Check)(schema, references, value1))
        continue;
      return Default6(schema, path, value1);
    }
    return Default6(schema, path, value);
  }
  function Visit17(schema, references, path, value) {
    const references_ = (0, index_4.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
      case "Array":
        return FromArray18(schema_, references_, path, value);
      case "Import":
        return FromImport11(schema_, references_, path, value);
      case "Intersect":
        return FromIntersect19(schema_, references_, path, value);
      case "Not":
        return FromNot8(schema_, references_, path, value);
      case "Object":
        return FromObject19(schema_, references_, path, value);
      case "Record":
        return FromRecord14(schema_, references_, path, value);
      case "Ref":
        return FromRef15(schema_, references_, path, value);
      case "This":
        return FromThis11(schema_, references_, path, value);
      case "Tuple":
        return FromTuple16(schema_, references_, path, value);
      case "Union":
        return FromUnion21(schema_, references_, path, value);
      default:
        return Default6(schema_, path, value);
    }
  }
  function TransformEncode2(schema, references, value) {
    return Visit17(schema, references, "", value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/has.js
var require_has = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HasTransform = HasTransform2;
  var index_1 = require_deref2();
  var index_2 = require_symbols2();
  var kind_1 = require_kind();
  var index_3 = require_guard2();
  function FromArray18(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit17(schema.items, references);
  }
  function FromAsyncIterator8(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit17(schema.items, references);
  }
  function FromConstructor9(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit17(schema.returns, references) || schema.parameters.some((schema2) => Visit17(schema2, references));
  }
  function FromFunction8(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit17(schema.returns, references) || schema.parameters.some((schema2) => Visit17(schema2, references));
  }
  function FromIntersect19(schema, references) {
    return (0, kind_1.IsTransform)(schema) || (0, kind_1.IsTransform)(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit17(schema2, references));
  }
  function FromImport11(schema, references) {
    const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
    const target = schema.$defs[schema.$ref];
    return (0, kind_1.IsTransform)(schema) || Visit17(target, [...additional, ...references]);
  }
  function FromIterator8(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit17(schema.items, references);
  }
  function FromNot8(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit17(schema.not, references);
  }
  function FromObject19(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Object.values(schema.properties).some((schema2) => Visit17(schema2, references)) || (0, kind_1.IsSchema)(schema.additionalProperties) && Visit17(schema.additionalProperties, references);
  }
  function FromPromise8(schema, references) {
    return (0, kind_1.IsTransform)(schema) || Visit17(schema.item, references);
  }
  function FromRecord14(schema, references) {
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[pattern];
    return (0, kind_1.IsTransform)(schema) || Visit17(property, references) || (0, kind_1.IsSchema)(schema.additionalProperties) && (0, kind_1.IsTransform)(schema.additionalProperties);
  }
  function FromRef15(schema, references) {
    if ((0, kind_1.IsTransform)(schema))
      return true;
    return Visit17((0, index_1.Deref)(schema, references), references);
  }
  function FromThis11(schema, references) {
    if ((0, kind_1.IsTransform)(schema))
      return true;
    return Visit17((0, index_1.Deref)(schema, references), references);
  }
  function FromTuple16(schema, references) {
    return (0, kind_1.IsTransform)(schema) || !(0, index_3.IsUndefined)(schema.items) && schema.items.some((schema2) => Visit17(schema2, references));
  }
  function FromUnion21(schema, references) {
    return (0, kind_1.IsTransform)(schema) || schema.anyOf.some((schema2) => Visit17(schema2, references));
  }
  function Visit17(schema, references) {
    const references_ = (0, index_1.Pushref)(schema, references);
    const schema_ = schema;
    if (schema.$id && visited2.has(schema.$id))
      return false;
    if (schema.$id)
      visited2.add(schema.$id);
    switch (schema[index_2.Kind]) {
      case "Array":
        return FromArray18(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator8(schema_, references_);
      case "Constructor":
        return FromConstructor9(schema_, references_);
      case "Function":
        return FromFunction8(schema_, references_);
      case "Import":
        return FromImport11(schema_, references_);
      case "Intersect":
        return FromIntersect19(schema_, references_);
      case "Iterator":
        return FromIterator8(schema_, references_);
      case "Not":
        return FromNot8(schema_, references_);
      case "Object":
        return FromObject19(schema_, references_);
      case "Promise":
        return FromPromise8(schema_, references_);
      case "Record":
        return FromRecord14(schema_, references_);
      case "Ref":
        return FromRef15(schema_, references_);
      case "This":
        return FromThis11(schema_, references_);
      case "Tuple":
        return FromTuple16(schema_, references_);
      case "Union":
        return FromUnion21(schema_, references_);
      default:
        return (0, kind_1.IsTransform)(schema);
    }
  }
  var visited2 = new Set;
  function HasTransform2(schema, references) {
    visited2.clear();
    return Visit17(schema, references);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/index.js
var require_transform3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_decode(), exports);
  __exportStar(require_encode(), exports);
  __exportStar(require_has(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/compiler/compiler.js
var require_compiler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = undefined;
  var index_1 = require_transform3();
  var index_2 = require_errors2();
  var index_3 = require_system2();
  var index_4 = require_error2();
  var index_5 = require_deref2();
  var index_6 = require_hash2();
  var index_7 = require_symbols2();
  var index_8 = require_registry();
  var index_9 = require_keyof2();
  var extends_undefined_1 = require_extends_undefined();
  var index_10 = require_never2();
  var index_11 = require_ref2();
  var index_12 = require_guard2();
  var type_1 = require_type3();

  class TypeCheck3 {
    constructor(schema, references, checkFunc, code) {
      this.schema = schema;
      this.references = references;
      this.checkFunc = checkFunc;
      this.code = code;
      this.hasTransform = (0, index_1.HasTransform)(schema, references);
    }
    Code() {
      return this.code;
    }
    Schema() {
      return this.schema;
    }
    References() {
      return this.references;
    }
    Errors(value) {
      return (0, index_2.Errors)(this.schema, this.references, value);
    }
    Check(value) {
      return this.checkFunc(value);
    }
    Decode(value) {
      if (!this.checkFunc(value))
        throw new index_1.TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
      return this.hasTransform ? (0, index_1.TransformDecode)(this.schema, this.references, value) : value;
    }
    Encode(value) {
      const encoded = this.hasTransform ? (0, index_1.TransformEncode)(this.schema, this.references, value) : value;
      if (!this.checkFunc(encoded))
        throw new index_1.TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
      return encoded;
    }
  }
  exports.TypeCheck = TypeCheck3;
  var Character2;
  (function(Character3) {
    function DollarSign(code) {
      return code === 36;
    }
    Character3.DollarSign = DollarSign;
    function IsUnderscore(code) {
      return code === 95;
    }
    Character3.IsUnderscore = IsUnderscore;
    function IsAlpha(code) {
      return code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
    Character3.IsAlpha = IsAlpha;
    function IsNumeric(code) {
      return code >= 48 && code <= 57;
    }
    Character3.IsNumeric = IsNumeric;
  })(Character2 || (Character2 = {}));
  var MemberExpression2;
  (function(MemberExpression3) {
    function IsFirstCharacterNumeric(value) {
      if (value.length === 0)
        return false;
      return Character2.IsNumeric(value.charCodeAt(0));
    }
    function IsAccessor(value) {
      if (IsFirstCharacterNumeric(value))
        return false;
      for (let i = 0;i < value.length; i++) {
        const code = value.charCodeAt(i);
        const check2 = Character2.IsAlpha(code) || Character2.IsNumeric(code) || Character2.DollarSign(code) || Character2.IsUnderscore(code);
        if (!check2)
          return false;
      }
      return true;
    }
    function EscapeHyphen(key) {
      return key.replace(/'/g, "\\'");
    }
    function Encode2(object, key) {
      return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
    }
    MemberExpression3.Encode = Encode2;
  })(MemberExpression2 || (MemberExpression2 = {}));
  var Identifier2;
  (function(Identifier3) {
    function Encode2($id) {
      const buffer = [];
      for (let i = 0;i < $id.length; i++) {
        const code = $id.charCodeAt(i);
        if (Character2.IsNumeric(code) || Character2.IsAlpha(code)) {
          buffer.push($id.charAt(i));
        } else {
          buffer.push(`_${code}_`);
        }
      }
      return buffer.join("").replace(/__/g, "_");
    }
    Identifier3.Encode = Encode2;
  })(Identifier2 || (Identifier2 = {}));
  var LiteralString2;
  (function(LiteralString3) {
    function Escape3(content) {
      return content.replace(/'/g, "\\'");
    }
    LiteralString3.Escape = Escape3;
  })(LiteralString2 || (LiteralString2 = {}));

  class TypeCompilerUnknownTypeError2 extends index_4.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError2;

  class TypeCompilerTypeGuardError2 extends index_4.TypeBoxError {
    constructor(schema) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = schema;
    }
  }
  exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError2;
  var Policy2;
  (function(Policy3) {
    function IsExactOptionalProperty(value, key, expression) {
      return index_3.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression2.Encode(value, key)} !== undefined ? ${expression} : true)`;
    }
    Policy3.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      return !index_3.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
    }
    Policy3.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return !index_3.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
    }
    Policy3.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      return index_3.TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
    }
    Policy3.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      return index_3.TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
    }
    Policy3.IsVoidLike = IsVoidLike;
  })(Policy2 || (exports.Policy = Policy2 = {}));
  var TypeCompiler3;
  (function(TypeCompiler4) {
    function IsAnyOrUnknown2(schema) {
      return schema[index_7.Kind] === "Any" || schema[index_7.Kind] === "Unknown";
    }
    function* FromAny5(schema, references, value) {
      yield "true";
    }
    function* FromArgument5(schema, references, value) {
      yield "true";
    }
    function* FromArray18(schema, references, value) {
      yield `Array.isArray(${value})`;
      const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
      if ((0, index_12.IsNumber)(schema.maxItems))
        yield `${value}.length <= ${schema.maxItems}`;
      if ((0, index_12.IsNumber)(schema.minItems))
        yield `${value}.length >= ${schema.minItems}`;
      const elementExpression = CreateExpression(schema.items, references, "value");
      yield `${value}.every((${parameter}) => ${elementExpression})`;
      if ((0, type_1.IsSchema)(schema.contains) || (0, index_12.IsNumber)(schema.minContains) || (0, index_12.IsNumber)(schema.maxContains)) {
        const containsSchema = (0, type_1.IsSchema)(schema.contains) ? schema.contains : (0, index_10.Never)();
        const checkExpression = CreateExpression(containsSchema, references, "value");
        const checkMinContains = (0, index_12.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
        const checkMaxContains = (0, index_12.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
        const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
        const check2 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
        yield `((${parameter}) => { ${checkCount}; return ${check2}})(${value})`;
      }
      if (schema.uniqueItems === true) {
        const check2 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
        const block = `const set = new Set(); for(const element of value) { ${check2} }`;
        yield `((${parameter}) => { ${block} )(${value})`;
      }
    }
    function* FromAsyncIterator8(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
    }
    function* FromBigInt6(schema, references, value) {
      yield `(typeof ${value} === 'bigint')`;
      if ((0, index_12.IsBigInt)(schema.exclusiveMaximum))
        yield `${value} < BigInt(${schema.exclusiveMaximum})`;
      if ((0, index_12.IsBigInt)(schema.exclusiveMinimum))
        yield `${value} > BigInt(${schema.exclusiveMinimum})`;
      if ((0, index_12.IsBigInt)(schema.maximum))
        yield `${value} <= BigInt(${schema.maximum})`;
      if ((0, index_12.IsBigInt)(schema.minimum))
        yield `${value} >= BigInt(${schema.minimum})`;
      if ((0, index_12.IsBigInt)(schema.multipleOf))
        yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
    }
    function* FromBoolean6(schema, references, value) {
      yield `(typeof ${value} === 'boolean')`;
    }
    function* FromConstructor9(schema, references, value) {
      yield* Visit17(schema.returns, references, `${value}.prototype`);
    }
    function* FromDate8(schema, references, value) {
      yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
      if ((0, index_12.IsNumber)(schema.exclusiveMaximumTimestamp))
        yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
      if ((0, index_12.IsNumber)(schema.exclusiveMinimumTimestamp))
        yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
      if ((0, index_12.IsNumber)(schema.maximumTimestamp))
        yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
      if ((0, index_12.IsNumber)(schema.minimumTimestamp))
        yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
      if ((0, index_12.IsNumber)(schema.multipleOfTimestamp))
        yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
    }
    function* FromFunction8(schema, references, value) {
      yield `(typeof ${value} === 'function')`;
    }
    function* FromImport11(schema, references, value) {
      const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
        return [...result, schema.$defs[key]];
      }, []);
      yield* Visit17((0, index_11.Ref)(schema.$ref), [...references, ...members], value);
    }
    function* FromInteger6(schema, references, value) {
      yield `Number.isInteger(${value})`;
      if ((0, index_12.IsNumber)(schema.exclusiveMaximum))
        yield `${value} < ${schema.exclusiveMaximum}`;
      if ((0, index_12.IsNumber)(schema.exclusiveMinimum))
        yield `${value} > ${schema.exclusiveMinimum}`;
      if ((0, index_12.IsNumber)(schema.maximum))
        yield `${value} <= ${schema.maximum}`;
      if ((0, index_12.IsNumber)(schema.minimum))
        yield `${value} >= ${schema.minimum}`;
      if ((0, index_12.IsNumber)(schema.multipleOf))
        yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* FromIntersect19(schema, references, value) {
      const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
      if (schema.unevaluatedProperties === false) {
        const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema))};`);
        const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
        yield `(${check1} && ${check2})`;
      } else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {
        const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema))};`);
        const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
        yield `(${check1} && ${check2})`;
      } else {
        yield `(${check1})`;
      }
    }
    function* FromIterator8(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
    }
    function* FromLiteral7(schema, references, value) {
      if (typeof schema.const === "number" || typeof schema.const === "boolean") {
        yield `(${value} === ${schema.const})`;
      } else {
        yield `(${value} === '${LiteralString2.Escape(schema.const)}')`;
      }
    }
    function* FromNever6(schema, references, value) {
      yield `false`;
    }
    function* FromNot8(schema, references, value) {
      const expression = CreateExpression(schema.not, references, value);
      yield `(!${expression})`;
    }
    function* FromNull6(schema, references, value) {
      yield `(${value} === null)`;
    }
    function* FromNumber6(schema, references, value) {
      yield Policy2.IsNumberLike(value);
      if ((0, index_12.IsNumber)(schema.exclusiveMaximum))
        yield `${value} < ${schema.exclusiveMaximum}`;
      if ((0, index_12.IsNumber)(schema.exclusiveMinimum))
        yield `${value} > ${schema.exclusiveMinimum}`;
      if ((0, index_12.IsNumber)(schema.maximum))
        yield `${value} <= ${schema.maximum}`;
      if ((0, index_12.IsNumber)(schema.minimum))
        yield `${value} >= ${schema.minimum}`;
      if ((0, index_12.IsNumber)(schema.multipleOf))
        yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* FromObject19(schema, references, value) {
      yield Policy2.IsObjectLike(value);
      if ((0, index_12.IsNumber)(schema.minProperties))
        yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
      if ((0, index_12.IsNumber)(schema.maxProperties))
        yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
      const knownKeys = Object.getOwnPropertyNames(schema.properties);
      for (const knownKey of knownKeys) {
        const memberExpression = MemberExpression2.Encode(value, knownKey);
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
          yield* Visit17(property, references, memberExpression);
          if ((0, extends_undefined_1.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown2(property))
            yield `('${knownKey}' in ${value})`;
        } else {
          const expression = CreateExpression(property, references, memberExpression);
          yield Policy2.IsExactOptionalProperty(value, knownKey, expression);
        }
      }
      if (schema.additionalProperties === false) {
        if (schema.required && schema.required.length === knownKeys.length) {
          yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
        } else {
          const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
        }
      }
      if (typeof schema.additionalProperties === "object") {
        const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
      }
    }
    function* FromPromise8(schema, references, value) {
      yield `${value} instanceof Promise`;
    }
    function* FromRecord14(schema, references, value) {
      yield Policy2.IsRecordLike(value);
      if ((0, index_12.IsNumber)(schema.minProperties))
        yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
      if ((0, index_12.IsNumber)(schema.maxProperties))
        yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
      const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
      const variable = CreateVariable(`${new RegExp(patternKey)}`);
      const check1 = CreateExpression(patternSchema, references, "value");
      const check2 = (0, type_1.IsSchema)(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
      const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
      yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
    }
    function* FromRef15(schema, references, value) {
      const target = (0, index_5.Deref)(schema, references);
      if (state.functions.has(schema.$ref))
        return yield `${CreateFunctionName(schema.$ref)}(${value})`;
      yield* Visit17(target, references, value);
    }
    function* FromRegExp5(schema, references, value) {
      const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
      yield `(typeof ${value} === 'string')`;
      if ((0, index_12.IsNumber)(schema.maxLength))
        yield `${value}.length <= ${schema.maxLength}`;
      if ((0, index_12.IsNumber)(schema.minLength))
        yield `${value}.length >= ${schema.minLength}`;
      yield `${variable}.test(${value})`;
    }
    function* FromString6(schema, references, value) {
      yield `(typeof ${value} === 'string')`;
      if ((0, index_12.IsNumber)(schema.maxLength))
        yield `${value}.length <= ${schema.maxLength}`;
      if ((0, index_12.IsNumber)(schema.minLength))
        yield `${value}.length >= ${schema.minLength}`;
      if (schema.pattern !== undefined) {
        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
        yield `${variable}.test(${value})`;
      }
      if (schema.format !== undefined) {
        yield `format('${schema.format}', ${value})`;
      }
    }
    function* FromSymbol6(schema, references, value) {
      yield `(typeof ${value} === 'symbol')`;
    }
    function* FromTemplateLiteral7(schema, references, value) {
      yield `(typeof ${value} === 'string')`;
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    function* FromThis11(schema, references, value) {
      yield `${CreateFunctionName(schema.$ref)}(${value})`;
    }
    function* FromTuple16(schema, references, value) {
      yield `Array.isArray(${value})`;
      if (schema.items === undefined)
        return yield `${value}.length === 0`;
      yield `(${value}.length === ${schema.maxItems})`;
      for (let i = 0;i < schema.items.length; i++) {
        const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
        yield `${expression}`;
      }
    }
    function* FromUndefined6(schema, references, value) {
      yield `${value} === undefined`;
    }
    function* FromUnion21(schema, references, value) {
      const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
      yield `(${expressions.join(" || ")})`;
    }
    function* FromUint8Array5(schema, references, value) {
      yield `${value} instanceof Uint8Array`;
      if ((0, index_12.IsNumber)(schema.maxByteLength))
        yield `(${value}.length <= ${schema.maxByteLength})`;
      if ((0, index_12.IsNumber)(schema.minByteLength))
        yield `(${value}.length >= ${schema.minByteLength})`;
    }
    function* FromUnknown5(schema, references, value) {
      yield "true";
    }
    function* FromVoid5(schema, references, value) {
      yield Policy2.IsVoidLike(value);
    }
    function* FromKind4(schema, references, value) {
      const instance = state.instances.size;
      state.instances.set(instance, schema);
      yield `kind('${schema[index_7.Kind]}', ${instance}, ${value})`;
    }
    function* Visit17(schema, references, value, useHoisting = true) {
      const references_ = (0, index_12.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      if (useHoisting && (0, index_12.IsString)(schema.$id)) {
        const functionName = CreateFunctionName(schema.$id);
        if (state.functions.has(functionName)) {
          return yield `${functionName}(${value})`;
        } else {
          state.functions.set(functionName, "<deferred>");
          const functionCode = CreateFunction(functionName, schema, references, "value", false);
          state.functions.set(functionName, functionCode);
          return yield `${functionName}(${value})`;
        }
      }
      switch (schema_[index_7.Kind]) {
        case "Any":
          return yield* FromAny5(schema_, references_, value);
        case "Argument":
          return yield* FromArgument5(schema_, references_, value);
        case "Array":
          return yield* FromArray18(schema_, references_, value);
        case "AsyncIterator":
          return yield* FromAsyncIterator8(schema_, references_, value);
        case "BigInt":
          return yield* FromBigInt6(schema_, references_, value);
        case "Boolean":
          return yield* FromBoolean6(schema_, references_, value);
        case "Constructor":
          return yield* FromConstructor9(schema_, references_, value);
        case "Date":
          return yield* FromDate8(schema_, references_, value);
        case "Function":
          return yield* FromFunction8(schema_, references_, value);
        case "Import":
          return yield* FromImport11(schema_, references_, value);
        case "Integer":
          return yield* FromInteger6(schema_, references_, value);
        case "Intersect":
          return yield* FromIntersect19(schema_, references_, value);
        case "Iterator":
          return yield* FromIterator8(schema_, references_, value);
        case "Literal":
          return yield* FromLiteral7(schema_, references_, value);
        case "Never":
          return yield* FromNever6(schema_, references_, value);
        case "Not":
          return yield* FromNot8(schema_, references_, value);
        case "Null":
          return yield* FromNull6(schema_, references_, value);
        case "Number":
          return yield* FromNumber6(schema_, references_, value);
        case "Object":
          return yield* FromObject19(schema_, references_, value);
        case "Promise":
          return yield* FromPromise8(schema_, references_, value);
        case "Record":
          return yield* FromRecord14(schema_, references_, value);
        case "Ref":
          return yield* FromRef15(schema_, references_, value);
        case "RegExp":
          return yield* FromRegExp5(schema_, references_, value);
        case "String":
          return yield* FromString6(schema_, references_, value);
        case "Symbol":
          return yield* FromSymbol6(schema_, references_, value);
        case "TemplateLiteral":
          return yield* FromTemplateLiteral7(schema_, references_, value);
        case "This":
          return yield* FromThis11(schema_, references_, value);
        case "Tuple":
          return yield* FromTuple16(schema_, references_, value);
        case "Undefined":
          return yield* FromUndefined6(schema_, references_, value);
        case "Union":
          return yield* FromUnion21(schema_, references_, value);
        case "Uint8Array":
          return yield* FromUint8Array5(schema_, references_, value);
        case "Unknown":
          return yield* FromUnknown5(schema_, references_, value);
        case "Void":
          return yield* FromVoid5(schema_, references_, value);
        default:
          if (!index_8.TypeRegistry.Has(schema_[index_7.Kind]))
            throw new TypeCompilerUnknownTypeError2(schema);
          return yield* FromKind4(schema_, references_, value);
      }
    }
    const state = {
      language: "javascript",
      functions: new Map,
      variables: new Map,
      instances: new Map
    };
    function CreateExpression(schema, references, value, useHoisting = true) {
      return `(${[...Visit17(schema, references, value, useHoisting)].join(" && ")})`;
    }
    function CreateFunctionName($id) {
      return `check_${Identifier2.Encode($id)}`;
    }
    function CreateVariable(expression) {
      const variableName = `local_${state.variables.size}`;
      state.variables.set(variableName, `const ${variableName} = ${expression}`);
      return variableName;
    }
    function CreateFunction(name, schema, references, value, useHoisting = true) {
      const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const expression = [...Visit17(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
      return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
    }
    function CreateParameter(name, type2) {
      const annotation = state.language === "typescript" ? `: ${type2}` : "";
      return `${name}${annotation}`;
    }
    function CreateReturns(type2) {
      return state.language === "typescript" ? `: ${type2}` : "";
    }
    function Build(schema, references, options) {
      const functionCode = CreateFunction("check", schema, references, "value");
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const functions = [...state.functions.values()];
      const variables = [...state.variables.values()];
      const checkFunction = (0, index_12.IsString)(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
      return [...variables, ...functions, checkFunction].join(`
`);
    }
    function Code(...args) {
      const defaults = { language: "javascript" };
      const [schema, references, options] = args.length === 2 && (0, index_12.IsArray)(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !(0, index_12.IsArray)(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
      state.language = options.language;
      state.variables.clear();
      state.functions.clear();
      state.instances.clear();
      if (!(0, type_1.IsSchema)(schema))
        throw new TypeCompilerTypeGuardError2(schema);
      for (const schema2 of references)
        if (!(0, type_1.IsSchema)(schema2))
          throw new TypeCompilerTypeGuardError2(schema2);
      return Build(schema, references, options);
    }
    TypeCompiler4.Code = Code;
    function Compile(schema, references = []) {
      const generatedCode = Code(schema, references, { language: "javascript" });
      const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
      const instances = new Map(state.instances);
      function typeRegistryFunction(kind, instance, value) {
        if (!index_8.TypeRegistry.Has(kind) || !instances.has(instance))
          return false;
        const checkFunc = index_8.TypeRegistry.Get(kind);
        const schema2 = instances.get(instance);
        return checkFunc(schema2, value);
      }
      function formatRegistryFunction(format, value) {
        if (!index_8.FormatRegistry.Has(format))
          return false;
        const checkFunc = index_8.FormatRegistry.Get(format);
        return checkFunc(value);
      }
      function hashFunction(value) {
        return (0, index_6.Hash)(value);
      }
      const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
      return new TypeCheck3(schema, references, checkFunction, generatedCode);
    }
    TypeCompiler4.Compile = Compile;
  })(TypeCompiler3 || (exports.TypeCompiler = TypeCompiler3 = {}));
});

// node_modules/@sinclair/typebox/build/cjs/compiler/index.js
var require_compiler2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_compiler(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/assert/assert.js
var require_assert = __commonJS((exports) => {
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _AssertError_instances2;
  var _AssertError_iterator2;
  var _AssertError_Iterator3;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AssertError = undefined;
  exports.Assert = Assert2;
  var index_1 = require_errors2();
  var error_1 = require_error();
  var check_1 = require_check();

  class AssertError2 extends error_1.TypeBoxError {
    constructor(iterator) {
      const error3 = iterator.First();
      super(error3 === undefined ? "Invalid Value" : error3.message);
      _AssertError_instances2.add(this);
      _AssertError_iterator2.set(this, undefined);
      __classPrivateFieldSet2(this, _AssertError_iterator2, iterator, "f");
      this.error = error3;
    }
    Errors() {
      return new index_1.ValueErrorIterator(__classPrivateFieldGet2(this, _AssertError_instances2, "m", _AssertError_Iterator3).call(this));
    }
  }
  exports.AssertError = AssertError2;
  _AssertError_iterator2 = new WeakMap, _AssertError_instances2 = new WeakSet, _AssertError_Iterator3 = function* _AssertError_Iterator() {
    if (this.error)
      yield this.error;
    yield* __classPrivateFieldGet2(this, _AssertError_iterator2, "f");
  };
  function AssertValue2(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return;
    throw new AssertError2((0, index_1.Errors)(schema, references, value));
  }
  function Assert2(...args) {
    return args.length === 3 ? AssertValue2(args[0], args[1], args[2]) : AssertValue2(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/assert/index.js
var require_assert2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_assert(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/clone.js
var require_clone3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = Clone3;
  var index_1 = require_guard2();
  function FromObject19(value) {
    const Acc = {};
    for (const key of Object.getOwnPropertyNames(value)) {
      Acc[key] = Clone3(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      Acc[key] = Clone3(value[key]);
    }
    return Acc;
  }
  function FromArray18(value) {
    return value.map((element) => Clone3(element));
  }
  function FromTypedArray2(value) {
    return value.slice();
  }
  function FromMap2(value) {
    return new Map(Clone3([...value.entries()]));
  }
  function FromSet2(value) {
    return new Set(Clone3([...value.entries()]));
  }
  function FromDate8(value) {
    return new Date(value.toISOString());
  }
  function FromValue3(value) {
    return value;
  }
  function Clone3(value) {
    if ((0, index_1.IsArray)(value))
      return FromArray18(value);
    if ((0, index_1.IsDate)(value))
      return FromDate8(value);
    if ((0, index_1.IsTypedArray)(value))
      return FromTypedArray2(value);
    if ((0, index_1.IsMap)(value))
      return FromMap2(value);
    if ((0, index_1.IsSet)(value))
      return FromSet2(value);
    if ((0, index_1.IsObject)(value))
      return FromObject19(value);
    if ((0, index_1.IsValueType)(value))
      return FromValue3(value);
    throw new Error("ValueClone: Unable to clone value");
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/index.js
var require_clone4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clone3(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/create/create.js
var require_create2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueCreateError = undefined;
  exports.Create = Create3;
  var index_1 = require_guard2();
  var index_2 = require_check2();
  var index_3 = require_clone4();
  var index_4 = require_deref2();
  var index_5 = require_template_literal2();
  var index_6 = require_patterns2();
  var index_7 = require_registry();
  var index_8 = require_symbols2();
  var index_9 = require_error2();
  var guard_1 = require_guard();

  class ValueCreateError2 extends index_9.TypeBoxError {
    constructor(schema, message) {
      super(message);
      this.schema = schema;
    }
  }
  exports.ValueCreateError = ValueCreateError2;
  function FromDefault2(value) {
    return (0, guard_1.IsFunction)(value) ? value() : (0, index_3.Clone)(value);
  }
  function FromAny5(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return {};
    }
  }
  function FromArgument5(schema, references) {
    return {};
  }
  function FromArray18(schema, references) {
    if (schema.uniqueItems === true && !(0, index_1.HasPropertyKey)(schema, "default")) {
      throw new ValueCreateError2(schema, "Array with the uniqueItems constraint requires a default value");
    } else if ("contains" in schema && !(0, index_1.HasPropertyKey)(schema, "default")) {
      throw new ValueCreateError2(schema, "Array with the contains constraint requires a default value");
    } else if ("default" in schema) {
      return FromDefault2(schema.default);
    } else if (schema.minItems !== undefined) {
      return Array.from({ length: schema.minItems }).map((item) => {
        return Visit17(schema.items, references);
      });
    } else {
      return [];
    }
  }
  function FromAsyncIterator8(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return async function* () {}();
    }
  }
  function FromBigInt6(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return BigInt(0);
    }
  }
  function FromBoolean6(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return false;
    }
  }
  function FromConstructor9(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      const value = Visit17(schema.returns, references);
      if (typeof value === "object" && !Array.isArray(value)) {
        return class {
          constructor() {
            for (const [key, val] of Object.entries(value)) {
              const self2 = this;
              self2[key] = val;
            }
          }
        };
      } else {
        return class {
        };
      }
    }
  }
  function FromDate8(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else if (schema.minimumTimestamp !== undefined) {
      return new Date(schema.minimumTimestamp);
    } else {
      return new Date;
    }
  }
  function FromFunction8(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return () => Visit17(schema.returns, references);
    }
  }
  function FromImport11(schema, references) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit17(target, [...references, ...definitions]);
  }
  function FromInteger6(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function FromIntersect19(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      const value = schema.allOf.reduce((acc, schema2) => {
        const next2 = Visit17(schema2, references);
        return typeof next2 === "object" ? { ...acc, ...next2 } : next2;
      }, {});
      if (!(0, index_2.Check)(schema, references, value))
        throw new ValueCreateError2(schema, "Intersect produced invalid value. Consider using a default value.");
      return value;
    }
  }
  function FromIterator8(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return function* () {}();
    }
  }
  function FromLiteral7(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return schema.const;
    }
  }
  function FromNever6(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      throw new ValueCreateError2(schema, "Never types cannot be created. Consider using a default value.");
    }
  }
  function FromNot8(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      throw new ValueCreateError2(schema, "Not types must have a default value");
    }
  }
  function FromNull6(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return null;
    }
  }
  function FromNumber6(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function FromObject19(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      const required = new Set(schema.required);
      const Acc = {};
      for (const [key, subschema] of Object.entries(schema.properties)) {
        if (!required.has(key))
          continue;
        Acc[key] = Visit17(subschema, references);
      }
      return Acc;
    }
  }
  function FromPromise8(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return Promise.resolve(Visit17(schema.item, references));
    }
  }
  function FromRecord14(schema, references) {
    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else if (!(keyPattern === index_6.PatternStringExact || keyPattern === index_6.PatternNumberExact)) {
      const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
      const Acc = {};
      for (const key of propertyKeys)
        Acc[key] = Visit17(valueSchema, references);
      return Acc;
    } else {
      return {};
    }
  }
  function FromRef15(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return Visit17((0, index_4.Deref)(schema, references), references);
    }
  }
  function FromRegExp5(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      throw new ValueCreateError2(schema, "RegExp types cannot be created. Consider using a default value.");
    }
  }
  function FromString6(schema, references) {
    if (schema.pattern !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError2(schema, "String types with patterns must specify a default value");
      } else {
        return FromDefault2(schema.default);
      }
    } else if (schema.format !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError2(schema, "String types with formats must specify a default value");
      } else {
        return FromDefault2(schema.default);
      }
    } else {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault2(schema.default);
      } else if (schema.minLength !== undefined) {
        return Array.from({ length: schema.minLength }).map(() => " ").join("");
      } else {
        return "";
      }
    }
  }
  function FromSymbol6(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else if ("value" in schema) {
      return Symbol.for(schema.value);
    } else {
      return Symbol();
    }
  }
  function FromTemplateLiteral7(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    }
    if (!(0, index_5.IsTemplateLiteralFinite)(schema))
      throw new ValueCreateError2(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
    const generated = (0, index_5.TemplateLiteralGenerate)(schema);
    return generated[0];
  }
  function FromThis11(schema, references) {
    if (recursiveDepth2++ > recursiveMaxDepth2)
      throw new ValueCreateError2(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return Visit17((0, index_4.Deref)(schema, references), references);
    }
  }
  function FromTuple16(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    }
    if (schema.items === undefined) {
      return [];
    } else {
      return Array.from({ length: schema.minItems }).map((_, index) => Visit17(schema.items[index], references));
    }
  }
  function FromUndefined6(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return;
    }
  }
  function FromUnion21(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else if (schema.anyOf.length === 0) {
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    } else {
      return Visit17(schema.anyOf[0], references);
    }
  }
  function FromUint8Array5(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else if (schema.minByteLength !== undefined) {
      return new Uint8Array(schema.minByteLength);
    } else {
      return new Uint8Array(0);
    }
  }
  function FromUnknown5(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return {};
    }
  }
  function FromVoid5(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      return;
    }
  }
  function FromKind4(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault2(schema.default);
    } else {
      throw new Error("User defined types must specify a default value");
    }
  }
  function Visit17(schema, references) {
    const references_ = (0, index_4.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema_[index_8.Kind]) {
      case "Any":
        return FromAny5(schema_, references_);
      case "Argument":
        return FromArgument5(schema_, references_);
      case "Array":
        return FromArray18(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator8(schema_, references_);
      case "BigInt":
        return FromBigInt6(schema_, references_);
      case "Boolean":
        return FromBoolean6(schema_, references_);
      case "Constructor":
        return FromConstructor9(schema_, references_);
      case "Date":
        return FromDate8(schema_, references_);
      case "Function":
        return FromFunction8(schema_, references_);
      case "Import":
        return FromImport11(schema_, references_);
      case "Integer":
        return FromInteger6(schema_, references_);
      case "Intersect":
        return FromIntersect19(schema_, references_);
      case "Iterator":
        return FromIterator8(schema_, references_);
      case "Literal":
        return FromLiteral7(schema_, references_);
      case "Never":
        return FromNever6(schema_, references_);
      case "Not":
        return FromNot8(schema_, references_);
      case "Null":
        return FromNull6(schema_, references_);
      case "Number":
        return FromNumber6(schema_, references_);
      case "Object":
        return FromObject19(schema_, references_);
      case "Promise":
        return FromPromise8(schema_, references_);
      case "Record":
        return FromRecord14(schema_, references_);
      case "Ref":
        return FromRef15(schema_, references_);
      case "RegExp":
        return FromRegExp5(schema_, references_);
      case "String":
        return FromString6(schema_, references_);
      case "Symbol":
        return FromSymbol6(schema_, references_);
      case "TemplateLiteral":
        return FromTemplateLiteral7(schema_, references_);
      case "This":
        return FromThis11(schema_, references_);
      case "Tuple":
        return FromTuple16(schema_, references_);
      case "Undefined":
        return FromUndefined6(schema_, references_);
      case "Union":
        return FromUnion21(schema_, references_);
      case "Uint8Array":
        return FromUint8Array5(schema_, references_);
      case "Unknown":
        return FromUnknown5(schema_, references_);
      case "Void":
        return FromVoid5(schema_, references_);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_8.Kind]))
          throw new ValueCreateError2(schema_, "Unknown type");
        return FromKind4(schema_, references_);
    }
  }
  var recursiveMaxDepth2 = 512;
  var recursiveDepth2 = 0;
  function Create3(...args) {
    recursiveDepth2 = 0;
    return args.length === 2 ? Visit17(args[0], args[1]) : Visit17(args[0], []);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/create/index.js
var require_create3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_create2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/cast.js
var require_cast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueCastError = undefined;
  exports.Cast = Cast2;
  var index_1 = require_guard2();
  var index_2 = require_error2();
  var index_3 = require_symbols2();
  var index_4 = require_create3();
  var index_5 = require_check2();
  var index_6 = require_clone4();
  var index_7 = require_deref2();

  class ValueCastError2 extends index_2.TypeBoxError {
    constructor(schema, message) {
      super(message);
      this.schema = schema;
    }
  }
  exports.ValueCastError = ValueCastError2;
  function ScoreUnion2(schema, references, value) {
    if (schema[index_3.Kind] === "Object" && typeof value === "object" && !(0, index_1.IsNull)(value)) {
      const object = schema;
      const keys = Object.getOwnPropertyNames(value);
      const entries = Object.entries(object.properties);
      const [point, max] = [1 / entries.length, entries.length];
      return entries.reduce((acc, [key, schema2]) => {
        const literal = schema2[index_3.Kind] === "Literal" && schema2.const === value[key] ? max : 0;
        const checks = (0, index_5.Check)(schema2, references, value[key]) ? point : 0;
        const exists = keys.includes(key) ? point : 0;
        return acc + (literal + checks + exists);
      }, 0);
    } else {
      return (0, index_5.Check)(schema, references, value) ? 1 : 0;
    }
  }
  function SelectUnion2(union, references, value) {
    const schemas = union.anyOf.map((schema) => (0, index_7.Deref)(schema, references));
    let [select, best] = [schemas[0], 0];
    for (const schema of schemas) {
      const score = ScoreUnion2(schema, references, value);
      if (score > best) {
        select = schema;
        best = score;
      }
    }
    return select;
  }
  function CastUnion2(union, references, value) {
    if ("default" in union) {
      return typeof value === "function" ? union.default : (0, index_6.Clone)(union.default);
    } else {
      const schema = SelectUnion2(union, references, value);
      return Cast2(schema, references, value);
    }
  }
  function DefaultClone2(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
  }
  function Default6(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? value : (0, index_4.Create)(schema, references);
  }
  function FromArray18(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    const created = (0, index_1.IsArray)(value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
    const minimum = (0, index_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
    const maximum = (0, index_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
    const casted = maximum.map((value2) => Visit17(schema.items, references, value2));
    if (schema.uniqueItems !== true)
      return casted;
    const unique = [...new Set(casted)];
    if (!(0, index_5.Check)(schema, references, unique))
      throw new ValueCastError2(schema, "Array cast produced invalid data due to uniqueItems constraint");
    return unique;
  }
  function FromConstructor9(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_4.Create)(schema, references);
    const required = new Set(schema.returns.required || []);
    const result = function() {};
    for (const [key, property] of Object.entries(schema.returns.properties)) {
      if (!required.has(key) && value.prototype[key] === undefined)
        continue;
      result.prototype[key] = Visit17(property, references, value.prototype[key]);
    }
    return result;
  }
  function FromImport11(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit17(target, [...references, ...definitions], value);
  }
  function FromIntersect19(schema, references, value) {
    const created = (0, index_4.Create)(schema, references);
    const mapped = (0, index_1.IsObject)(created) && (0, index_1.IsObject)(value) ? { ...created, ...value } : value;
    return (0, index_5.Check)(schema, references, mapped) ? mapped : (0, index_4.Create)(schema, references);
  }
  function FromNever6(schema, references, value) {
    throw new ValueCastError2(schema, "Never types cannot be cast");
  }
  function FromObject19(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return value;
    if (value === null || typeof value !== "object")
      return (0, index_4.Create)(schema, references);
    const required = new Set(schema.required || []);
    const result = {};
    for (const [key, property] of Object.entries(schema.properties)) {
      if (!required.has(key) && value[key] === undefined)
        continue;
      result[key] = Visit17(property, references, value[key]);
    }
    if (typeof schema.additionalProperties === "object") {
      const propertyNames = Object.getOwnPropertyNames(schema.properties);
      for (const propertyName of Object.getOwnPropertyNames(value)) {
        if (propertyNames.includes(propertyName))
          continue;
        result[propertyName] = Visit17(schema.additionalProperties, references, value[propertyName]);
      }
    }
    return result;
  }
  function FromRecord14(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
      return (0, index_4.Create)(schema, references);
    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const subschema = schema.patternProperties[subschemaPropertyName];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit17(subschema, references, propValue);
    }
    return result;
  }
  function FromRef15(schema, references, value) {
    return Visit17((0, index_7.Deref)(schema, references), references, value);
  }
  function FromThis11(schema, references, value) {
    return Visit17((0, index_7.Deref)(schema, references), references, value);
  }
  function FromTuple16(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    if (!(0, index_1.IsArray)(value))
      return (0, index_4.Create)(schema, references);
    if (schema.items === undefined)
      return [];
    return schema.items.map((schema2, index) => Visit17(schema2, references, value[index]));
  }
  function FromUnion21(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : CastUnion2(schema, references, value);
  }
  function Visit17(schema, references, value) {
    const references_ = (0, index_1.IsString)(schema.$id) ? (0, index_7.Pushref)(schema, references) : references;
    const schema_ = schema;
    switch (schema[index_3.Kind]) {
      case "Array":
        return FromArray18(schema_, references_, value);
      case "Constructor":
        return FromConstructor9(schema_, references_, value);
      case "Import":
        return FromImport11(schema_, references_, value);
      case "Intersect":
        return FromIntersect19(schema_, references_, value);
      case "Never":
        return FromNever6(schema_, references_, value);
      case "Object":
        return FromObject19(schema_, references_, value);
      case "Record":
        return FromRecord14(schema_, references_, value);
      case "Ref":
        return FromRef15(schema_, references_, value);
      case "This":
        return FromThis11(schema_, references_, value);
      case "Tuple":
        return FromTuple16(schema_, references_, value);
      case "Union":
        return FromUnion21(schema_, references_, value);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return DefaultClone2(schema, references, value);
      default:
        return Default6(schema_, references_, value);
    }
  }
  function Cast2(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/index.js
var require_cast2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_cast(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/clean.js
var require_clean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clean = Clean2;
  var index_1 = require_keyof2();
  var index_2 = require_check2();
  var index_3 = require_clone4();
  var index_4 = require_deref2();
  var index_5 = require_symbols2();
  var index_6 = require_guard2();
  var kind_1 = require_kind();
  function IsCheckable2(schema) {
    return (0, kind_1.IsKind)(schema) && schema[index_5.Kind] !== "Unsafe";
  }
  function FromArray18(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
      return value;
    return value.map((value2) => Visit17(schema.items, references, value2));
  }
  function FromImport11(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit17(target, [...references, ...definitions], value);
  }
  function FromIntersect19(schema, references, value) {
    const unevaluatedProperties = schema.unevaluatedProperties;
    const intersections = schema.allOf.map((schema2) => Visit17(schema2, references, (0, index_3.Clone)(value)));
    const composite = intersections.reduce((acc, value2) => (0, index_6.IsObject)(value2) ? { ...acc, ...value2 } : value2, {});
    if (!(0, index_6.IsObject)(value) || !(0, index_6.IsObject)(composite) || !(0, kind_1.IsKind)(unevaluatedProperties))
      return composite;
    const knownkeys = (0, index_1.KeyOfPropertyKeys)(schema);
    for (const key of Object.getOwnPropertyNames(value)) {
      if (knownkeys.includes(key))
        continue;
      if ((0, index_2.Check)(unevaluatedProperties, references, value[key])) {
        composite[key] = Visit17(unevaluatedProperties, references, value[key]);
      }
    }
    return composite;
  }
  function FromObject19(schema, references, value) {
    if (!(0, index_6.IsObject)(value) || (0, index_6.IsArray)(value))
      return value;
    const additionalProperties = schema.additionalProperties;
    for (const key of Object.getOwnPropertyNames(value)) {
      if ((0, index_6.HasPropertyKey)(schema.properties, key)) {
        value[key] = Visit17(schema.properties[key], references, value[key]);
        continue;
      }
      if ((0, kind_1.IsKind)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
        value[key] = Visit17(additionalProperties, references, value[key]);
        continue;
      }
      delete value[key];
    }
    return value;
  }
  function FromRecord14(schema, references, value) {
    if (!(0, index_6.IsObject)(value))
      return value;
    const additionalProperties = schema.additionalProperties;
    const propertyKeys = Object.getOwnPropertyNames(value);
    const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
    const propertyKeyTest = new RegExp(propertyKey);
    for (const key of propertyKeys) {
      if (propertyKeyTest.test(key)) {
        value[key] = Visit17(propertySchema, references, value[key]);
        continue;
      }
      if ((0, kind_1.IsKind)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
        value[key] = Visit17(additionalProperties, references, value[key]);
        continue;
      }
      delete value[key];
    }
    return value;
  }
  function FromRef15(schema, references, value) {
    return Visit17((0, index_4.Deref)(schema, references), references, value);
  }
  function FromThis11(schema, references, value) {
    return Visit17((0, index_4.Deref)(schema, references), references, value);
  }
  function FromTuple16(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
      return value;
    if ((0, index_6.IsUndefined)(schema.items))
      return [];
    const length = Math.min(value.length, schema.items.length);
    for (let i = 0;i < length; i++) {
      value[i] = Visit17(schema.items[i], references, value[i]);
    }
    return value.length > length ? value.slice(0, length) : value;
  }
  function FromUnion21(schema, references, value) {
    for (const inner of schema.anyOf) {
      if (IsCheckable2(inner) && (0, index_2.Check)(inner, references, value)) {
        return Visit17(inner, references, value);
      }
    }
    return value;
  }
  function Visit17(schema, references, value) {
    const references_ = (0, index_6.IsString)(schema.$id) ? (0, index_4.Pushref)(schema, references) : references;
    const schema_ = schema;
    switch (schema_[index_5.Kind]) {
      case "Array":
        return FromArray18(schema_, references_, value);
      case "Import":
        return FromImport11(schema_, references_, value);
      case "Intersect":
        return FromIntersect19(schema_, references_, value);
      case "Object":
        return FromObject19(schema_, references_, value);
      case "Record":
        return FromRecord14(schema_, references_, value);
      case "Ref":
        return FromRef15(schema_, references_, value);
      case "This":
        return FromThis11(schema_, references_, value);
      case "Tuple":
        return FromTuple16(schema_, references_, value);
      case "Union":
        return FromUnion21(schema_, references_, value);
      default:
        return value;
    }
  }
  function Clean2(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/index.js
var require_clean2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clean(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/convert.js
var require_convert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Convert = Convert2;
  var index_1 = require_clone4();
  var index_2 = require_check2();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  function IsStringNumeric2(value) {
    return (0, index_5.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
  }
  function IsValueToString2(value) {
    return (0, index_5.IsBigInt)(value) || (0, index_5.IsBoolean)(value) || (0, index_5.IsNumber)(value);
  }
  function IsValueTrue2(value) {
    return value === true || (0, index_5.IsNumber)(value) && value === 1 || (0, index_5.IsBigInt)(value) && value === BigInt("1") || (0, index_5.IsString)(value) && (value.toLowerCase() === "true" || value === "1");
  }
  function IsValueFalse2(value) {
    return value === false || (0, index_5.IsNumber)(value) && (value === 0 || Object.is(value, -0)) || (0, index_5.IsBigInt)(value) && value === BigInt("0") || (0, index_5.IsString)(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
  }
  function IsTimeStringWithTimeZone2(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsTimeStringWithoutTimeZone2(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateTimeStringWithTimeZone2(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsDateTimeStringWithoutTimeZone2(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateString2(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
  }
  function TryConvertLiteralString2(value, target) {
    const conversion = TryConvertString2(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralNumber2(value, target) {
    const conversion = TryConvertNumber2(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralBoolean2(value, target) {
    const conversion = TryConvertBoolean2(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteral2(schema, value) {
    return (0, index_5.IsString)(schema.const) ? TryConvertLiteralString2(value, schema.const) : (0, index_5.IsNumber)(schema.const) ? TryConvertLiteralNumber2(value, schema.const) : (0, index_5.IsBoolean)(schema.const) ? TryConvertLiteralBoolean2(value, schema.const) : value;
  }
  function TryConvertBoolean2(value) {
    return IsValueTrue2(value) ? true : IsValueFalse2(value) ? false : value;
  }
  function TryConvertBigInt2(value) {
    const truncateInteger = (value2) => value2.split(".")[0];
    return IsStringNumeric2(value) ? BigInt(truncateInteger(value)) : (0, index_5.IsNumber)(value) ? BigInt(Math.trunc(value)) : IsValueFalse2(value) ? BigInt(0) : IsValueTrue2(value) ? BigInt(1) : value;
  }
  function TryConvertString2(value) {
    return (0, index_5.IsSymbol)(value) && value.description !== undefined ? value.description.toString() : IsValueToString2(value) ? value.toString() : value;
  }
  function TryConvertNumber2(value) {
    return IsStringNumeric2(value) ? parseFloat(value) : IsValueTrue2(value) ? 1 : IsValueFalse2(value) ? 0 : value;
  }
  function TryConvertInteger2(value) {
    return IsStringNumeric2(value) ? parseInt(value) : (0, index_5.IsNumber)(value) ? Math.trunc(value) : IsValueTrue2(value) ? 1 : IsValueFalse2(value) ? 0 : value;
  }
  function TryConvertNull2(value) {
    return (0, index_5.IsString)(value) && value.toLowerCase() === "null" ? null : value;
  }
  function TryConvertUndefined2(value) {
    return (0, index_5.IsString)(value) && value === "undefined" ? undefined : value;
  }
  function TryConvertDate2(value) {
    return (0, index_5.IsDate)(value) ? value : (0, index_5.IsNumber)(value) ? new Date(value) : IsValueTrue2(value) ? new Date(1) : IsValueFalse2(value) ? new Date(0) : IsStringNumeric2(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone2(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone2(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone2(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone2(value) ? new Date(value) : IsDateString2(value) ? new Date(`${value}T00:00:00.000Z`) : value;
  }
  function Default6(value) {
    return value;
  }
  function FromArray18(schema, references, value) {
    const elements = (0, index_5.IsArray)(value) ? value : [value];
    return elements.map((element) => Visit17(schema.items, references, element));
  }
  function FromBigInt6(schema, references, value) {
    return TryConvertBigInt2(value);
  }
  function FromBoolean6(schema, references, value) {
    return TryConvertBoolean2(value);
  }
  function FromDate8(schema, references, value) {
    return TryConvertDate2(value);
  }
  function FromImport11(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit17(target, [...references, ...definitions], value);
  }
  function FromInteger6(schema, references, value) {
    return TryConvertInteger2(value);
  }
  function FromIntersect19(schema, references, value) {
    return schema.allOf.reduce((value2, schema2) => Visit17(schema2, references, value2), value);
  }
  function FromLiteral7(schema, references, value) {
    return TryConvertLiteral2(schema, value);
  }
  function FromNull6(schema, references, value) {
    return TryConvertNull2(value);
  }
  function FromNumber6(schema, references, value) {
    return TryConvertNumber2(value);
  }
  function FromObject19(schema, references, value) {
    if (!(0, index_5.IsObject)(value))
      return value;
    for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
      if (!(0, index_5.HasPropertyKey)(value, propertyKey))
        continue;
      value[propertyKey] = Visit17(schema.properties[propertyKey], references, value[propertyKey]);
    }
    return value;
  }
  function FromRecord14(schema, references, value) {
    const isConvertable = (0, index_5.IsObject)(value);
    if (!isConvertable)
      return value;
    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[propertyKey];
    for (const [propKey, propValue] of Object.entries(value)) {
      value[propKey] = Visit17(property, references, propValue);
    }
    return value;
  }
  function FromRef15(schema, references, value) {
    return Visit17((0, index_3.Deref)(schema, references), references, value);
  }
  function FromString6(schema, references, value) {
    return TryConvertString2(value);
  }
  function FromSymbol6(schema, references, value) {
    return (0, index_5.IsString)(value) || (0, index_5.IsNumber)(value) ? Symbol(value) : value;
  }
  function FromThis11(schema, references, value) {
    return Visit17((0, index_3.Deref)(schema, references), references, value);
  }
  function FromTuple16(schema, references, value) {
    const isConvertable = (0, index_5.IsArray)(value) && !(0, index_5.IsUndefined)(schema.items);
    if (!isConvertable)
      return value;
    return value.map((value2, index) => {
      return index < schema.items.length ? Visit17(schema.items[index], references, value2) : value2;
    });
  }
  function FromUndefined6(schema, references, value) {
    return TryConvertUndefined2(value);
  }
  function FromUnion21(schema, references, value) {
    for (const subschema of schema.anyOf) {
      const converted = Visit17(subschema, references, (0, index_1.Clone)(value));
      if (!(0, index_2.Check)(subschema, references, converted))
        continue;
      return converted;
    }
    return value;
  }
  function Visit17(schema, references, value) {
    const references_ = (0, index_3.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema[index_4.Kind]) {
      case "Array":
        return FromArray18(schema_, references_, value);
      case "BigInt":
        return FromBigInt6(schema_, references_, value);
      case "Boolean":
        return FromBoolean6(schema_, references_, value);
      case "Date":
        return FromDate8(schema_, references_, value);
      case "Import":
        return FromImport11(schema_, references_, value);
      case "Integer":
        return FromInteger6(schema_, references_, value);
      case "Intersect":
        return FromIntersect19(schema_, references_, value);
      case "Literal":
        return FromLiteral7(schema_, references_, value);
      case "Null":
        return FromNull6(schema_, references_, value);
      case "Number":
        return FromNumber6(schema_, references_, value);
      case "Object":
        return FromObject19(schema_, references_, value);
      case "Record":
        return FromRecord14(schema_, references_, value);
      case "Ref":
        return FromRef15(schema_, references_, value);
      case "String":
        return FromString6(schema_, references_, value);
      case "Symbol":
        return FromSymbol6(schema_, references_, value);
      case "This":
        return FromThis11(schema_, references_, value);
      case "Tuple":
        return FromTuple16(schema_, references_, value);
      case "Undefined":
        return FromUndefined6(schema_, references_, value);
      case "Union":
        return FromUnion21(schema_, references_, value);
      default:
        return Default6(value);
    }
  }
  function Convert2(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/index.js
var require_convert2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_convert(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/decode/decode.js
var require_decode2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Decode = Decode2;
  var index_1 = require_transform3();
  var index_2 = require_check2();
  var index_3 = require_errors2();
  function Decode2(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    if (!(0, index_2.Check)(schema, references, value))
      throw new index_1.TransformDecodeCheckError(schema, value, (0, index_3.Errors)(schema, references, value).First());
    return (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformDecode)(schema, references, value) : value;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/decode/index.js
var require_decode3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_decode2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/default/default.js
var require_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Default = Default6;
  var index_1 = require_check2();
  var index_2 = require_clone4();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  var kind_1 = require_kind();
  function ValueOrDefault2(schema, value) {
    const defaultValue = (0, index_5.HasPropertyKey)(schema, "default") ? schema.default : undefined;
    const clone2 = (0, index_5.IsFunction)(defaultValue) ? defaultValue() : (0, index_2.Clone)(defaultValue);
    return (0, index_5.IsUndefined)(value) ? clone2 : (0, index_5.IsObject)(value) && (0, index_5.IsObject)(clone2) ? Object.assign(clone2, value) : value;
  }
  function HasDefaultProperty2(schema) {
    return (0, kind_1.IsKind)(schema) && "default" in schema;
  }
  function FromArray18(schema, references, value) {
    if ((0, index_5.IsArray)(value)) {
      for (let i = 0;i < value.length; i++) {
        value[i] = Visit17(schema.items, references, value[i]);
      }
      return value;
    }
    const defaulted = ValueOrDefault2(schema, value);
    if (!(0, index_5.IsArray)(defaulted))
      return defaulted;
    for (let i = 0;i < defaulted.length; i++) {
      defaulted[i] = Visit17(schema.items, references, defaulted[i]);
    }
    return defaulted;
  }
  function FromDate8(schema, references, value) {
    return (0, index_5.IsDate)(value) ? value : ValueOrDefault2(schema, value);
  }
  function FromImport11(schema, references, value) {
    const definitions = globalThis.Object.values(schema.$defs);
    const target = schema.$defs[schema.$ref];
    return Visit17(target, [...references, ...definitions], value);
  }
  function FromIntersect19(schema, references, value) {
    const defaulted = ValueOrDefault2(schema, value);
    return schema.allOf.reduce((acc, schema2) => {
      const next2 = Visit17(schema2, references, defaulted);
      return (0, index_5.IsObject)(next2) ? { ...acc, ...next2 } : next2;
    }, {});
  }
  function FromObject19(schema, references, value) {
    const defaulted = ValueOrDefault2(schema, value);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
    for (const key of knownPropertyKeys) {
      const propertyValue = Visit17(schema.properties[key], references, defaulted[key]);
      if ((0, index_5.IsUndefined)(propertyValue))
        continue;
      defaulted[key] = Visit17(schema.properties[key], references, defaulted[key]);
    }
    if (!HasDefaultProperty2(schema.additionalProperties))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKeys.includes(key))
        continue;
      defaulted[key] = Visit17(schema.additionalProperties, references, defaulted[key]);
    }
    return defaulted;
  }
  function FromRecord14(schema, references, value) {
    const defaulted = ValueOrDefault2(schema, value);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const additionalPropertiesSchema = schema.additionalProperties;
    const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
    const knownPropertyKey = new RegExp(propertyKeyPattern);
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (!(knownPropertyKey.test(key) && HasDefaultProperty2(propertySchema)))
        continue;
      defaulted[key] = Visit17(propertySchema, references, defaulted[key]);
    }
    if (!HasDefaultProperty2(additionalPropertiesSchema))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKey.test(key))
        continue;
      defaulted[key] = Visit17(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
  }
  function FromRef15(schema, references, value) {
    return Visit17((0, index_3.Deref)(schema, references), references, ValueOrDefault2(schema, value));
  }
  function FromThis11(schema, references, value) {
    return Visit17((0, index_3.Deref)(schema, references), references, value);
  }
  function FromTuple16(schema, references, value) {
    const defaulted = ValueOrDefault2(schema, value);
    if (!(0, index_5.IsArray)(defaulted) || (0, index_5.IsUndefined)(schema.items))
      return defaulted;
    const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
    for (let i = 0;i < max; i++) {
      if (i < items.length)
        defaulted[i] = Visit17(items[i], references, defaulted[i]);
    }
    return defaulted;
  }
  function FromUnion21(schema, references, value) {
    const defaulted = ValueOrDefault2(schema, value);
    for (const inner of schema.anyOf) {
      const result = Visit17(inner, references, (0, index_2.Clone)(defaulted));
      if ((0, index_1.Check)(inner, references, result)) {
        return result;
      }
    }
    return defaulted;
  }
  function Visit17(schema, references, value) {
    const references_ = (0, index_3.Pushref)(schema, references);
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
      case "Array":
        return FromArray18(schema_, references_, value);
      case "Date":
        return FromDate8(schema_, references_, value);
      case "Import":
        return FromImport11(schema_, references_, value);
      case "Intersect":
        return FromIntersect19(schema_, references_, value);
      case "Object":
        return FromObject19(schema_, references_, value);
      case "Record":
        return FromRecord14(schema_, references_, value);
      case "Ref":
        return FromRef15(schema_, references_, value);
      case "This":
        return FromThis11(schema_, references_, value);
      case "Tuple":
        return FromTuple16(schema_, references_, value);
      case "Union":
        return FromUnion21(schema_, references_, value);
      default:
        return ValueOrDefault2(schema_, value);
    }
  }
  function Default6(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/default/index.js
var require_default2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_default(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/pointer.js
var require_pointer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = undefined;
  exports.Format = Format2;
  exports.Set = Set5;
  exports.Delete = Delete5;
  exports.Has = Has4;
  exports.Get = Get4;
  var index_1 = require_error2();

  class ValuePointerRootSetError2 extends index_1.TypeBoxError {
    constructor(value, path, update) {
      super("Cannot set root value");
      this.value = value;
      this.path = path;
      this.update = update;
    }
  }
  exports.ValuePointerRootSetError = ValuePointerRootSetError2;

  class ValuePointerRootDeleteError2 extends index_1.TypeBoxError {
    constructor(value, path) {
      super("Cannot delete root value");
      this.value = value;
      this.path = path;
    }
  }
  exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError2;
  function Escape3(component) {
    return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function* Format2(pointer2) {
    if (pointer2 === "")
      return;
    let [start, end] = [0, 0];
    for (let i = 0;i < pointer2.length; i++) {
      const char = pointer2.charAt(i);
      if (char === "/") {
        if (i === 0) {
          start = i + 1;
        } else {
          end = i;
          yield Escape3(pointer2.slice(start, end));
          start = i + 1;
        }
      } else {
        end = i;
      }
    }
    yield Escape3(pointer2.slice(start));
  }
  function Set5(value, pointer2, update) {
    if (pointer2 === "")
      throw new ValuePointerRootSetError2(value, pointer2, update);
    let [owner, next2, key] = [null, value, ""];
    for (const component of Format2(pointer2)) {
      if (next2[component] === undefined)
        next2[component] = {};
      owner = next2;
      next2 = next2[component];
      key = component;
    }
    owner[key] = update;
  }
  function Delete5(value, pointer2) {
    if (pointer2 === "")
      throw new ValuePointerRootDeleteError2(value, pointer2);
    let [owner, next2, key] = [null, value, ""];
    for (const component of Format2(pointer2)) {
      if (next2[component] === undefined || next2[component] === null)
        return;
      owner = next2;
      next2 = next2[component];
      key = component;
    }
    if (Array.isArray(owner)) {
      const index = parseInt(key);
      owner.splice(index, 1);
    } else {
      delete owner[key];
    }
  }
  function Has4(value, pointer2) {
    if (pointer2 === "")
      return true;
    let [owner, next2, key] = [null, value, ""];
    for (const component of Format2(pointer2)) {
      if (next2[component] === undefined)
        return false;
      owner = next2;
      next2 = next2[component];
      key = component;
    }
    return Object.getOwnPropertyNames(owner).includes(key);
  }
  function Get4(value, pointer2) {
    if (pointer2 === "")
      return value;
    let current = value;
    for (const component of Format2(pointer2)) {
      if (current[component] === undefined)
        return;
      current = current[component];
    }
    return current;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/index.js
var require_pointer2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValuePointer = undefined;
  exports.ValuePointer = require_pointer();
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/equal.js
var require_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Equal = Equal2;
  var index_1 = require_guard2();
  function ObjectType6(left, right) {
    if (!(0, index_1.IsObject)(right))
      return false;
    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
    if (leftKeys.length !== rightKeys.length)
      return false;
    return leftKeys.every((key) => Equal2(left[key], right[key]));
  }
  function DateType4(left, right) {
    return (0, index_1.IsDate)(right) && left.getTime() === right.getTime();
  }
  function ArrayType6(left, right) {
    if (!(0, index_1.IsArray)(right) || left.length !== right.length)
      return false;
    return left.every((value, index) => Equal2(value, right[index]));
  }
  function TypedArrayType4(left, right) {
    if (!(0, index_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
      return false;
    return left.every((value, index) => Equal2(value, right[index]));
  }
  function ValueType4(left, right) {
    return left === right;
  }
  function Equal2(left, right) {
    if ((0, index_1.IsDate)(left))
      return DateType4(left, right);
    if ((0, index_1.IsTypedArray)(left))
      return TypedArrayType4(left, right);
    if ((0, index_1.IsArray)(left))
      return ArrayType6(left, right);
    if ((0, index_1.IsObject)(left))
      return ObjectType6(left, right);
    if ((0, index_1.IsValueType)(left))
      return ValueType4(left, right);
    throw new Error("ValueEquals: Unable to compare value");
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/delta.js
var require_delta = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueDiffError = exports.Edit = exports.Delete = exports.Update = exports.Insert = undefined;
  exports.Diff = Diff2;
  exports.Patch = Patch2;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone4();
  var equal_1 = require_equal();
  var index_4 = require_error2();
  var index_5 = require_literal2();
  var index_6 = require_object2();
  var index_7 = require_string2();
  var index_8 = require_unknown2();
  var index_9 = require_union2();
  exports.Insert = (0, index_6.Object)({
    type: (0, index_5.Literal)("insert"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports.Update = (0, index_6.Object)({
    type: (0, index_5.Literal)("update"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports.Delete = (0, index_6.Object)({
    type: (0, index_5.Literal)("delete"),
    path: (0, index_7.String)()
  });
  exports.Edit = (0, index_9.Union)([exports.Insert, exports.Update, exports.Delete]);

  class ValueDiffError2 extends index_4.TypeBoxError {
    constructor(value, message) {
      super(message);
      this.value = value;
    }
  }
  exports.ValueDiffError = ValueDiffError2;
  function CreateUpdate2(path, value) {
    return { type: "update", path, value };
  }
  function CreateInsert2(path, value) {
    return { type: "insert", path, value };
  }
  function CreateDelete2(path) {
    return { type: "delete", path };
  }
  function AssertDiffable2(value) {
    if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
      throw new ValueDiffError2(value, "Cannot diff objects with symbols");
  }
  function* ObjectType6(path, current, next2) {
    AssertDiffable2(current);
    AssertDiffable2(next2);
    if (!(0, index_1.IsStandardObject)(next2))
      return yield CreateUpdate2(path, next2);
    const currentKeys = globalThis.Object.getOwnPropertyNames(current);
    const nextKeys = globalThis.Object.getOwnPropertyNames(next2);
    for (const key of nextKeys) {
      if ((0, index_1.HasPropertyKey)(current, key))
        continue;
      yield CreateInsert2(`${path}/${key}`, next2[key]);
    }
    for (const key of currentKeys) {
      if (!(0, index_1.HasPropertyKey)(next2, key))
        continue;
      if ((0, equal_1.Equal)(current, next2))
        continue;
      yield* Visit17(`${path}/${key}`, current[key], next2[key]);
    }
    for (const key of currentKeys) {
      if ((0, index_1.HasPropertyKey)(next2, key))
        continue;
      yield CreateDelete2(`${path}/${key}`);
    }
  }
  function* ArrayType6(path, current, next2) {
    if (!(0, index_1.IsArray)(next2))
      return yield CreateUpdate2(path, next2);
    for (let i = 0;i < Math.min(current.length, next2.length); i++) {
      yield* Visit17(`${path}/${i}`, current[i], next2[i]);
    }
    for (let i = 0;i < next2.length; i++) {
      if (i < current.length)
        continue;
      yield CreateInsert2(`${path}/${i}`, next2[i]);
    }
    for (let i = current.length - 1;i >= 0; i--) {
      if (i < next2.length)
        continue;
      yield CreateDelete2(`${path}/${i}`);
    }
  }
  function* TypedArrayType4(path, current, next2) {
    if (!(0, index_1.IsTypedArray)(next2) || current.length !== next2.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next2).constructor.name)
      return yield CreateUpdate2(path, next2);
    for (let i = 0;i < Math.min(current.length, next2.length); i++) {
      yield* Visit17(`${path}/${i}`, current[i], next2[i]);
    }
  }
  function* ValueType4(path, current, next2) {
    if (current === next2)
      return;
    yield CreateUpdate2(path, next2);
  }
  function* Visit17(path, current, next2) {
    if ((0, index_1.IsStandardObject)(current))
      return yield* ObjectType6(path, current, next2);
    if ((0, index_1.IsArray)(current))
      return yield* ArrayType6(path, current, next2);
    if ((0, index_1.IsTypedArray)(current))
      return yield* TypedArrayType4(path, current, next2);
    if ((0, index_1.IsValueType)(current))
      return yield* ValueType4(path, current, next2);
    throw new ValueDiffError2(current, "Unable to diff value");
  }
  function Diff2(current, next2) {
    return [...Visit17("", current, next2)];
  }
  function IsRootUpdate2(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  }
  function IsIdentity2(edits) {
    return edits.length === 0;
  }
  function Patch2(current, edits) {
    if (IsRootUpdate2(edits)) {
      return (0, index_3.Clone)(edits[0].value);
    }
    if (IsIdentity2(edits)) {
      return (0, index_3.Clone)(current);
    }
    const clone2 = (0, index_3.Clone)(current);
    for (const edit of edits) {
      switch (edit.type) {
        case "insert": {
          index_2.ValuePointer.Set(clone2, edit.path, edit.value);
          break;
        }
        case "update": {
          index_2.ValuePointer.Set(clone2, edit.path, edit.value);
          break;
        }
        case "delete": {
          index_2.ValuePointer.Delete(clone2, edit.path);
          break;
        }
      }
    }
    return clone2;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/index.js
var require_delta2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_delta(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/encode/encode.js
var require_encode2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Encode = Encode2;
  var index_1 = require_transform3();
  var index_2 = require_check2();
  var index_3 = require_errors2();
  function Encode2(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    const encoded = (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformEncode)(schema, references, value) : value;
    if (!(0, index_2.Check)(schema, references, encoded))
      throw new index_1.TransformEncodeCheckError(schema, encoded, (0, index_3.Errors)(schema, references, encoded).First());
    return encoded;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/encode/index.js
var require_encode3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_encode2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/index.js
var require_equal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_equal(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/mutate.js
var require_mutate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueMutateError = undefined;
  exports.Mutate = Mutate2;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone4();
  var index_4 = require_error2();
  function IsStandardObject3(value) {
    return (0, index_1.IsObject)(value) && !(0, index_1.IsArray)(value);
  }

  class ValueMutateError2 extends index_4.TypeBoxError {
    constructor(message) {
      super(message);
    }
  }
  exports.ValueMutateError = ValueMutateError2;
  function ObjectType6(root, path, current, next2) {
    if (!IsStandardObject3(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next2));
    } else {
      const currentKeys = Object.getOwnPropertyNames(current);
      const nextKeys = Object.getOwnPropertyNames(next2);
      for (const currentKey of currentKeys) {
        if (!nextKeys.includes(currentKey)) {
          delete current[currentKey];
        }
      }
      for (const nextKey of nextKeys) {
        if (!currentKeys.includes(nextKey)) {
          current[nextKey] = null;
        }
      }
      for (const nextKey of nextKeys) {
        Visit17(root, `${path}/${nextKey}`, current[nextKey], next2[nextKey]);
      }
    }
  }
  function ArrayType6(root, path, current, next2) {
    if (!(0, index_1.IsArray)(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next2));
    } else {
      for (let index = 0;index < next2.length; index++) {
        Visit17(root, `${path}/${index}`, current[index], next2[index]);
      }
      current.splice(next2.length);
    }
  }
  function TypedArrayType4(root, path, current, next2) {
    if ((0, index_1.IsTypedArray)(current) && current.length === next2.length) {
      for (let i = 0;i < current.length; i++) {
        current[i] = next2[i];
      }
    } else {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next2));
    }
  }
  function ValueType4(root, path, current, next2) {
    if (current === next2)
      return;
    index_2.ValuePointer.Set(root, path, next2);
  }
  function Visit17(root, path, current, next2) {
    if ((0, index_1.IsArray)(next2))
      return ArrayType6(root, path, current, next2);
    if ((0, index_1.IsTypedArray)(next2))
      return TypedArrayType4(root, path, current, next2);
    if (IsStandardObject3(next2))
      return ObjectType6(root, path, current, next2);
    if ((0, index_1.IsValueType)(next2))
      return ValueType4(root, path, current, next2);
  }
  function IsNonMutableValue2(value) {
    return (0, index_1.IsTypedArray)(value) || (0, index_1.IsValueType)(value);
  }
  function IsMismatchedValue2(current, next2) {
    return IsStandardObject3(current) && (0, index_1.IsArray)(next2) || (0, index_1.IsArray)(current) && IsStandardObject3(next2);
  }
  function Mutate2(current, next2) {
    if (IsNonMutableValue2(current) || IsNonMutableValue2(next2))
      throw new ValueMutateError2("Only object and array types can be mutated at the root level");
    if (IsMismatchedValue2(current, next2))
      throw new ValueMutateError2("Cannot assign due type mismatch of assignable values");
    Visit17(current, "", current, next2);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/index.js
var require_mutate2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_mutate(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/parse/parse.js
var require_parse2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParseDefault = exports.ParseRegistry = exports.ParseError = undefined;
  exports.Parse = Parse2;
  var index_1 = require_error2();
  var index_2 = require_transform3();
  var index_3 = require_assert2();
  var index_4 = require_cast2();
  var index_5 = require_clean2();
  var index_6 = require_clone4();
  var index_7 = require_convert2();
  var index_8 = require_default2();
  var index_9 = require_guard2();

  class ParseError4 extends index_1.TypeBoxError {
    constructor(message) {
      super(message);
    }
  }
  exports.ParseError = ParseError4;
  var ParseRegistry2;
  (function(ParseRegistry3) {
    const registry = new Map([
      ["Assert", (type2, references, value) => {
        (0, index_3.Assert)(type2, references, value);
        return value;
      }],
      ["Cast", (type2, references, value) => (0, index_4.Cast)(type2, references, value)],
      ["Clean", (type2, references, value) => (0, index_5.Clean)(type2, references, value)],
      ["Clone", (_type, _references, value) => (0, index_6.Clone)(value)],
      ["Convert", (type2, references, value) => (0, index_7.Convert)(type2, references, value)],
      ["Decode", (type2, references, value) => (0, index_2.HasTransform)(type2, references) ? (0, index_2.TransformDecode)(type2, references, value) : value],
      ["Default", (type2, references, value) => (0, index_8.Default)(type2, references, value)],
      ["Encode", (type2, references, value) => (0, index_2.HasTransform)(type2, references) ? (0, index_2.TransformEncode)(type2, references, value) : value]
    ]);
    function Delete5(key) {
      registry.delete(key);
    }
    ParseRegistry3.Delete = Delete5;
    function Set5(key, callback) {
      registry.set(key, callback);
    }
    ParseRegistry3.Set = Set5;
    function Get4(key) {
      return registry.get(key);
    }
    ParseRegistry3.Get = Get4;
  })(ParseRegistry2 || (exports.ParseRegistry = ParseRegistry2 = {}));
  exports.ParseDefault = [
    "Clone",
    "Clean",
    "Default",
    "Convert",
    "Assert",
    "Decode"
  ];
  function ParseValue2(operations, type2, references, value) {
    return operations.reduce((value2, operationKey) => {
      const operation = ParseRegistry2.Get(operationKey);
      if ((0, index_9.IsUndefined)(operation))
        throw new ParseError4(`Unable to find Parse operation '${operationKey}'`);
      return operation(type2, references, value2);
    }, value);
  }
  function Parse2(...args) {
    const [operations, schema, references, value] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? (0, index_9.IsArray)(args[0]) ? [args[0], args[1], [], args[2]] : [exports.ParseDefault, args[0], args[1], args[2]] : args.length === 2 ? [exports.ParseDefault, args[0], [], args[1]] : (() => {
      throw new ParseError4("Invalid Arguments");
    })();
    return ParseValue2(operations, schema, references, value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/parse/index.js
var require_parse3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_parse2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/value/value.js
var require_value3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parse = exports.Mutate = exports.Hash = exports.Equal = exports.Encode = exports.Edit = exports.Patch = exports.Diff = exports.Default = exports.Decode = exports.Create = exports.Convert = exports.Clone = exports.Clean = exports.Check = exports.Cast = exports.Assert = exports.ValueErrorIterator = exports.Errors = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "Errors", { enumerable: true, get: function() {
    return index_1.Errors;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  var index_2 = require_assert2();
  Object.defineProperty(exports, "Assert", { enumerable: true, get: function() {
    return index_2.Assert;
  } });
  var index_3 = require_cast2();
  Object.defineProperty(exports, "Cast", { enumerable: true, get: function() {
    return index_3.Cast;
  } });
  var index_4 = require_check2();
  Object.defineProperty(exports, "Check", { enumerable: true, get: function() {
    return index_4.Check;
  } });
  var index_5 = require_clean2();
  Object.defineProperty(exports, "Clean", { enumerable: true, get: function() {
    return index_5.Clean;
  } });
  var index_6 = require_clone4();
  Object.defineProperty(exports, "Clone", { enumerable: true, get: function() {
    return index_6.Clone;
  } });
  var index_7 = require_convert2();
  Object.defineProperty(exports, "Convert", { enumerable: true, get: function() {
    return index_7.Convert;
  } });
  var index_8 = require_create3();
  Object.defineProperty(exports, "Create", { enumerable: true, get: function() {
    return index_8.Create;
  } });
  var index_9 = require_decode3();
  Object.defineProperty(exports, "Decode", { enumerable: true, get: function() {
    return index_9.Decode;
  } });
  var index_10 = require_default2();
  Object.defineProperty(exports, "Default", { enumerable: true, get: function() {
    return index_10.Default;
  } });
  var index_11 = require_delta2();
  Object.defineProperty(exports, "Diff", { enumerable: true, get: function() {
    return index_11.Diff;
  } });
  Object.defineProperty(exports, "Patch", { enumerable: true, get: function() {
    return index_11.Patch;
  } });
  Object.defineProperty(exports, "Edit", { enumerable: true, get: function() {
    return index_11.Edit;
  } });
  var index_12 = require_encode3();
  Object.defineProperty(exports, "Encode", { enumerable: true, get: function() {
    return index_12.Encode;
  } });
  var index_13 = require_equal2();
  Object.defineProperty(exports, "Equal", { enumerable: true, get: function() {
    return index_13.Equal;
  } });
  var index_14 = require_hash2();
  Object.defineProperty(exports, "Hash", { enumerable: true, get: function() {
    return index_14.Hash;
  } });
  var index_15 = require_mutate2();
  Object.defineProperty(exports, "Mutate", { enumerable: true, get: function() {
    return index_15.Mutate;
  } });
  var index_16 = require_parse3();
  Object.defineProperty(exports, "Parse", { enumerable: true, get: function() {
    return index_16.Parse;
  } });
});

// node_modules/@sinclair/typebox/build/cjs/value/value/index.js
var require_value4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = undefined;
  exports.Value = require_value3();
});

// node_modules/@sinclair/typebox/build/cjs/value/index.js
var require_value5 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_guard2(), exports);
  __exportStar(require_assert2(), exports);
  __exportStar(require_cast2(), exports);
  __exportStar(require_check2(), exports);
  __exportStar(require_clean2(), exports);
  __exportStar(require_clone4(), exports);
  __exportStar(require_convert2(), exports);
  __exportStar(require_create3(), exports);
  __exportStar(require_decode3(), exports);
  __exportStar(require_default2(), exports);
  __exportStar(require_delta2(), exports);
  __exportStar(require_encode3(), exports);
  __exportStar(require_equal2(), exports);
  __exportStar(require_hash2(), exports);
  __exportStar(require_mutate2(), exports);
  __exportStar(require_parse3(), exports);
  __exportStar(require_pointer2(), exports);
  __exportStar(require_transform3(), exports);
  var index_2 = require_value4();
  Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
    return index_2.Value;
  } });
});

// node_modules/elysia/dist/cjs/formats.js
var require_formats = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var formats_exports = {};
  __export2(formats_exports, {
    fullFormats: () => fullFormats2
  });
  module.exports = __toCommonJS2(formats_exports);
  var fullFormats2 = {
    date: date2,
    time: getTime2(true),
    "date-time": getDateTime2(true),
    "iso-time": getTime2(false),
    "iso-date-time": getDateTime2(false),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: uri2,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: regex2,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte: byte2,
    int32: { type: "number", validate: validateInt322 },
    int64: { type: "number", validate: validateInt642 },
    float: { type: "number", validate: validateNumber2 },
    double: { type: "number", validate: validateNumber2 },
    password: true,
    binary: true
  };
  function isLeapYear2(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  var DATE2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date2(str) {
    const matches = DATE2.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear2(year) ? 29 : DAYS2[month]);
  }
  var TIME2 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function getTime2(strictTimeZone) {
    return function time(str) {
      const matches = TIME2.exec(str);
      if (!matches)
        return false;
      const hr = +matches[1];
      const min = +matches[2];
      const sec = +matches[3];
      const tz = matches[4];
      const tzSign = matches[5] === "-" ? -1 : 1;
      const tzH = +(matches[6] || 0);
      const tzM = +(matches[7] || 0);
      if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
        return false;
      if (hr <= 23 && min <= 59 && sec < 60)
        return true;
      const utcMin = min - tzM * tzSign;
      const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
      return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
    };
  }
  var DATE_TIME_SEPARATOR2 = /t|\s/i;
  function getDateTime2(strictTimeZone) {
    const time = getTime2(strictTimeZone);
    return function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR2);
      return dateTime.length === 2 && date2(dateTime[0]) && time(dateTime[1]);
    };
  }
  var NOT_URI_FRAGMENT2 = /\/|:/;
  var URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri2(str) {
    return NOT_URI_FRAGMENT2.test(str) && URI2.test(str);
  }
  var BYTE2 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte2(str) {
    BYTE2.lastIndex = 0;
    return BYTE2.test(str);
  }
  var MIN_INT322 = -(2 ** 31);
  var MAX_INT322 = 2 ** 31 - 1;
  function validateInt322(value) {
    return Number.isInteger(value) && value <= MAX_INT322 && value >= MIN_INT322;
  }
  function validateInt642(value) {
    return Number.isInteger(value);
  }
  function validateNumber2() {
    return true;
  }
  var Z_ANCHOR2 = /[^\\]\\Z/;
  function regex2(str) {
    if (Z_ANCHOR2.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
});

// node_modules/elysia/dist/cjs/utils.js
var require_utils3 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var utils_exports = {};
  __export2(utils_exports, {
    ELYSIA_FORM_DATA: () => ELYSIA_FORM_DATA3,
    ELYSIA_REQUEST_ID: () => ELYSIA_REQUEST_ID3,
    InvertedStatusMap: () => InvertedStatusMap3,
    PromiseGroup: () => PromiseGroup2,
    StatusMap: () => StatusMap3,
    asHookType: () => asHookType2,
    checksum: () => checksum3,
    cloneInference: () => cloneInference3,
    coercePrimitiveRoot: () => coercePrimitiveRoot2,
    compressHistoryHook: () => compressHistoryHook2,
    createMacroManager: () => createMacroManager2,
    decompressHistoryHook: () => decompressHistoryHook,
    deduplicateChecksum: () => deduplicateChecksum3,
    encodePath: () => encodePath2,
    filterGlobalHook: () => filterGlobalHook2,
    fnToContainer: () => fnToContainer2,
    form: () => form3,
    getCookieValidator: () => getCookieValidator2,
    getLoosePath: () => getLoosePath2,
    getResponseSchemaValidator: () => getResponseSchemaValidator3,
    getSchemaValidator: () => getSchemaValidator3,
    hasHeaderShorthand: () => hasHeaderShorthand2,
    injectChecksum: () => injectChecksum2,
    isClass: () => isClass2,
    isNotEmpty: () => isNotEmpty2,
    isNumericString: () => isNumericString2,
    lifeCycleToFn: () => lifeCycleToFn2,
    localHookToLifeCycleStore: () => localHookToLifeCycleStore2,
    mergeCookie: () => mergeCookie2,
    mergeDeep: () => mergeDeep2,
    mergeHook: () => mergeHook3,
    mergeLifeCycle: () => mergeLifeCycle2,
    mergeObjectArray: () => mergeObjectArray3,
    mergeResponse: () => mergeResponse2,
    mergeSchemaValidator: () => mergeSchemaValidator2,
    primitiveHooks: () => primitiveHooks2,
    promoteEvent: () => promoteEvent2,
    randomId: () => randomId2,
    redirect: () => redirect3,
    replaceSchemaType: () => replaceSchemaType3,
    replaceUrlPath: () => replaceUrlPath3,
    signCookie: () => signCookie2,
    stringToStructureCoercions: () => stringToStructureCoercions2,
    traceBackMacro: () => traceBackMacro2,
    unsignCookie: () => unsignCookie2
  });
  module.exports = __toCommonJS2(utils_exports);
  var import_typebox5 = require_cjs2();
  var import_value27 = require_value5();
  var import_compiler3 = require_compiler2();
  var import_type_system4 = require_type_system();
  var import_error34 = require_error3();
  var hasHeaderShorthand2 = "toJSON" in new Headers;
  var replaceUrlPath3 = (url, pathname) => {
    const urlObject = new URL(url);
    urlObject.pathname = pathname;
    return urlObject.toString();
  };
  var isClass2 = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString && v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty2(Object.getPrototypeOf(v));
  var isObject2 = (item) => item && typeof item === "object" && !Array.isArray(item);
  var mergeDeep2 = (target, source, {
    skipKeys,
    override = true
  } = {}) => {
    if (!isObject2(target) || !isObject2(source))
      return target;
    for (const [key, value] of Object.entries(source)) {
      if (skipKeys?.includes(key))
        continue;
      if (!isObject2(value) || !(key in target) || isClass2(value)) {
        if (override || !(key in target))
          target[key] = value;
        continue;
      }
      target[key] = mergeDeep2(target[key], value, { skipKeys, override });
    }
    return target;
  };
  var mergeCookie2 = (a, b) => {
    const v = mergeDeep2(Object.assign({}, a), b, {
      skipKeys: ["properties"]
    });
    if ("properties" in v)
      delete v.properties;
    return v;
  };
  var mergeObjectArray3 = (a = [], b = []) => {
    if (!a)
      return;
    if (!b)
      return a;
    const array = [];
    const checksums = [];
    if (!Array.isArray(a))
      a = [a];
    if (!Array.isArray(b))
      b = [b];
    for (const item of a) {
      array.push(item);
      if (item.checksum)
        checksums.push(item.checksum);
    }
    for (const item of b)
      if (!checksums.includes(item.checksum))
        array.push(item);
    return array;
  };
  var primitiveHooks2 = [
    "start",
    "request",
    "parse",
    "transform",
    "resolve",
    "beforeHandle",
    "afterHandle",
    "mapResponse",
    "afterResponse",
    "trace",
    "error",
    "stop",
    "body",
    "headers",
    "params",
    "query",
    "response",
    "type",
    "detail"
  ];
  var primitiveHookMap2 = primitiveHooks2.reduce((acc, x) => (acc[x] = true, acc), {});
  var mergeResponse2 = (a, b) => {
    const isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every(isNumericString2);
    if (isRecordNumber(a) && isRecordNumber(b))
      return Object.assign(a, b);
    else if (a && !isRecordNumber(a) && isRecordNumber(b))
      return Object.assign({ 200: a }, b);
    return b ?? a;
  };
  var mergeSchemaValidator2 = (a, b) => {
    return {
      body: b?.body ?? a?.body,
      headers: b?.headers ?? a?.headers,
      params: b?.params ?? a?.params,
      query: b?.query ?? a?.query,
      cookie: b?.cookie ?? a?.cookie,
      response: mergeResponse2(a?.response, b?.response)
    };
  };
  var mergeHook3 = (a, b) => {
    const { resolve: resolveA, ...restA } = a ?? {};
    const { resolve: resolveB, ...restB } = b ?? {};
    return {
      ...restA,
      ...restB,
      body: b?.body ?? a?.body,
      headers: b?.headers ?? a?.headers,
      params: b?.params ?? a?.params,
      query: b?.query ?? a?.query,
      cookie: b?.cookie ?? a?.cookie,
      response: mergeResponse2(a?.response, b?.response),
      type: a?.type || b?.type,
      detail: mergeDeep2(b?.detail ?? {}, a?.detail ?? {}),
      parse: mergeObjectArray3(a?.parse, b?.parse),
      transform: mergeObjectArray3(a?.transform, b?.transform),
      beforeHandle: mergeObjectArray3(mergeObjectArray3(fnToContainer2(resolveA, "resolve"), a?.beforeHandle), mergeObjectArray3(fnToContainer2(resolveB, "resolve"), b?.beforeHandle)),
      afterHandle: mergeObjectArray3(a?.afterHandle, b?.afterHandle),
      mapResponse: mergeObjectArray3(a?.mapResponse, b?.mapResponse),
      afterResponse: mergeObjectArray3(a?.afterResponse, b?.afterResponse),
      trace: mergeObjectArray3(a?.trace, b?.trace),
      error: mergeObjectArray3(a?.error, b?.error)
    };
  };
  var replaceSchemaType3 = (schema, options, root = true) => {
    if (!Array.isArray(options)) {
      options.original = schema;
      return _replaceSchemaType2(schema, options, root);
    }
    for (const option of options) {
      option.original = schema;
      schema = _replaceSchemaType2(schema, option, root);
    }
    return schema;
  };
  var _replaceSchemaType2 = (schema, options, root = true) => {
    if (!schema)
      return schema;
    if (options.untilObjectFound && !root && schema.type === "object")
      return schema;
    const fromSymbol = options.from[import_typebox5.Kind];
    if (schema.oneOf) {
      for (let i = 0;i < schema.oneOf.length; i++)
        schema.oneOf[i] = _replaceSchemaType2(schema.oneOf[i], options, root);
      return schema;
    }
    if (schema.anyOf) {
      for (let i = 0;i < schema.anyOf.length; i++)
        schema.anyOf[i] = _replaceSchemaType2(schema.anyOf[i], options, root);
      return schema;
    }
    if (schema.allOf) {
      for (let i = 0;i < schema.allOf.length; i++)
        schema.allOf[i] = _replaceSchemaType2(schema.allOf[i], options, root);
      return schema;
    }
    if (schema.not)
      return _replaceSchemaType2(schema.not, options, root);
    const isRoot = root && !!options.excludeRoot;
    if (schema[import_typebox5.Kind] === fromSymbol) {
      const { anyOf, oneOf, allOf, not, properties: properties2, items, ...rest } = schema;
      const to = options.to(rest);
      if (!to)
        return schema;
      let transform2;
      const composeProperties = (v) => {
        if (properties2 && v.type === "object") {
          const newProperties = {};
          for (const [key, value2] of Object.entries(properties2))
            newProperties[key] = _replaceSchemaType2(value2, options, false);
          return {
            ...rest,
            ...v,
            properties: newProperties
          };
        }
        if (items && v.type === "array")
          return {
            ...rest,
            ...v,
            items: _replaceSchemaType2(items, options, false)
          };
        const value = {
          ...rest,
          ...v
        };
        delete value["required"];
        if (properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}") {
          transform2 = import_type_system4.t.ObjectString(properties2, rest);
          value.default = JSON.stringify(import_value27.Value.Create(import_type_system4.t.Object(properties2)));
          value.properties = properties2;
        }
        if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]") {
          transform2 = import_type_system4.t.ArrayString(items, rest);
          value.default = JSON.stringify(import_value27.Value.Create(import_type_system4.t.Array(items)));
          value.items = items;
        }
        return value;
      };
      if (isRoot) {
        if (properties2) {
          const newProperties = {};
          for (const [key, value] of Object.entries(properties2))
            newProperties[key] = _replaceSchemaType2(value, options, false);
          return {
            ...rest,
            properties: newProperties
          };
        } else if (items?.map)
          return {
            ...rest,
            items: items.map((v) => _replaceSchemaType2(v, options, false))
          };
        return rest;
      }
      if (to.anyOf)
        for (let i = 0;i < to.anyOf.length; i++)
          to.anyOf[i] = composeProperties(to.anyOf[i]);
      else if (to.oneOf)
        for (let i = 0;i < to.oneOf.length; i++)
          to.oneOf[i] = composeProperties(to.oneOf[i]);
      else if (to.allOf)
        for (let i = 0;i < to.allOf.length; i++)
          to.allOf[i] = composeProperties(to.allOf[i]);
      else if (to.not)
        to.not = composeProperties(to.not);
      if (transform2)
        to[import_typebox5.TransformKind] = transform2[import_typebox5.TransformKind];
      if (to.anyOf || to.oneOf || to.allOf || to.not)
        return to;
      if (properties2) {
        const newProperties = {};
        for (const [key, value] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType2(value, options, false);
        return {
          ...rest,
          ...to,
          properties: newProperties
        };
      } else if (items?.map)
        return {
          ...rest,
          ...to,
          items: items.map((v) => _replaceSchemaType2(v, options, false))
        };
      return {
        ...rest,
        ...to
      };
    }
    const properties = schema?.properties;
    if (properties && root && options.rootOnly !== true)
      for (const [key, value] of Object.entries(properties)) {
        switch (value[import_typebox5.Kind]) {
          case fromSymbol:
            const { anyOf, oneOf, allOf, not, type: type2, ...rest } = value;
            const to = options.to(rest);
            if (!to)
              return schema;
            if (to.anyOf)
              for (let i = 0;i < to.anyOf.length; i++)
                to.anyOf[i] = { ...rest, ...to.anyOf[i] };
            else if (to.oneOf)
              for (let i = 0;i < to.oneOf.length; i++)
                to.oneOf[i] = { ...rest, ...to.oneOf[i] };
            else if (to.allOf)
              for (let i = 0;i < to.allOf.length; i++)
                to.allOf[i] = { ...rest, ...to.allOf[i] };
            else if (to.not)
              to.not = { ...rest, ...to.not };
            properties[key] = {
              ...rest,
              ..._replaceSchemaType2(rest, options, false)
            };
            break;
          case "Object":
          case "Union":
            properties[key] = _replaceSchemaType2(value, options, false);
            break;
          default:
            if (Array.isArray(value.items)) {
              for (let i = 0;i < value.items.length; i++) {
                value.items[i] = _replaceSchemaType2(value.items[i], options, false);
              }
            } else if (value.anyOf || value.oneOf || value.allOf || value.not)
              properties[key] = _replaceSchemaType2(value, options, false);
            else if (value.type === "array") {
              value.items = _replaceSchemaType2(value.items, options, false);
            }
            break;
        }
      }
    return schema;
  };
  var createCleaner2 = (schema) => (value) => {
    if (typeof value === "object")
      try {
        return import_value27.Value.Clean(schema, structuredClone(value));
      } catch {
        try {
          return import_value27.Value.Clean(schema, value);
        } catch {
          return value;
        }
      }
    return value;
  };
  var getSchemaValidator3 = (s, {
    models = {},
    dynamic = false,
    modules,
    normalize = false,
    additionalProperties = false,
    coerce = false,
    additionalCoerce = []
  } = {
    modules: import_type_system4.t.Module({})
  }) => {
    if (!s)
      return;
    let schema;
    if (typeof s !== "string")
      schema = s;
    else {
      const isArray = s.endsWith("[]");
      const key = isArray ? s.substring(0, s.length - 2) : s;
      schema = modules.Import(key) ?? models[key];
      if (isArray)
        schema = import_type_system4.t.Array(schema);
    }
    if (!schema)
      return;
    if (coerce || additionalCoerce) {
      if (coerce)
        schema = replaceSchemaType3(schema, [
          {
            from: import_type_system4.t.Ref(""),
            to: (options) => modules.Import(options["$ref"])
          },
          {
            from: import_type_system4.t.Number(),
            to: (options) => import_type_system4.t.Numeric(options),
            untilObjectFound: true
          },
          {
            from: import_type_system4.t.Boolean(),
            to: (options) => import_type_system4.t.BooleanString(options),
            untilObjectFound: true
          },
          ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]
        ]);
      else {
        schema = replaceSchemaType3(schema, [
          {
            from: import_type_system4.t.Ref(""),
            to: (options) => modules.Import(options["$ref"])
          },
          ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]
        ]);
      }
    }
    if (schema.type === "object" && "additionalProperties" in schema === false)
      schema.additionalProperties = additionalProperties;
    if (dynamic) {
      const validator = {
        schema,
        references: "",
        checkFunc: () => {},
        code: "",
        Check: (value) => import_value27.Value.Check(schema, value),
        Errors: (value) => import_value27.Value.Errors(schema, value),
        Code: () => "",
        Clean: createCleaner2(schema),
        Decode: (value) => import_value27.Value.Decode(schema, value),
        Encode: (value) => import_value27.Value.Encode(schema, value)
      };
      if (normalize && schema.additionalProperties === false)
        validator.Clean = createCleaner2(schema);
      if (schema.config) {
        validator.config = schema.config;
        if (validator?.schema?.config)
          delete validator.schema.config;
      }
      validator.parse = (v) => {
        try {
          return validator.Decode(v);
        } catch (error3) {
          throw [...validator.Errors(v)].map(import_error34.mapValueError);
        }
      };
      validator.safeParse = (v) => {
        try {
          return { success: true, data: validator.Decode(v), error: null };
        } catch (error3) {
          const errors = [...compiled.Errors(v)].map(import_error34.mapValueError);
          return {
            success: false,
            data: null,
            error: errors[0]?.summary,
            errors
          };
        }
      };
      return validator;
    }
    const compiled = import_compiler3.TypeCompiler.Compile(schema, Object.values(models));
    compiled.Clean = createCleaner2(schema);
    if (schema.config) {
      compiled.config = schema.config;
      if (compiled?.schema?.config)
        delete compiled.schema.config;
    }
    compiled.parse = (v) => {
      try {
        return compiled.Decode(v);
      } catch (error3) {
        throw [...compiled.Errors(v)].map(import_error34.mapValueError);
      }
    };
    compiled.safeParse = (v) => {
      try {
        return { success: true, data: compiled.Decode(v), error: null };
      } catch (error3) {
        const errors = [...compiled.Errors(v)].map(import_error34.mapValueError);
        return {
          success: false,
          data: null,
          error: errors[0]?.summary,
          errors
        };
      }
    };
    return compiled;
  };
  var getResponseSchemaValidator3 = (s, {
    models = {},
    modules,
    dynamic = false,
    normalize = false,
    additionalProperties = false
  }) => {
    if (!s)
      return;
    let maybeSchemaOrRecord;
    if (typeof s !== "string")
      maybeSchemaOrRecord = s;
    else {
      const isArray = s.endsWith("[]");
      const key = isArray ? s.substring(0, s.length - 2) : s;
      maybeSchemaOrRecord = modules.Import(key) ?? models[key];
      if (isArray)
        maybeSchemaOrRecord = import_type_system4.t.Array(maybeSchemaOrRecord);
    }
    if (!maybeSchemaOrRecord)
      return;
    const compile = (schema, references) => {
      if (dynamic)
        return {
          schema,
          references: "",
          checkFunc: () => {},
          code: "",
          Check: (value) => import_value27.Value.Check(schema, value),
          Errors: (value) => import_value27.Value.Errors(schema, value),
          Code: () => "",
          Clean: createCleaner2(schema),
          Decode: (value) => import_value27.Value.Decode(schema, value),
          Encode: (value) => import_value27.Value.Encode(schema, value)
        };
      const compiledValidator = import_compiler3.TypeCompiler.Compile(schema, references);
      if (normalize && schema.additionalProperties === false)
        compiledValidator.Clean = createCleaner2(schema);
      return compiledValidator;
    };
    const modelValues = Object.values(models);
    if (import_typebox5.Kind in maybeSchemaOrRecord) {
      if ("additionalProperties" in maybeSchemaOrRecord === false)
        maybeSchemaOrRecord.additionalProperties = additionalProperties;
      return {
        200: compile(maybeSchemaOrRecord, modelValues)
      };
    }
    const record = {};
    Object.keys(maybeSchemaOrRecord).forEach((status) => {
      const maybeNameOrSchema = maybeSchemaOrRecord[+status];
      if (typeof maybeNameOrSchema === "string") {
        if (maybeNameOrSchema in models) {
          const schema = models[maybeNameOrSchema];
          schema.type === "object" && "additionalProperties" in schema;
          record[+status] = import_typebox5.Kind in schema ? compile(schema, modelValues) : schema;
        }
        return;
      }
      if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
        maybeNameOrSchema.additionalProperties = additionalProperties;
      record[+status] = import_typebox5.Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, modelValues) : maybeNameOrSchema;
    });
    return record;
  };
  var isBun3 = typeof Bun !== "undefined";
  var hasHash2 = isBun3 && typeof Bun.hash === "function";
  var checksum3 = (s) => {
    if (hasHash2)
      return Bun.hash(s);
    let h = 9;
    for (let i = 0;i < s.length; )
      h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
    return h = h ^ h >>> 9;
  };
  var _stringToStructureCoercions2;
  var stringToStructureCoercions2 = () => {
    if (!_stringToStructureCoercions2) {
      _stringToStructureCoercions2 = [
        {
          from: import_type_system4.t.Object({}),
          to: () => import_type_system4.t.ObjectString({}),
          excludeRoot: true
        },
        {
          from: import_type_system4.t.Array(import_type_system4.t.Any()),
          to: () => import_type_system4.t.ArrayString(import_type_system4.t.Any())
        }
      ];
    }
    return _stringToStructureCoercions2;
  };
  var _coercePrimitiveRoot2;
  var coercePrimitiveRoot2 = () => {
    if (!_coercePrimitiveRoot2)
      _coercePrimitiveRoot2 = [
        {
          from: import_type_system4.t.Number(),
          to: (options) => import_type_system4.t.Numeric(options),
          rootOnly: true
        },
        {
          from: import_type_system4.t.Boolean(),
          to: (options) => import_type_system4.t.BooleanString(options),
          rootOnly: true
        }
      ];
    return _coercePrimitiveRoot2;
  };
  var getCookieValidator2 = ({
    validator,
    modules,
    defaultConfig = {},
    config,
    dynamic,
    models
  }) => {
    let cookieValidator = getSchemaValidator3(validator, {
      modules,
      dynamic,
      models,
      additionalProperties: true,
      coerce: true,
      additionalCoerce: stringToStructureCoercions2()
    });
    if (isNotEmpty2(defaultConfig)) {
      if (cookieValidator) {
        cookieValidator.config = mergeCookie2(cookieValidator.config, config);
      } else {
        cookieValidator = getSchemaValidator3(import_type_system4.t.Cookie({}), {
          modules,
          dynamic,
          models,
          additionalProperties: true
        });
        cookieValidator.config = defaultConfig;
      }
    }
    return cookieValidator;
  };
  var injectChecksum2 = (checksum22, x) => {
    if (!x)
      return;
    if (!Array.isArray(x)) {
      const fn = x;
      if (checksum22 && !fn.checksum)
        fn.checksum = checksum22;
      if (fn.scope === "scoped")
        fn.scope = "local";
      return fn;
    }
    const fns = [...x];
    for (const fn of fns) {
      if (checksum22 && !fn.checksum)
        fn.checksum = checksum22;
      if (fn.scope === "scoped")
        fn.scope = "local";
    }
    return fns;
  };
  var mergeLifeCycle2 = (a, b, checksum22) => {
    return {
      start: mergeObjectArray3(a.start, injectChecksum2(checksum22, b?.start)),
      request: mergeObjectArray3(a.request, injectChecksum2(checksum22, b?.request)),
      parse: mergeObjectArray3(a.parse, injectChecksum2(checksum22, b?.parse)),
      transform: mergeObjectArray3(a.transform, injectChecksum2(checksum22, b?.transform)),
      beforeHandle: mergeObjectArray3(mergeObjectArray3(fnToContainer2(a.resolve, "resolve"), a.beforeHandle), injectChecksum2(checksum22, mergeObjectArray3(fnToContainer2(b?.resolve, "resolve"), b?.beforeHandle))),
      afterHandle: mergeObjectArray3(a.afterHandle, injectChecksum2(checksum22, b?.afterHandle)),
      mapResponse: mergeObjectArray3(a.mapResponse, injectChecksum2(checksum22, b?.mapResponse)),
      afterResponse: mergeObjectArray3(a.afterResponse, injectChecksum2(checksum22, b?.afterResponse)),
      trace: mergeObjectArray3(a.trace, injectChecksum2(checksum22, b?.trace)),
      error: mergeObjectArray3(a.error, injectChecksum2(checksum22, b?.error)),
      stop: mergeObjectArray3(a.stop, injectChecksum2(checksum22, b?.stop))
    };
  };
  var asHookType2 = (fn, inject, { skipIfHasType = false } = {}) => {
    if (!fn)
      return fn;
    if (!Array.isArray(fn)) {
      if (skipIfHasType)
        fn.scope ??= inject;
      else
        fn.scope = inject;
      return fn;
    }
    for (const x of fn)
      if (skipIfHasType)
        x.scope ??= inject;
      else
        x.scope = inject;
    return fn;
  };
  var filterGlobal2 = (fn) => {
    if (!fn)
      return fn;
    if (!Array.isArray(fn))
      switch (fn.scope) {
        case "global":
        case "scoped":
          return { ...fn };
        default:
          return { fn };
      }
    const array = [];
    for (const x of fn)
      switch (x.scope) {
        case "global":
        case "scoped":
          array.push({
            ...x
          });
          break;
      }
    return array;
  };
  var filterGlobalHook2 = (hook) => {
    return {
      ...hook,
      type: hook?.type,
      detail: hook?.detail,
      parse: filterGlobal2(hook?.parse),
      transform: filterGlobal2(hook?.transform),
      beforeHandle: filterGlobal2(hook?.beforeHandle),
      afterHandle: filterGlobal2(hook?.afterHandle),
      mapResponse: filterGlobal2(hook?.mapResponse),
      afterResponse: filterGlobal2(hook?.afterResponse),
      error: filterGlobal2(hook?.error),
      trace: filterGlobal2(hook?.trace)
    };
  };
  var StatusMap3 = {
    Continue: 100,
    "Switching Protocols": 101,
    Processing: 102,
    "Early Hints": 103,
    OK: 200,
    Created: 201,
    Accepted: 202,
    "Non-Authoritative Information": 203,
    "No Content": 204,
    "Reset Content": 205,
    "Partial Content": 206,
    "Multi-Status": 207,
    "Already Reported": 208,
    "Multiple Choices": 300,
    "Moved Permanently": 301,
    Found: 302,
    "See Other": 303,
    "Not Modified": 304,
    "Temporary Redirect": 307,
    "Permanent Redirect": 308,
    "Bad Request": 400,
    Unauthorized: 401,
    "Payment Required": 402,
    Forbidden: 403,
    "Not Found": 404,
    "Method Not Allowed": 405,
    "Not Acceptable": 406,
    "Proxy Authentication Required": 407,
    "Request Timeout": 408,
    Conflict: 409,
    Gone: 410,
    "Length Required": 411,
    "Precondition Failed": 412,
    "Payload Too Large": 413,
    "URI Too Long": 414,
    "Unsupported Media Type": 415,
    "Range Not Satisfiable": 416,
    "Expectation Failed": 417,
    "I'm a teapot": 418,
    "Misdirected Request": 421,
    "Unprocessable Content": 422,
    Locked: 423,
    "Failed Dependency": 424,
    "Too Early": 425,
    "Upgrade Required": 426,
    "Precondition Required": 428,
    "Too Many Requests": 429,
    "Request Header Fields Too Large": 431,
    "Unavailable For Legal Reasons": 451,
    "Internal Server Error": 500,
    "Not Implemented": 501,
    "Bad Gateway": 502,
    "Service Unavailable": 503,
    "Gateway Timeout": 504,
    "HTTP Version Not Supported": 505,
    "Variant Also Negotiates": 506,
    "Insufficient Storage": 507,
    "Loop Detected": 508,
    "Not Extended": 510,
    "Network Authentication Required": 511
  };
  var InvertedStatusMap3 = Object.fromEntries(Object.entries(StatusMap3).map(([k, v]) => [v, k]));
  function removeTrailingEquals2(digest) {
    let trimmedDigest = digest;
    while (trimmedDigest.endsWith("=")) {
      trimmedDigest = trimmedDigest.slice(0, -1);
    }
    return trimmedDigest;
  }
  var encoder2 = new TextEncoder;
  var signCookie2 = async (val, secret) => {
    if (typeof val !== "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (secret === null)
      throw new TypeError("Secret key must be provided.");
    const secretKey = await crypto.subtle.importKey("raw", encoder2.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    const hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder2.encode(val));
    return val + "." + removeTrailingEquals2(Buffer.from(hmacBuffer).toString("base64"));
  };
  var unsignCookie2 = async (input, secret) => {
    if (typeof input !== "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (secret === null)
      throw new TypeError("Secret key must be provided.");
    const tentativeValue = input.slice(0, input.lastIndexOf("."));
    const expectedInput = await signCookie2(tentativeValue, secret);
    return expectedInput === input ? tentativeValue : false;
  };
  var traceBackMacro2 = (extension, property, manage) => {
    if (!extension || typeof extension !== "object" || !property)
      return;
    for (const [key, value] of Object.entries(property)) {
      if (key in primitiveHookMap2 || !(key in extension))
        continue;
      const v = extension[key];
      if (typeof v === "function") {
        const hook = v(value);
        if (typeof hook === "object") {
          for (const [k, v2] of Object.entries(hook)) {
            manage(k)({
              fn: v2
            });
          }
        }
      }
      delete property[key];
    }
  };
  var createMacroManager2 = ({
    globalHook,
    localHook
  }) => (stackName) => (type2, fn) => {
    if (typeof type2 === "function")
      type2 = {
        fn: type2
      };
    if (stackName === "resolve") {
      type2 = {
        ...type2,
        subType: "resolve"
      };
    }
    if ("fn" in type2 || Array.isArray(type2)) {
      if (!localHook[stackName])
        localHook[stackName] = [];
      if (typeof localHook[stackName] === "function")
        localHook[stackName] = [localHook[stackName]];
      if (Array.isArray(type2))
        localHook[stackName] = localHook[stackName].concat(type2);
      else
        localHook[stackName].push(type2);
      return;
    }
    const { insert = "after", stack = "local" } = type2;
    if (typeof fn === "function")
      fn = { fn };
    if (stack === "global") {
      if (!Array.isArray(fn)) {
        if (insert === "before") {
          globalHook[stackName].unshift(fn);
        } else {
          globalHook[stackName].push(fn);
        }
      } else {
        if (insert === "before") {
          globalHook[stackName] = fn.concat(globalHook[stackName]);
        } else {
          globalHook[stackName] = globalHook[stackName].concat(fn);
        }
      }
    } else {
      if (!localHook[stackName])
        localHook[stackName] = [];
      if (typeof localHook[stackName] === "function")
        localHook[stackName] = [localHook[stackName]];
      if (!Array.isArray(fn)) {
        if (insert === "before") {
          localHook[stackName].unshift(fn);
        } else {
          localHook[stackName].push(fn);
        }
      } else {
        if (insert === "before") {
          localHook[stackName] = fn.concat(localHook[stackName]);
        } else {
          localHook[stackName] = localHook[stackName].concat(fn);
        }
      }
    }
  };
  var parseNumericString2 = (message) => {
    if (typeof message === "number")
      return message;
    if (message.length < 16) {
      if (message.trim().length === 0)
        return null;
      const length = Number(message);
      if (Number.isNaN(length))
        return null;
      return length;
    }
    if (message.length === 16) {
      if (message.trim().length === 0)
        return null;
      const number = Number(message);
      if (Number.isNaN(number) || number.toString() !== message)
        return null;
      return number;
    }
    return null;
  };
  var isNumericString2 = (message) => parseNumericString2(message) !== null;

  class PromiseGroup2 {
    constructor(onError = console.error) {
      this.onError = onError;
      this.root = null;
      this.promises = [];
    }
    get size() {
      return this.promises.length;
    }
    add(promise) {
      this.promises.push(promise);
      this.root ||= this.drain();
      return promise;
    }
    async drain() {
      while (this.promises.length > 0) {
        try {
          await this.promises[0];
        } catch (error3) {
          this.onError(error3);
        }
        this.promises.shift();
      }
      this.root = null;
    }
    then(onfulfilled, onrejected) {
      return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
    }
  }
  var fnToContainer2 = (fn, subType) => {
    if (!fn)
      return fn;
    if (!Array.isArray(fn)) {
      if (typeof fn === "function" || typeof fn === "string")
        return subType ? { fn, subType } : { fn };
      else if ("fn" in fn)
        return fn;
    }
    const fns = [];
    for (const x of fn) {
      if (typeof x === "function" || typeof x === "string")
        fns.push(subType ? { fn: x, subType } : { fn: x });
      else if ("fn" in x)
        fns.push(x);
    }
    return fns;
  };
  var localHookToLifeCycleStore2 = (a) => {
    return {
      ...a,
      start: fnToContainer2(a?.start),
      request: fnToContainer2(a?.request),
      parse: fnToContainer2(a?.parse),
      transform: fnToContainer2(a?.transform),
      beforeHandle: fnToContainer2(a?.beforeHandle),
      afterHandle: fnToContainer2(a?.afterHandle),
      mapResponse: fnToContainer2(a?.mapResponse),
      afterResponse: fnToContainer2(a?.afterResponse),
      trace: fnToContainer2(a?.trace),
      error: fnToContainer2(a?.error),
      stop: fnToContainer2(a?.stop)
    };
  };
  var lifeCycleToFn2 = (a) => {
    const hook = {};
    if (a.start?.map)
      hook.start = a.start.map((x) => x.fn);
    if (a.request?.map)
      hook.request = a.request.map((x) => x.fn);
    if (a.parse?.map)
      hook.parse = a.parse.map((x) => x.fn);
    if (a.transform?.map)
      hook.transform = a.transform.map((x) => x.fn);
    if (a.beforeHandle?.map)
      hook.beforeHandle = a.beforeHandle.map((x) => x.fn);
    if (a.afterHandle?.map)
      hook.afterHandle = a.afterHandle.map((x) => x.fn);
    if (a.mapResponse?.map)
      hook.mapResponse = a.mapResponse.map((x) => x.fn);
    if (a.afterResponse?.map)
      hook.afterResponse = a.afterResponse.map((x) => x.fn);
    if (a.trace?.map)
      hook.trace = a.trace.map((x) => x.fn);
    if (a.error?.map)
      hook.error = a.error.map((x) => x.fn);
    if (a.stop?.map)
      hook.stop = a.stop.map((x) => x.fn);
    return hook;
  };
  var cloneInference3 = (inference) => ({
    body: inference.body,
    cookie: inference.cookie,
    headers: inference.headers,
    query: inference.query,
    set: inference.set,
    server: inference.server,
    request: inference.request,
    route: inference.route
  });
  var redirect3 = (url, status = 302) => Response.redirect(url, status);
  var ELYSIA_FORM_DATA3 = Symbol("ElysiaFormData");
  var ELYSIA_REQUEST_ID3 = Symbol("ElysiaRequestId");
  var form3 = (items) => {
    const formData = new FormData;
    for (const [key, value] of Object.entries(items)) {
      if (Array.isArray(value)) {
        for (const v of value) {
          if (value instanceof File)
            formData.append(key, value, value.name);
          formData.append(key, v);
        }
        continue;
      }
      if (value instanceof File)
        formData.append(key, value, value.name);
      formData.append(key, value);
    }
    return formData;
  };
  var randomId2 = () => {
    const uuid = crypto.randomUUID();
    return uuid.slice(0, 8) + uuid.slice(24, 32);
  };
  var deduplicateChecksum3 = (array) => {
    const hashes = [];
    for (let i = 0;i < array.length; i++) {
      const item = array[i];
      if (item.checksum) {
        if (hashes.includes(item.checksum)) {
          array.splice(i, 1);
          i--;
        }
        hashes.push(item.checksum);
      }
    }
    return array;
  };
  var promoteEvent2 = (events, as = "scoped") => {
    if (!events)
      return;
    if (as === "scoped") {
      for (const event of events)
        if ("scope" in event && event.scope === "local")
          event.scope = "scoped";
      return;
    }
    for (const event of events)
      if ("scope" in event)
        event.scope = "global";
  };
  var getLoosePath2 = (path) => {
    if (path.charCodeAt(path.length - 1) === 47)
      return path.slice(0, path.length - 1);
    return path + "/";
  };
  var isNotEmpty2 = (obj) => {
    if (!obj)
      return false;
    for (const x in obj)
      return true;
    return false;
  };
  var isEmptyHookProperty2 = (prop) => {
    if (Array.isArray(prop))
      return prop.length === 0;
    return !prop;
  };
  var compressHistoryHook2 = (hook) => {
    const history = { ...hook };
    if (isEmptyHookProperty2(hook.afterHandle))
      delete history.afterHandle;
    if (isEmptyHookProperty2(hook.afterResponse))
      delete history.afterResponse;
    if (isEmptyHookProperty2(hook.beforeHandle))
      delete history.beforeHandle;
    if (isEmptyHookProperty2(hook.error))
      delete history.error;
    if (isEmptyHookProperty2(hook.mapResponse))
      delete history.mapResponse;
    if (isEmptyHookProperty2(hook.parse))
      delete history.parse;
    if (isEmptyHookProperty2(hook.request))
      delete history.request;
    if (isEmptyHookProperty2(hook.start))
      delete history.start;
    if (isEmptyHookProperty2(hook.stop))
      delete history.stop;
    if (isEmptyHookProperty2(hook.trace))
      delete history.trace;
    if (isEmptyHookProperty2(hook.transform))
      delete history.transform;
    if (!history.type)
      delete history.type;
    if (history.detail && !Object.keys(history.detail).length)
      delete history.detail;
    if (!history.body)
      delete history.body;
    if (!history.cookie)
      delete history.cookie;
    if (!history.headers)
      delete history.headers;
    if (!history.query)
      delete history.query;
    if (!history.params)
      delete history.params;
    if (!history.response)
      delete history.response;
    return history;
  };
  var decompressHistoryHook = (hook) => {
    const history = { ...hook };
    if (!history.afterHandle)
      history.afterHandle = [];
    if (!history.afterResponse)
      history.afterResponse = [];
    if (!history.beforeHandle)
      history.beforeHandle = [];
    if (!history.error)
      history.error = [];
    if (!history.mapResponse)
      history.mapResponse = [];
    if (!history.parse)
      history.parse = [];
    if (!history.request)
      history.request = [];
    if (!history.start)
      history.start = [];
    if (!history.stop)
      history.stop = [];
    if (!history.trace)
      history.trace = [];
    if (!history.transform)
      history.transform = [];
    if (!history.body)
      history.body = undefined;
    if (!history.cookie)
      history.cookie = undefined;
    if (!history.headers)
      history.headers = undefined;
    if (!history.query)
      history.query = undefined;
    if (!history.params)
      history.params = undefined;
    if (!history.response)
      history.response = undefined;
    return history;
  };
  var encodePath2 = (path, { dynamic = false } = {}) => {
    let encoded = encodeURIComponent(path).replace(/%2F/g, "/");
    if (dynamic)
      encoded = encoded.replace(/%3A/g, ":").replace(/%3F/g, "?");
    return encoded;
  };
});

// node_modules/elysia/dist/cjs/error.js
var require_error3 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var error_exports = {};
  __export2(error_exports, {
    ERROR_CODE: () => ERROR_CODE3,
    ElysiaCustomStatusResponse: () => ElysiaCustomStatusResponse2,
    InternalServerError: () => InternalServerError3,
    InvalidCookieSignature: () => InvalidCookieSignature3,
    NotFoundError: () => NotFoundError3,
    ParseError: () => ParseError4,
    ValidationError: () => ValidationError3,
    error: () => error3,
    isProduction: () => isProduction2,
    mapValueError: () => mapValueError3
  });
  module.exports = __toCommonJS2(error_exports);
  var import_value27 = require_value5();
  var import_utils15 = require_utils3();
  var env4 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
  var ERROR_CODE3 = Symbol("ElysiaErrorCode");
  var isProduction2 = (env4?.NODE_ENV ?? env4?.ENV) === "production";

  class ElysiaCustomStatusResponse2 {
    constructor(code, response) {
      const res = response ?? (code in import_utils15.InvertedStatusMap ? import_utils15.InvertedStatusMap[code] : code);
      this.code = import_utils15.StatusMap[code] ?? code;
      this.response = res;
    }
  }
  var error3 = (code, response) => new ElysiaCustomStatusResponse2(code, response);

  class InternalServerError3 extends Error {
    constructor(message) {
      super(message ?? "INTERNAL_SERVER_ERROR");
      this.code = "INTERNAL_SERVER_ERROR";
      this.status = 500;
    }
  }

  class NotFoundError3 extends Error {
    constructor(message) {
      super(message ?? "NOT_FOUND");
      this.code = "NOT_FOUND";
      this.status = 404;
    }
  }

  class ParseError4 extends Error {
    constructor() {
      super("Bad Request");
      this.code = "PARSE";
      this.status = 400;
    }
  }

  class InvalidCookieSignature3 extends Error {
    constructor(key, message) {
      super(message ?? `"${key}" has invalid cookie signature`);
      this.key = key;
      this.code = "INVALID_COOKIE_SIGNATURE";
      this.status = 400;
    }
  }
  var mapValueError3 = (error22) => {
    if (!error22)
      return {
        summary: undefined
      };
    const { message, path, value, type: type2 } = error22;
    const property = path.slice(1).replaceAll("/", ".");
    const isRoot = path === "";
    switch (type2) {
      case 42:
        return {
          ...error22,
          summary: isRoot ? `Value should not be provided` : `Property '${property}' should not be provided`
        };
      case 45:
        return {
          ...error22,
          summary: isRoot ? `Value is missing` : `Property '${property}' is missing`
        };
      case 50:
        const quoteIndex = message.indexOf("'");
        const format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
        return {
          ...error22,
          summary: isRoot ? `Value should be an email` : `Property '${property}' should be ${format}`
        };
      case 54:
        return {
          ...error22,
          summary: `${message.slice(0, 9)} property '${property}' to be ${message.slice(8)} but found: ${value}`
        };
      case 62:
        const union = error22.schema.anyOf.map((x) => `'${x?.format ?? x.type}'`).join(", ");
        return {
          ...error22,
          summary: isRoot ? `Value should be one of ${union}` : `Property '${property}' should be one of: ${union}`
        };
      default:
        return { summary: message, ...error22 };
    }
  };

  class ValidationError3 extends Error {
    constructor(type2, validator, value) {
      if (value && typeof value === "object" && value instanceof ElysiaCustomStatusResponse2)
        value = value.response;
      const error22 = isProduction2 ? undefined : ("Errors" in validator) ? validator.Errors(value).First() : import_value27.Value.Errors(validator, value).First();
      const customError = error22?.schema?.message || error22?.schema?.error !== undefined ? typeof error22.schema.error === "function" ? error22.schema.error({
        type: type2,
        validator,
        value,
        get errors() {
          return [...validator.Errors(value)].map(mapValueError3);
        }
      }) : error22.schema.error : undefined;
      const accessor = error22?.path || "root";
      let message = "";
      if (customError !== undefined) {
        message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
      } else if (isProduction2) {
        message = JSON.stringify({
          type: "validation",
          on: type2,
          summary: mapValueError3(error22).summary,
          message: error22?.message,
          found: value
        });
      } else {
        const schema = validator?.schema ?? validator;
        const errors = "Errors" in validator ? [...validator.Errors(value)].map(mapValueError3) : [...import_value27.Value.Errors(validator, value)].map(mapValueError3);
        let expected;
        try {
          expected = import_value27.Value.Create(schema);
        } catch (error32) {
          expected = {
            type: "Could not create expected value",
            message: error32?.message,
            error: error32
          };
        }
        message = JSON.stringify({
          type: "validation",
          on: type2,
          summary: mapValueError3(error22).summary,
          property: accessor,
          message: error22?.message,
          expected,
          found: value,
          errors
        }, null, 2);
      }
      super(message);
      this.type = type2;
      this.validator = validator;
      this.value = value;
      this.code = "VALIDATION";
      this.status = 422;
      Object.setPrototypeOf(this, ValidationError3.prototype);
    }
    get all() {
      return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError3) : [...import_value27.Value.Errors(this.validator, this.value)].map(mapValueError3);
    }
    static simplifyModel(validator) {
      const model = "schema" in validator ? validator.schema : validator;
      try {
        return import_value27.Value.Create(model);
      } catch {
        return model;
      }
    }
    get model() {
      return ValidationError3.simplifyModel(this.validator);
    }
    toResponse(headers) {
      return new Response(this.message, {
        status: 400,
        headers: {
          ...headers,
          "content-type": "application/json"
        }
      });
    }
  }
});

// node_modules/elysia/dist/cjs/type-system.js
var require_type_system = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var type_system_exports = {};
  __export2(type_system_exports, {
    ElysiaType: () => ElysiaType2,
    FormatRegistry: () => import_typebox32.FormatRegistry,
    TypeCheck: () => import_compiler22.TypeCheck,
    TypeCompiler: () => import_compiler22.TypeCompiler,
    TypeRegistry: () => import_typebox32.TypeRegistry,
    TypeSystem: () => import_system4.TypeSystem,
    TypeSystemDuplicateFormat: () => import_system4.TypeSystemDuplicateFormat,
    TypeSystemDuplicateTypeKind: () => import_system4.TypeSystemDuplicateTypeKind,
    TypeSystemPolicy: () => import_system4.TypeSystemPolicy,
    t: () => t3
  });
  module.exports = __toCommonJS2(type_system_exports);
  var import_typebox5 = require_cjs2();
  var import_typebox22 = require_cjs2();
  var import_compiler3 = require_compiler2();
  var import_value27 = require_value5();
  var import_formats2 = require_formats();
  var import_error34 = require_error3();
  var import_system4 = require_system2();
  var import_typebox32 = require_cjs2();
  var import_compiler22 = require_compiler2();
  var isISO86012 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
  var isFormalDate2 = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
  var isShortenDate2 = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
  var _validateDate2 = import_formats2.fullFormats.date;
  var _validateDateTime2 = import_formats2.fullFormats["date-time"];
  if (!import_typebox5.FormatRegistry.Has("date"))
    import_typebox5.FormatRegistry.Set("date", (value) => {
      const temp = value.replace(/"/g, "");
      if (isISO86012.test(temp) || isFormalDate2.test(temp) || isShortenDate2.test(temp) || _validateDate2(temp)) {
        const date2 = new Date(temp);
        if (!Number.isNaN(date2.getTime()))
          return true;
      }
      return false;
    });
  if (!import_typebox5.FormatRegistry.Has("date-time"))
    import_typebox5.FormatRegistry.Set("date-time", (value) => {
      const temp = value.replace(/"/g, "");
      if (isISO86012.test(temp) || isFormalDate2.test(temp) || isShortenDate2.test(temp) || _validateDateTime2(temp)) {
        const date2 = new Date(temp);
        if (!Number.isNaN(date2.getTime()))
          return true;
      }
      return false;
    });
  Object.entries(import_formats2.fullFormats).forEach((formatEntry) => {
    const [formatName, formatValue] = formatEntry;
    if (!import_typebox5.FormatRegistry.Has(formatName)) {
      if (formatValue instanceof RegExp)
        import_typebox5.FormatRegistry.Set(formatName, (value) => formatValue.test(value));
      else if (typeof formatValue === "function")
        import_typebox5.FormatRegistry.Set(formatName, formatValue);
    }
  });
  var t3 = Object.assign({}, import_typebox5.Type);
  var parseFileUnit2 = (size) => {
    if (typeof size === "string")
      switch (size.slice(-1)) {
        case "k":
          return +size.slice(0, size.length - 1) * 1024;
        case "m":
          return +size.slice(0, size.length - 1) * 1048576;
        default:
          return +size;
      }
    return size;
  };
  var checkFileExtension2 = (type2, extension) => {
    if (type2.startsWith(extension))
      return true;
    return extension.charCodeAt(extension.length - 1) === 42 && extension.charCodeAt(extension.length - 2) === 47 && type2.startsWith(extension.slice(0, -1));
  };
  var validateFile2 = (options, value) => {
    if (!(value instanceof Blob))
      return false;
    if (options.minSize && value.size < parseFileUnit2(options.minSize))
      return false;
    if (options.maxSize && value.size > parseFileUnit2(options.maxSize))
      return false;
    if (options.extension) {
      if (typeof options.extension === "string")
        return checkFileExtension2(value.type, options.extension);
      for (let i = 0;i < options.extension.length; i++)
        if (checkFileExtension2(value.type, options.extension[i]))
          return true;
      return false;
    }
    return true;
  };
  var File3 = getOrSetType2("File", validateFile2);
  var Files2 = getOrSetType2("Files", (options, value) => {
    if (!Array.isArray(value))
      return validateFile2(options, value);
    if (options.minItems && value.length < options.minItems)
      return false;
    if (options.maxItems && value.length > options.maxItems)
      return false;
    for (let i = 0;i < value.length; i++)
      if (!validateFile2(options, value[i]))
        return false;
    return true;
  });
  if (!import_typebox5.FormatRegistry.Has("numeric"))
    import_typebox5.FormatRegistry.Set("numeric", (value) => !!value && !isNaN(+value));
  if (!import_typebox5.FormatRegistry.Has("integer"))
    import_typebox5.FormatRegistry.Set("integer", (value) => !!value && Number.isInteger(+value));
  if (!import_typebox5.FormatRegistry.Has("boolean"))
    import_typebox5.FormatRegistry.Set("boolean", (value) => value === "true" || value === "false");
  if (!import_typebox5.FormatRegistry.Has("ObjectString"))
    import_typebox5.FormatRegistry.Set("ObjectString", (value) => {
      let start = value.charCodeAt(0);
      if (start === 9 || start === 10 || start === 32)
        start = value.trimStart().charCodeAt(0);
      if (start !== 123 && start !== 91)
        return false;
      try {
        JSON.parse(value);
        return true;
      } catch {
        return false;
      }
    });
  if (!import_typebox5.FormatRegistry.Has("ArrayString"))
    import_typebox5.FormatRegistry.Set("ArrayString", (value) => {
      let start = value.charCodeAt(0);
      if (start === 9 || start === 10 || start === 32)
        start = value.trimStart().charCodeAt(0);
      if (start !== 123 && start !== 91)
        return false;
      try {
        JSON.parse(value);
        return true;
      } catch {
        return false;
      }
    });
  if (!import_typebox5.TypeRegistry.Has("UnionEnum"))
    import_typebox5.TypeRegistry.Set("UnionEnum", (schema, value) => {
      return (typeof value === "number" || typeof value === "string" || value === null) && schema.enum.includes(value);
    });
  var ElysiaType2 = {
    Numeric: (property) => {
      const schema = import_typebox5.Type.Number(property);
      return t3.Transform(t3.Union([
        t3.String({
          format: "numeric",
          default: 0
        }),
        t3.Number(property)
      ], property)).Decode((value) => {
        const number = +value;
        if (isNaN(number))
          return value;
        if (property && !import_value27.Value.Check(schema, number))
          throw new import_error34.ValidationError("property", schema, number);
        return number;
      }).Encode((value) => value);
    },
    Integer: (property) => {
      const schema = import_typebox5.Type.Integer(property);
      return t3.Transform(t3.Union([
        t3.String({
          format: "integer",
          default: 0
        }),
        import_typebox5.Type.Integer(property)
      ], property)).Decode((value) => {
        const number = +value;
        if (!import_value27.Value.Check(schema, number))
          throw new import_error34.ValidationError("property", schema, number);
        return number;
      }).Encode((value) => value);
    },
    Date: (property) => {
      const schema = import_typebox5.Type.Date(property);
      const _default = property?.default ? new Date(property.default) : undefined;
      return t3.Transform(t3.Union([
        import_typebox5.Type.Date(property),
        t3.String({
          format: "date",
          default: _default?.toISOString()
        }),
        t3.String({
          format: "date-time",
          default: _default?.toISOString()
        }),
        t3.Number({ default: _default?.getTime() })
      ], property)).Decode((value) => {
        if (typeof value === "number") {
          const date22 = new Date(value);
          if (!import_value27.Value.Check(schema, date22))
            throw new import_error34.ValidationError("property", schema, date22);
          return date22;
        }
        if (value instanceof Date)
          return value;
        const date2 = new Date(value);
        if (!date2 || isNaN(date2.getTime()))
          throw new import_error34.ValidationError("property", schema, date2);
        if (!import_value27.Value.Check(schema, date2))
          throw new import_error34.ValidationError("property", schema, date2);
        return date2;
      }).Encode((value) => value.toISOString());
    },
    BooleanString: (property) => {
      const schema = import_typebox5.Type.Boolean(property);
      return t3.Transform(t3.Union([
        t3.Boolean(property),
        t3.String({
          format: "boolean",
          default: false
        })
      ], property)).Decode((value) => {
        if (typeof value === "string")
          return value === "true";
        if (value !== undefined && !import_value27.Value.Check(schema, value))
          throw new import_error34.ValidationError("property", schema, value);
        return value;
      }).Encode((value) => value);
    },
    ObjectString: (properties, options) => {
      const schema = t3.Object(properties, options);
      const defaultValue = JSON.stringify(import_value27.Value.Create(schema));
      let compiler;
      try {
        compiler = import_compiler3.TypeCompiler.Compile(schema);
      } catch {}
      return t3.Transform(t3.Union([
        t3.String({
          format: "ObjectString",
          default: defaultValue
        }),
        schema
      ])).Decode((value) => {
        if (typeof value === "string") {
          if (value.charCodeAt(0) !== 123)
            throw new import_error34.ValidationError("property", schema, value);
          try {
            value = JSON.parse(value);
          } catch {
            throw new import_error34.ValidationError("property", schema, value);
          }
          if (compiler) {
            if (!compiler.Check(value))
              throw new import_error34.ValidationError("property", schema, value);
            return compiler.Decode(value);
          }
          if (!import_value27.Value.Check(schema, value))
            throw new import_error34.ValidationError("property", schema, value);
          return import_value27.Value.Decode(schema, value);
        }
        return value;
      }).Encode((value) => {
        if (typeof value === "string")
          try {
            value = JSON.parse(value);
          } catch {
            throw new import_error34.ValidationError("property", schema, value);
          }
        if (!import_value27.Value.Check(schema, value))
          throw new import_error34.ValidationError("property", schema, value);
        return JSON.stringify(value);
      });
    },
    ArrayString: (children = t3.String(), options) => {
      const schema = t3.Array(children, options);
      let compiler;
      try {
        compiler = import_compiler3.TypeCompiler.Compile(schema);
      } catch {}
      const decode3 = (value, isProperty = false) => {
        if (value.charCodeAt(0) === 91) {
          try {
            value = JSON.parse(value);
          } catch {
            throw new import_error34.ValidationError("property", schema, value);
          }
          if (compiler) {
            if (!compiler.Check(value))
              throw new import_error34.ValidationError("property", schema, value);
            return compiler.Decode(value);
          }
          if (!import_value27.Value.Check(schema, value))
            throw new import_error34.ValidationError("property", schema, value);
          return import_value27.Value.Decode(schema, value);
        }
        if (value.indexOf(",") !== -1) {
          const newValue = value.split(",").map((v) => v.trim());
          if (compiler) {
            if (!compiler.Check(newValue))
              throw new import_error34.ValidationError("property", schema, value);
            return compiler.Decode(newValue);
          }
          if (!import_value27.Value.Check(schema, newValue))
            throw new import_error34.ValidationError("property", schema, newValue);
          return import_value27.Value.Decode(schema, newValue);
        }
        if (isProperty)
          return value;
        throw new import_error34.ValidationError("property", schema, value);
      };
      return t3.Transform(t3.Union([
        t3.String({
          format: "ArrayString",
          default: options?.default
        }),
        schema
      ])).Decode((value) => {
        if (Array.isArray(value)) {
          let values = [];
          for (let i = 0;i < value.length; i++) {
            const v = value[i];
            if (typeof v === "string") {
              const t22 = decode3(v, true);
              if (Array.isArray(t22))
                values = values.concat(t22);
              else
                values.push(t22);
              continue;
            }
            values.push(v);
          }
          return values;
        }
        if (typeof value === "string")
          return decode3(value);
        return value;
      }).Encode((value) => {
        if (typeof value === "string")
          try {
            value = JSON.parse(value);
          } catch {
            throw new import_error34.ValidationError("property", schema, value);
          }
        if (!import_value27.Value.Check(schema, value))
          throw new import_error34.ValidationError("property", schema, value);
        return JSON.stringify(value);
      });
    },
    File: File3,
    Files: (options = {}) => t3.Transform(Files2(options)).Decode((value) => {
      if (Array.isArray(value))
        return value;
      return [value];
    }).Encode((value) => value),
    Nullable: (schema, options) => t3.Union([schema, t3.Null()], options),
    MaybeEmpty: (schema, options) => t3.Union([schema, t3.Null(), t3.Undefined()], options),
    Cookie: (properties, {
      domain,
      expires,
      httpOnly,
      maxAge,
      path,
      priority,
      sameSite,
      secure,
      secrets,
      sign,
      ...options
    } = {}) => {
      const v = t3.Object(properties, options);
      v.config = {
        domain,
        expires,
        httpOnly,
        maxAge,
        path,
        priority,
        sameSite,
        secure,
        secrets,
        sign
      };
      return v;
    },
    UnionEnum: (values, options = {}) => {
      const type2 = values.every((value) => typeof value === "string") ? { type: "string" } : values.every((value) => typeof value === "number") ? { type: "number" } : values.every((value) => value === null) ? { type: "null" } : {};
      if (values.some((x) => typeof x === "object" && x !== null))
        throw new Error("This type does not support objects or arrays");
      return {
        default: values[0],
        ...options,
        [import_typebox22.Kind]: "UnionEnum",
        ...type2,
        enum: values
      };
    }
  };
  t3.BooleanString = ElysiaType2.BooleanString;
  t3.ObjectString = ElysiaType2.ObjectString;
  t3.ArrayString = ElysiaType2.ArrayString;
  t3.Numeric = ElysiaType2.Numeric;
  t3.Integer = ElysiaType2.Integer;
  t3.File = (arg = {}) => ElysiaType2.File({
    default: "File",
    ...arg,
    extension: arg?.type,
    type: "string",
    format: "binary"
  });
  t3.Files = (arg = {}) => ElysiaType2.Files({
    ...arg,
    elysiaMeta: "Files",
    default: "Files",
    extension: arg?.type,
    type: "array",
    items: {
      ...arg,
      default: "Files",
      type: "string",
      format: "binary"
    }
  });
  t3.Nullable = (schema) => ElysiaType2.Nullable(schema);
  t3.MaybeEmpty = ElysiaType2.MaybeEmpty;
  t3.Cookie = ElysiaType2.Cookie;
  t3.Date = ElysiaType2.Date;
  t3.UnionEnum = ElysiaType2.UnionEnum;
  function getOrSetType2(kind, func) {
    if (!import_typebox5.TypeRegistry.Has(kind)) {
      import_typebox5.TypeRegistry.Set(kind, func);
    }
    return (options = {}) => (0, import_typebox22.Unsafe)({ ...options, [import_typebox22.Kind]: kind });
  }
});

// node_modules/elysia/dist/cjs/sucrose.js
var require_sucrose = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var sucrose_exports = {};
  __export2(sucrose_exports, {
    bracketPairRange: () => bracketPairRange2,
    bracketPairRangeReverse: () => bracketPairRangeReverse2,
    extractMainParameter: () => extractMainParameter2,
    findAlias: () => findAlias2,
    findParameterReference: () => findParameterReference2,
    hasReturn: () => hasReturn2,
    inferBodyReference: () => inferBodyReference2,
    isContextPassToFunction: () => isContextPassToFunction2,
    removeColonAlias: () => removeColonAlias2,
    removeDefaultParameter: () => removeDefaultParameter,
    retrieveRootParamters: () => retrieveRootParamters2,
    separateFunction: () => separateFunction2,
    sucrose: () => sucrose2
  });
  module.exports = __toCommonJS2(sucrose_exports);
  var hasReturn2 = (fn) => {
    const fnLiteral = typeof fn === "object" ? fn.fn.toString() : typeof fn === "string" ? fn.toString() : fn;
    const parenthesisEnd = fnLiteral.indexOf(")");
    if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
      return true;
    }
    return fnLiteral.includes("return");
  };
  var separateFunction2 = (code) => {
    if (code.startsWith("async"))
      code = code.slice(5);
    code = code.trimStart();
    let index = -1;
    if (code.charCodeAt(0) === 40) {
      index = code.indexOf("=>", code.indexOf(")"));
      if (index !== -1) {
        let bracketEndIndex = index;
        while (bracketEndIndex > 0)
          if (code.charCodeAt(--bracketEndIndex) === 41)
            break;
        let body = code.slice(index + 2);
        if (body.charCodeAt(0) === 32)
          body = body.trimStart();
        return [
          code.slice(1, bracketEndIndex),
          body,
          {
            isArrowReturn: body.charCodeAt(0) !== 123
          }
        ];
      }
    }
    if (/^(\w+)=>/g.test(code)) {
      index = code.indexOf("=>");
      if (index !== -1) {
        let body = code.slice(index + 2);
        if (body.charCodeAt(0) === 32)
          body = body.trimStart();
        return [
          code.slice(0, index),
          body,
          {
            isArrowReturn: body.charCodeAt(0) !== 123
          }
        ];
      }
    }
    if (code.startsWith("function")) {
      index = code.indexOf("(");
      const end = code.indexOf(")");
      return [
        code.slice(index + 1, end),
        code.slice(end + 2),
        {
          isArrowReturn: false
        }
      ];
    }
    const start = code.indexOf("(");
    if (start !== -1) {
      const sep2 = code.indexOf(`
`, 2);
      const parameter = code.slice(0, sep2);
      const end = parameter.lastIndexOf(")") + 1;
      const body = code.slice(sep2 + 1);
      return [
        parameter.slice(start, end),
        "{" + body,
        {
          isArrowReturn: false
        }
      ];
    }
    const x = code.split(`
`, 2);
    return [x[0], x[1], { isArrowReturn: false }];
  };
  var bracketPairRange2 = (parameter) => {
    const start = parameter.indexOf("{");
    if (start === -1)
      return [-1, 0];
    let end = start + 1;
    let deep = 1;
    for (;end < parameter.length; end++) {
      const char = parameter.charCodeAt(end);
      if (char === 123)
        deep++;
      else if (char === 125)
        deep--;
      if (deep === 0)
        break;
    }
    if (deep !== 0)
      return [0, parameter.length];
    return [start, end + 1];
  };
  var bracketPairRangeReverse2 = (parameter) => {
    const end = parameter.lastIndexOf("}");
    if (end === -1)
      return [-1, 0];
    let start = end - 1;
    let deep = 1;
    for (;start >= 0; start--) {
      const char = parameter.charCodeAt(start);
      if (char === 125)
        deep++;
      else if (char === 123)
        deep--;
      if (deep === 0)
        break;
    }
    if (deep !== 0)
      return [-1, 0];
    return [start, end + 1];
  };
  var removeColonAlias2 = (parameter) => {
    while (true) {
      const start = parameter.indexOf(":");
      if (start === -1)
        break;
      let end = parameter.indexOf(",", start);
      if (end === -1)
        end = parameter.indexOf("}", start) - 1;
      if (end === -2)
        end = parameter.length;
      parameter = parameter.slice(0, start) + parameter.slice(end);
    }
    return parameter;
  };
  var retrieveRootParamters2 = (parameter) => {
    let hasParenthesis = false;
    if (parameter.charCodeAt(0) === 40)
      parameter = parameter.slice(1, -1);
    if (parameter.charCodeAt(0) === 123) {
      hasParenthesis = true;
      parameter = parameter.slice(1, -1);
    }
    parameter = parameter.replace(/( |\t|\n)/g, "").trim();
    let parameters = [];
    while (true) {
      let [start, end] = bracketPairRange2(parameter);
      if (start === -1)
        break;
      parameters.push(parameter.slice(0, start - 1));
      if (parameter.charCodeAt(end) === 44)
        end++;
      parameter = parameter.slice(end);
    }
    parameter = removeColonAlias2(parameter);
    if (parameter)
      parameters = parameters.concat(parameter.split(","));
    const newParameters = [];
    for (const p of parameters) {
      if (p.indexOf(",") === -1) {
        newParameters.push(p);
        continue;
      }
      for (const q of p.split(","))
        newParameters.push(q.trim());
    }
    parameters = newParameters;
    return {
      hasParenthesis,
      parameters
    };
  };
  var findParameterReference2 = (parameter, inference) => {
    const { parameters, hasParenthesis } = retrieveRootParamters2(parameter);
    if (!inference.query && parameters.includes("query"))
      inference.query = true;
    if (!inference.headers && parameters.includes("headers"))
      inference.headers = true;
    if (!inference.body && parameters.includes("body"))
      inference.body = true;
    if (!inference.cookie && parameters.includes("cookie"))
      inference.cookie = true;
    if (!inference.set && parameters.includes("set"))
      inference.set = true;
    if (!inference.server && parameters.includes("server"))
      inference.server = true;
    if (!inference.request && parameters.includes("request"))
      inference.request = true;
    if (!inference.route && parameters.includes("route"))
      inference.route = true;
    if (hasParenthesis)
      return `{ ${parameters.join(", ")} }`;
    return parameters.join(", ");
  };
  var findEndIndex2 = (type2, content, index) => {
    const newLineIndex = content.indexOf(type2 + `
`, index);
    const newTabIndex = content.indexOf(type2 + "\t", index);
    const commaIndex = content.indexOf(type2 + ",", index);
    const semicolonIndex = content.indexOf(type2 + ";", index);
    const emptyIndex = content.indexOf(type2 + " ", index);
    return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i) => i > 0).sort((a, b) => a - b)[0] || -1;
  };
  var findAlias2 = (type2, body, depth = 0) => {
    if (depth > 5)
      return [];
    const aliases = [];
    let content = body;
    while (true) {
      let index = findEndIndex2(" = " + type2, content);
      if (index === -1)
        index = findEndIndex2("=" + type2, content);
      if (index === -1) {
        let lastIndex = content.indexOf(" = " + type2);
        if (lastIndex === -1)
          lastIndex = content.indexOf("=" + type2);
        if (lastIndex + 3 + type2.length !== content.length)
          break;
        index = lastIndex;
      }
      const part = content.slice(0, index);
      const lastPart = part.lastIndexOf(" ");
      let variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
      if (variable === "}") {
        const [start, end] = bracketPairRangeReverse2(part);
        aliases.push(removeColonAlias2(content.slice(start, end)));
        content = content.slice(index + 3 + type2.length);
        continue;
      }
      while (variable.charCodeAt(0) === 44)
        variable = variable.slice(1);
      while (variable.charCodeAt(0) === 9)
        variable = variable.slice(1);
      if (!variable.includes("("))
        aliases.push(variable);
      content = content.slice(index + 3 + type2.length);
    }
    for (const alias of aliases) {
      if (alias.charCodeAt(0) === 123)
        continue;
      const deepAlias = findAlias2(alias, body);
      if (deepAlias.length > 0)
        aliases.push(...deepAlias);
    }
    return aliases;
  };
  var extractMainParameter2 = (parameter) => {
    if (!parameter)
      return;
    if (parameter.charCodeAt(0) !== 123)
      return parameter;
    parameter = parameter.slice(2, -2);
    const hasComma = parameter.includes(",");
    if (!hasComma) {
      if (parameter.includes("..."))
        return parameter.slice(parameter.indexOf("...") + 3);
      return;
    }
    const spreadIndex = parameter.indexOf("...");
    if (spreadIndex === -1)
      return;
    return parameter.slice(spreadIndex + 3).trimEnd();
  };
  var inferBodyReference2 = (code, aliases, inference) => {
    const access = (type2, alias) => code.includes(alias + "." + type2) || code.includes(alias + '["' + type2 + '"]') || code.includes(alias + "['" + type2 + "']");
    for (const alias of aliases) {
      if (!alias)
        continue;
      if (alias.charCodeAt(0) === 123) {
        const parameters = retrieveRootParamters2(alias).parameters;
        if (!inference.query && parameters.includes("query"))
          inference.query = true;
        if (!inference.headers && parameters.includes("headers"))
          inference.headers = true;
        if (!inference.body && parameters.includes("body"))
          inference.body = true;
        if (!inference.cookie && parameters.includes("cookie"))
          inference.cookie = true;
        if (!inference.set && parameters.includes("set"))
          inference.set = true;
        if (!inference.query && parameters.includes("server"))
          inference.server = true;
        if (!inference.request && parameters.includes("request"))
          inference.request = true;
        if (!inference.route && parameters.includes("route"))
          inference.route = true;
        continue;
      }
      if (!inference.query && access("query", alias))
        inference.query = true;
      if (code.includes("return " + alias) || code.includes("return " + alias + ".query"))
        inference.query = true;
      if (!inference.headers && access("headers", alias))
        inference.headers = true;
      if (!inference.body && access("body", alias))
        inference.body = true;
      if (!inference.cookie && access("cookie", alias))
        inference.cookie = true;
      if (!inference.set && access("set", alias))
        inference.set = true;
      if (!inference.server && access("server", alias))
        inference.server = true;
      if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.server && inference.route)
        break;
    }
    return aliases;
  };
  var removeDefaultParameter = (parameter) => {
    while (true) {
      const index = parameter.indexOf("=");
      if (index === -1)
        break;
      const commaIndex = parameter.indexOf(",", index);
      const bracketIndex = parameter.indexOf("}", index);
      const end = [commaIndex, bracketIndex].filter((i) => i > 0).sort((a, b) => a - b)[0] || -1;
      if (end === -1) {
        parameter = parameter.slice(0, index);
        break;
      }
      parameter = parameter.slice(0, index) + parameter.slice(end);
    }
    return parameter.split(",").map((i) => i.trim()).join(", ");
  };
  var isContextPassToFunction2 = (context, body, inference) => {
    try {
      const captureFunction = new RegExp(`(?:\\w)\\((?:.*)?${context}`, "gs");
      captureFunction.test(body);
      const nextChar = body.charCodeAt(captureFunction.lastIndex);
      if (nextChar === 41 || nextChar === 44) {
        inference.query = true;
        inference.headers = true;
        inference.body = true;
        inference.cookie = true;
        inference.set = true;
        inference.server = true;
        inference.route = true;
        inference.request = true;
        return true;
      }
      return false;
    } catch (error3) {
      console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:");
      console.log("--- body ---");
      console.log(body);
      console.log("--- context ---");
      console.log(context);
      return true;
    }
  };
  var sucrose2 = (lifeCycle, inference = {
    query: false,
    headers: false,
    body: false,
    cookie: false,
    set: false,
    server: false,
    request: false,
    route: false
  }) => {
    const events = [];
    if (lifeCycle.handler && typeof lifeCycle.handler === "function")
      events.push(lifeCycle.handler);
    if (lifeCycle.request?.length)
      events.push(...lifeCycle.request);
    if (lifeCycle.beforeHandle?.length)
      events.push(...lifeCycle.beforeHandle);
    if (lifeCycle.parse?.length)
      events.push(...lifeCycle.parse);
    if (lifeCycle.error?.length)
      events.push(...lifeCycle.error);
    if (lifeCycle.transform?.length)
      events.push(...lifeCycle.transform);
    if (lifeCycle.afterHandle?.length)
      events.push(...lifeCycle.afterHandle);
    if (lifeCycle.mapResponse?.length)
      events.push(...lifeCycle.mapResponse);
    if (lifeCycle.afterResponse?.length)
      events.push(...lifeCycle.afterResponse);
    for (const e of events) {
      if (!e)
        continue;
      const event = "fn" in e ? e.fn : e;
      if (typeof event !== "function")
        continue;
      const [parameter, body, { isArrowReturn }] = separateFunction2(event.toString());
      const rootParameters = findParameterReference2(parameter, inference);
      const mainParameter = extractMainParameter2(rootParameters);
      if (mainParameter) {
        const aliases = findAlias2(mainParameter, body.slice(1, -1));
        aliases.splice(0, -1, mainParameter);
        let code = body;
        if (code.charCodeAt(0) === 123 && code.charCodeAt(body.length - 1) === 125)
          code = code.slice(1, -1);
        if (!isContextPassToFunction2(mainParameter, code, inference))
          inferBodyReference2(code, aliases, inference);
        if (!inference.query && code.includes("return " + mainParameter + ".query"))
          inference.query = true;
      }
      if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.request && inference.route)
        break;
    }
    return inference;
  };
});

// node_modules/elysia/dist/cjs/deuri.js
var require_deuri = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var deuri_exports = {};
  __export2(deuri_exports, {
    decode: () => decode3,
    decodeSegment: () => decodeSegment,
    encode: () => encode2
  });
  module.exports = __toCommonJS2(deuri_exports);
  var hex2 = [];
  for (let i = 48;i < 58; i++)
    hex2[i] = i - 48;
  for (let i = 0;i < 6; i++)
    hex2[i + 65] = hex2[i + 97] = i + 10;
  var calcHex2 = (a, b) => {
    if (a in hex2 && b in hex2)
      return hex2[a] << 4 | hex2[b];
    return 255;
  };
  var type2 = [
    ...new Array(128).fill(0),
    ...new Array(16).fill(1),
    ...new Array(16).fill(2),
    ...new Array(32).fill(3),
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4
  ];
  var next2 = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var mask2 = type2.map((val) => [
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ][val]);
  var decode3 = (url) => {
    let percentPosition = url.indexOf("%");
    if (percentPosition === -1)
      return url;
    let end = url.length - 3;
    if (percentPosition > end)
      return null;
    let decoded = "", start = 0, codepoint = 0, startOfOctets = percentPosition, state = 12, byte2;
    for (;; ) {
      byte2 = calcHex2(url.charCodeAt(percentPosition + 1), url.charCodeAt(percentPosition + 2));
      state = next2[state + type2[byte2]];
      if (state === 0)
        return null;
      if (state === 12) {
        decoded += url.substring(start, startOfOctets);
        codepoint = codepoint << 6 | byte2 & mask2[byte2];
        if (codepoint > 65535)
          decoded += String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        else
          decoded += String.fromCharCode(codepoint);
        start = percentPosition + 3;
        percentPosition = url.indexOf("%", start);
        if (percentPosition === -1)
          return decoded + url.substring(start);
        if (percentPosition > end)
          return null;
        startOfOctets = percentPosition;
        codepoint = 0;
      } else {
        percentPosition += 3;
        if (percentPosition > end || url.charCodeAt(percentPosition) !== 37)
          return null;
        codepoint = codepoint << 6 | byte2 & mask2[byte2];
      }
    }
  };
  var encode2 = (str) => str.isWellFormed() ? encodeURIComponent(str) : null;
  var decodeSegment = (url, start, end) => {
    let percentPosition = url.indexOf("%");
    if (percentPosition === -1)
      return url;
    end -= 3;
    if (percentPosition > end)
      return null;
    let decoded = "", codepoint = 0, startOfOctets = percentPosition, state = 12, byte2;
    for (;; ) {
      byte2 = calcHex2(url.charCodeAt(percentPosition + 1), url.charCodeAt(percentPosition + 2));
      state = next2[state + type2[byte2]];
      if (state === 0)
        return null;
      if (state === 12) {
        decoded += url.substring(start, startOfOctets);
        codepoint = codepoint << 6 | byte2 & mask2[byte2];
        if (codepoint > 65535)
          decoded += String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        else
          decoded += String.fromCharCode(codepoint);
        start = percentPosition + 3;
        percentPosition = url.indexOf("%", start);
        if (percentPosition === -1)
          return decoded + url.substring(start);
        if (percentPosition > end)
          return null;
        startOfOctets = percentPosition;
        codepoint = 0;
      } else {
        percentPosition += 3;
        if (percentPosition > end || url.charCodeAt(percentPosition) !== 37)
          return null;
        codepoint = codepoint << 6 | byte2 & mask2[byte2];
      }
    }
  };
});

// node_modules/elysia/dist/cjs/cookies.js
var require_cookies = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var cookies_exports = {};
  __export2(cookies_exports, {
    Cookie: () => Cookie3,
    createCookieJar: () => createCookieJar2,
    parseCookie: () => parseCookie2,
    serializeCookie: () => serializeCookie3
  });
  module.exports = __toCommonJS2(cookies_exports);
  var import_cookie2 = require_dist();
  var import_deuri4 = require_deuri();
  var import_utils15 = require_utils3();
  var import_error34 = require_error3();

  class Cookie3 {
    constructor(name, jar, initial = {}) {
      this.name = name;
      this.jar = jar;
      this.initial = initial;
    }
    get cookie() {
      return this.jar[this.name] ?? this.initial;
    }
    set cookie(jar) {
      if (!(this.name in this.jar))
        this.jar[this.name] = this.initial;
      this.jar[this.name] = jar;
    }
    get setCookie() {
      if (!(this.name in this.jar))
        this.jar[this.name] = this.initial;
      return this.jar[this.name];
    }
    set setCookie(jar) {
      this.cookie = jar;
    }
    get value() {
      return this.cookie.value;
    }
    set value(value) {
      this.setCookie.value = value;
    }
    get expires() {
      return this.cookie.expires;
    }
    set expires(expires) {
      this.setCookie.expires = expires;
    }
    get maxAge() {
      return this.cookie.maxAge;
    }
    set maxAge(maxAge) {
      this.setCookie.maxAge = maxAge;
    }
    get domain() {
      return this.cookie.domain;
    }
    set domain(domain) {
      this.setCookie.domain = domain;
    }
    get path() {
      return this.cookie.path;
    }
    set path(path) {
      this.setCookie.path = path;
    }
    get secure() {
      return this.cookie.secure;
    }
    set secure(secure) {
      this.setCookie.secure = secure;
    }
    get httpOnly() {
      return this.cookie.httpOnly;
    }
    set httpOnly(httpOnly) {
      this.setCookie.httpOnly = httpOnly;
    }
    get sameSite() {
      return this.cookie.sameSite;
    }
    set sameSite(sameSite) {
      this.setCookie.sameSite = sameSite;
    }
    get priority() {
      return this.cookie.priority;
    }
    set priority(priority) {
      this.setCookie.priority = priority;
    }
    get partitioned() {
      return this.cookie.partitioned;
    }
    set partitioned(partitioned) {
      this.setCookie.partitioned = partitioned;
    }
    get secrets() {
      return this.cookie.secrets;
    }
    set secrets(secrets) {
      this.setCookie.secrets = secrets;
    }
    update(config) {
      this.setCookie = Object.assign(this.cookie, typeof config === "function" ? config(this.cookie) : config);
      return this;
    }
    set(config) {
      this.setCookie = Object.assign({
        ...this.initial,
        value: this.value
      }, typeof config === "function" ? config(this.cookie) : config);
      return this;
    }
    remove() {
      if (this.value === undefined)
        return;
      this.set({
        expires: /* @__PURE__ */ new Date(0),
        maxAge: 0,
        value: ""
      });
      return this;
    }
    toString() {
      return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
    }
  }
  var createCookieJar2 = (set2, store, initial) => {
    if (!set2.cookie)
      set2.cookie = {};
    return new Proxy(store, {
      get(_, key) {
        if (key in store)
          return new Cookie3(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
        return new Cookie3(key, set2.cookie, Object.assign({}, initial));
      }
    });
  };
  var parseCookie2 = async (set2, cookieString, {
    secrets,
    sign,
    ...initial
  } = {}) => {
    if (!cookieString)
      return createCookieJar2(set2, {}, initial);
    const isStringKey = typeof secrets === "string";
    if (sign && sign !== true && !Array.isArray(sign))
      sign = [sign];
    const jar = {};
    const cookies = (0, import_cookie2.parse)(cookieString);
    for (const [name, v] of Object.entries(cookies)) {
      if (v === undefined)
        continue;
      let value = (0, import_deuri4.decode)(v);
      if (sign === true || sign?.includes(name)) {
        if (!secrets)
          throw new Error("No secret is provided to cookie plugin");
        if (isStringKey) {
          const temp = await (0, import_utils15.unsignCookie)(value, secrets);
          if (temp === false)
            throw new import_error34.InvalidCookieSignature(name);
          value = temp;
        } else {
          let decoded = true;
          for (let i = 0;i < secrets.length; i++) {
            const temp = await (0, import_utils15.unsignCookie)(value, secrets[i]);
            if (temp !== false) {
              decoded = true;
              value = temp;
              break;
            }
          }
          if (!decoded)
            throw new import_error34.InvalidCookieSignature(name);
        }
      }
      jar[name] = {
        value
      };
    }
    return createCookieJar2(set2, jar, initial);
  };
  var serializeCookie3 = (cookies) => {
    if (!cookies || !(0, import_utils15.isNotEmpty)(cookies))
      return;
    const set2 = [];
    for (const [key, property] of Object.entries(cookies)) {
      if (!key || !property)
        continue;
      const value = property.value;
      if (value === undefined || value === null)
        continue;
      set2.push((0, import_cookie2.serialize)(key, typeof value === "object" ? JSON.stringify(value) : value + "", property));
    }
    if (set2.length === 0)
      return;
    if (set2.length === 1)
      return set2[0];
    return set2;
  };
});

// node_modules/elysia/dist/cjs/adapter/web-standard/handler.js
var require_handler = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var handler_exports = {};
  __export2(handler_exports, {
    createStaticHandler: () => createStaticHandler3,
    errorToResponse: () => errorToResponse2,
    handleSet: () => handleSet2,
    mapCompactResponse: () => mapCompactResponse3,
    mapEarlyResponse: () => mapEarlyResponse3,
    mapResponse: () => mapResponse3,
    mergeResponseWithSetHeaders: () => mergeResponseWithSetHeaders2,
    parseSetCookies: () => parseSetCookies2,
    streamResponse: () => streamResponse2
  });
  module.exports = __toCommonJS2(handler_exports);
  var import_utils15 = require_utils3();
  var import_cookies6 = require_cookies();
  var import_error34 = require_error3();
  var handleFile2 = (response, set2) => {
    const size = response.size;
    if (!set2 && size || size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416) {
      if (set2) {
        if (set2.headers instanceof Headers) {
          let setHeaders = {
            "accept-ranges": "bytes",
            "content-range": `bytes 0-${size - 1}/${size}`,
            "transfer-encoding": "chunked"
          };
          if (import_utils15.hasHeaderShorthand)
            setHeaders = set2.headers.toJSON();
          else {
            setHeaders = {};
            for (const [key, value] of set2.headers.entries())
              if (key in set2.headers)
                setHeaders[key] = value;
          }
          return new Response(response, {
            status: set2.status,
            headers: setHeaders
          });
        }
        if ((0, import_utils15.isNotEmpty)(set2.headers))
          return new Response(response, {
            status: set2.status,
            headers: Object.assign({
              "accept-ranges": "bytes",
              "content-range": `bytes 0-${size - 1}/${size}`,
              "transfer-encoding": "chunked"
            }, set2.headers)
          });
      }
      return new Response(response, {
        headers: {
          "accept-ranges": "bytes",
          "content-range": `bytes 0-${size - 1}/${size}`,
          "transfer-encoding": "chunked"
        }
      });
    }
    return new Response(response);
  };
  var parseSetCookies2 = (headers, setCookie) => {
    if (!headers)
      return headers;
    headers.delete("set-cookie");
    for (let i = 0;i < setCookie.length; i++) {
      const index = setCookie[i].indexOf("=");
      headers.append("set-cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
    }
    return headers;
  };
  var responseToSetHeaders2 = (response, set2) => {
    if (set2?.headers) {
      if (response) {
        if (import_utils15.hasHeaderShorthand)
          Object.assign(set2.headers, response.headers.toJSON());
        else
          for (const [key, value] of response.headers.entries())
            if (key in set2.headers)
              set2.headers[key] = value;
      }
      if (set2.status === 200)
        set2.status = response.status;
      if (set2.headers["content-encoding"])
        delete set2.headers["content-encoding"];
      return set2;
    }
    if (!response)
      return {
        headers: {},
        status: set2?.status ?? 200
      };
    if (import_utils15.hasHeaderShorthand) {
      set2 = {
        headers: response.headers.toJSON(),
        status: set2?.status ?? 200
      };
      if (set2.headers["content-encoding"])
        delete set2.headers["content-encoding"];
      return set2;
    }
    set2 = {
      headers: {},
      status: set2?.status ?? 200
    };
    for (const [key, value] of response.headers.entries()) {
      if (key === "content-encoding")
        continue;
      if (key in set2.headers)
        set2.headers[key] = value;
    }
    return set2;
  };
  var handleStream2 = async (generator, set2, request) => {
    let init = generator.next();
    if (init instanceof Promise)
      init = await init;
    if (init.done) {
      if (set2)
        return mapResponse3(init.value, set2, request);
      return mapCompactResponse3(init.value, request);
    }
    if (set2?.headers) {
      if (!set2.headers["transfer-encoding"])
        set2.headers["transfer-encoding"] = "chunked";
      if (!set2.headers["content-type"])
        set2.headers["content-type"] = "text/event-stream; charset=utf-8";
    } else {
      set2 = {
        status: 200,
        headers: {
          "content-type": "text/event-stream; charset=utf-8",
          "transfer-encoding": "chunked"
        }
      };
    }
    return new Response(new ReadableStream({
      async start(controller) {
        let end = false;
        request?.signal?.addEventListener("abort", () => {
          end = true;
          try {
            controller.close();
          } catch {}
        });
        if (init.value !== undefined && init.value !== null) {
          if (typeof init.value === "object")
            try {
              controller.enqueue(Buffer.from(JSON.stringify(init.value)));
            } catch {
              controller.enqueue(Buffer.from(init.value.toString()));
            }
          else
            controller.enqueue(Buffer.from(init.value.toString()));
        }
        for await (const chunk of generator) {
          if (end)
            break;
          if (chunk === undefined || chunk === null)
            continue;
          if (typeof chunk === "object")
            try {
              controller.enqueue(Buffer.from(JSON.stringify(chunk)));
            } catch {
              controller.enqueue(Buffer.from(chunk.toString()));
            }
          else
            controller.enqueue(Buffer.from(chunk.toString()));
          await new Promise((resolve2) => setTimeout(() => resolve2(), 0));
        }
        try {
          controller.close();
        } catch {}
      }
    }), set2);
  };
  async function* streamResponse2(response) {
    const body = response.body;
    if (!body)
      return;
    const reader = body.getReader();
    const decoder = new TextDecoder;
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        yield decoder.decode(value);
      }
    } finally {
      reader.releaseLock();
    }
  }
  var handleSet2 = (set2) => {
    if (typeof set2.status === "string")
      set2.status = import_utils15.StatusMap[set2.status];
    if (set2.cookie && (0, import_utils15.isNotEmpty)(set2.cookie)) {
      const cookie = (0, import_cookies6.serializeCookie)(set2.cookie);
      if (cookie)
        set2.headers["set-cookie"] = cookie;
    }
    if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"])) {
      set2.headers = parseSetCookies2(new Headers(set2.headers), set2.headers["set-cookie"]);
    }
  };
  var mergeResponseWithSetHeaders2 = (response, set2) => {
    if (response.status !== set2.status && set2.status !== 200 && (response.status <= 300 || response.status > 400))
      response = new Response(response.body, {
        headers: response.headers,
        status: set2.status
      });
    let isCookieSet = false;
    if (set2.headers instanceof Headers)
      for (const key of set2.headers.keys()) {
        if (key === "set-cookie") {
          if (isCookieSet)
            continue;
          isCookieSet = true;
          for (const cookie of set2.headers.getSetCookie())
            response.headers.append("set-cookie", cookie);
        } else
          response.headers.append(key, set2.headers?.get(key) ?? "");
      }
    else
      for (const key in set2.headers)
        response.headers.append(key, set2.headers[key]);
    return response;
  };
  var mapResponse3 = (response, set2, request) => {
    if ((0, import_utils15.isNotEmpty)(set2.headers) || set2.status !== 200 || set2.cookie) {
      handleSet2(set2);
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response, set2);
        case "Array":
        case "Object":
          return Response.json(response, set2);
        case "ElysiaFile":
          return handleFile2(response.value);
        case "Blob":
          return handleFile2(response, set2);
        case "ElysiaCustomStatusResponse":
          set2.status = response.code;
          return mapResponse3(response.response, set2, request);
        case "ReadableStream":
          if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
            set2.headers["content-type"] = "text/event-stream; charset=utf-8";
          request?.signal?.addEventListener("abort", {
            handleEvent() {
              if (request?.signal && !request?.signal?.aborted)
                response.cancel();
            }
          }, {
            once: true
          });
          return new Response(response, set2);
        case undefined:
          if (!response)
            return new Response("", set2);
          return Response.json(response, set2);
        case "Response":
          response = mergeResponseWithSetHeaders2(response, set2);
          if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
            return handleStream2(streamResponse2(response), responseToSetHeaders2(response, set2), request);
          return response;
        case "Error":
          return errorToResponse2(response, set2);
        case "Promise":
          return response.then((x) => mapResponse3(x, set2, request));
        case "Function":
          return mapResponse3(response(), set2, request);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set2);
        case "Cookie":
          if (response instanceof import_cookies6.Cookie)
            return new Response(response.value, set2);
          return new Response(response?.toString(), set2);
        case "FormData":
          return new Response(response, set2);
        default:
          if (response instanceof Response) {
            response = mergeResponseWithSetHeaders2(response, set2);
            if (response.headers.get("transfer-encoding") === "chunked")
              return handleStream2(streamResponse2(response), responseToSetHeaders2(response, set2), request);
            return response;
          }
          if (response instanceof Promise)
            return response.then((x) => mapResponse3(x, set2));
          if (response instanceof Error)
            return errorToResponse2(response, set2);
          if (response instanceof import_error34.ElysiaCustomStatusResponse) {
            set2.status = response.code;
            return mapResponse3(response.response, set2, request);
          }
          if (typeof response?.next === "function")
            return handleStream2(response, set2, request);
          if (typeof response?.then === "function")
            return response.then((x) => mapResponse3(x, set2));
          if (typeof response?.toResponse === "function")
            return mapResponse3(response.toResponse(), set2);
          if ("charCodeAt" in response) {
            const code = response.charCodeAt(0);
            if (code === 123 || code === 91) {
              if (!set2.headers["Content-Type"])
                set2.headers["Content-Type"] = "application/json";
              return new Response(JSON.stringify(response), set2);
            }
          }
          return new Response(response, set2);
      }
    }
    if (response instanceof Response && !response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
      return handleStream2(streamResponse2(response), responseToSetHeaders2(response, set2), request);
    if (typeof response?.next === "function" || response instanceof ReadableStream)
      return handleStream2(response, set2, request);
    return mapCompactResponse3(response, request);
  };
  var mapEarlyResponse3 = (response, set2, request) => {
    if (response === undefined || response === null)
      return;
    if ((0, import_utils15.isNotEmpty)(set2.headers) || set2.status !== 200 || set2.cookie) {
      handleSet2(set2);
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response, set2);
        case "Array":
        case "Object":
          return Response.json(response, set2);
        case "ElysiaFile":
          return handleFile2(response.value);
        case "Blob":
          return handleFile2(response, set2);
        case "ElysiaCustomStatusResponse":
          set2.status = response.code;
          return mapEarlyResponse3(response.response, set2, request);
        case "ReadableStream":
          if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
            set2.headers["content-type"] = "text/event-stream; charset=utf-8";
          request?.signal?.addEventListener("abort", {
            handleEvent() {
              if (request?.signal && !request?.signal?.aborted)
                response.cancel();
            }
          }, {
            once: true
          });
          return new Response(response, set2);
        case undefined:
          if (!response)
            return;
          return Response.json(response, set2);
        case "Response":
          response = mergeResponseWithSetHeaders2(response, set2);
          if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
            return handleStream2(streamResponse2(response), responseToSetHeaders2(response, set2), request);
          return response;
        case "Promise":
          return response.then((x) => mapEarlyResponse3(x, set2));
        case "Error":
          return errorToResponse2(response, set2);
        case "Function":
          return mapEarlyResponse3(response(), set2);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set2);
        case "FormData":
          return new Response(response);
        case "Cookie":
          if (response instanceof import_cookies6.Cookie)
            return new Response(response.value, set2);
          return new Response(response?.toString(), set2);
        default:
          if (response instanceof Response) {
            response = mergeResponseWithSetHeaders2(response, set2);
            if (response.headers.get("transfer-encoding") === "chunked")
              return handleStream2(streamResponse2(response), responseToSetHeaders2(response, set2), request);
            return response;
          }
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse3(x, set2));
          if (response instanceof Error)
            return errorToResponse2(response, set2);
          if (response instanceof import_error34.ElysiaCustomStatusResponse) {
            set2.status = response.code;
            return mapEarlyResponse3(response.response, set2, request);
          }
          if (typeof response?.next === "function")
            return handleStream2(response, set2, request);
          if (typeof response?.then === "function")
            return response.then((x) => mapEarlyResponse3(x, set2));
          if (typeof response?.toResponse === "function")
            return mapEarlyResponse3(response.toResponse(), set2);
          if ("charCodeAt" in response) {
            const code = response.charCodeAt(0);
            if (code === 123 || code === 91) {
              if (!set2.headers["Content-Type"])
                set2.headers["Content-Type"] = "application/json";
              return new Response(JSON.stringify(response), set2);
            }
          }
          return new Response(response, set2);
      }
    } else
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response);
        case "Array":
        case "Object":
          return Response.json(response, set2);
        case "ElysiaFile":
          return handleFile2(response.value);
        case "Blob":
          return handleFile2(response, set2);
        case "ElysiaCustomStatusResponse":
          set2.status = response.code;
          return mapEarlyResponse3(response.response, set2, request);
        case "ReadableStream":
          request?.signal?.addEventListener("abort", {
            handleEvent() {
              if (request?.signal && !request?.signal?.aborted)
                response.cancel();
            }
          }, {
            once: true
          });
          return new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case undefined:
          if (!response)
            return new Response("");
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "Response":
          if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
            return handleStream2(streamResponse2(response), responseToSetHeaders2(response), request);
          return response;
        case "Promise":
          return response.then((x) => {
            const r = mapEarlyResponse3(x, set2);
            if (r !== undefined)
              return r;
          });
        case "Error":
          return errorToResponse2(response, set2);
        case "Function":
          return mapCompactResponse3(response(), request);
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          if (response instanceof import_cookies6.Cookie)
            return new Response(response.value, set2);
          return new Response(response?.toString(), set2);
        case "FormData":
          return new Response(response);
        default:
          if (response instanceof Response)
            return response;
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse3(x, set2));
          if (response instanceof Error)
            return errorToResponse2(response, set2);
          if (response instanceof import_error34.ElysiaCustomStatusResponse) {
            set2.status = response.code;
            return mapEarlyResponse3(response.response, set2, request);
          }
          if (typeof response?.next === "function")
            return handleStream2(response, set2, request);
          if (typeof response?.then === "function")
            return response.then((x) => mapEarlyResponse3(x, set2));
          if (typeof response?.toResponse === "function")
            return mapEarlyResponse3(response.toResponse(), set2);
          if ("charCodeAt" in response) {
            const code = response.charCodeAt(0);
            if (code === 123 || code === 91) {
              if (!set2.headers["Content-Type"])
                set2.headers["Content-Type"] = "application/json";
              return new Response(JSON.stringify(response), set2);
            }
          }
          return new Response(response);
      }
  };
  var mapCompactResponse3 = (response, request) => {
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Object":
      case "Array":
        return Response.json(response);
      case "ElysiaFile":
        return handleFile2(response.value);
      case "Blob":
        return handleFile2(response);
      case "ElysiaCustomStatusResponse":
        return mapResponse3(response.response, {
          status: response.code,
          headers: {}
        });
      case "ReadableStream":
        request?.signal?.addEventListener("abort", {
          handleEvent() {
            if (request?.signal && !request?.signal?.aborted)
              response.cancel();
          }
        }, {
          once: true
        });
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        if (response.headers.get("transfer-encoding") === "chunked")
          return handleStream2(streamResponse2(response), responseToSetHeaders2(response), request);
        return response;
      case "Error":
        return errorToResponse2(response);
      case "Promise":
        return response.then((x) => mapCompactResponse3(x, request));
      case "Function":
        return mapCompactResponse3(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapCompactResponse3(x, request));
        if (response instanceof Error)
          return errorToResponse2(response);
        if (response instanceof import_error34.ElysiaCustomStatusResponse)
          return mapResponse3(response.response, {
            status: response.code,
            headers: {}
          });
        if (typeof response?.next === "function")
          return handleStream2(response, undefined, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse3(x, set));
        if (typeof response?.toResponse === "function")
          return mapCompactResponse3(response.toResponse());
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            return new Response(JSON.stringify(response), {
              headers: {
                "Content-Type": "application/json"
              }
            });
          }
        }
        return new Response(response);
    }
  };
  var errorToResponse2 = (error3, set2) => new Response(JSON.stringify({
    name: error3?.name,
    message: error3?.message,
    cause: error3?.cause
  }), {
    status: set2?.status !== 200 ? set2?.status ?? 500 : 500,
    headers: set2?.headers
  });
  var createStaticHandler3 = (handle, hooks, setHeaders = {}) => {
    if (typeof handle === "function")
      return;
    const response = mapResponse3(handle, {
      headers: setHeaders
    });
    if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
      return response.clone.bind(response);
  };
});

// node_modules/elysia/dist/cjs/adapter/web-standard/index.js
var require_web_standard = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var web_standard_exports = {};
  __export2(web_standard_exports, {
    WebStandardAdapter: () => WebStandardAdapter2
  });
  module.exports = __toCommonJS2(web_standard_exports);
  var import_handler5 = require_handler();
  var import_utils15 = require_utils3();
  var WebStandardAdapter2 = {
    name: "web-standard",
    isWebStandard: true,
    handler: {
      mapResponse: import_handler5.mapResponse,
      mapEarlyResponse: import_handler5.mapEarlyResponse,
      mapCompactResponse: import_handler5.mapCompactResponse,
      createStaticHandler: import_handler5.createStaticHandler
    },
    composeHandler: {
      mapResponseContext: "c.request",
      preferWebstandardHeaders: true,
      headers: `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
`,
      parser: {
        json(isOptional2) {
          if (isOptional2)
            return `try{c.body=await c.request.json()}catch{}
`;
          return `c.body=await c.request.json()
`;
        },
        text() {
          return `c.body=await c.request.text()
`;
        },
        urlencoded() {
          return `c.body=parseQuery(await c.request.text())
`;
        },
        arrayBuffer() {
          return `c.body=await c.request.arrayBuffer()
`;
        },
        formData(isOptional2) {
          let fnLiteral = `
c.body={}
`;
          if (isOptional2)
            fnLiteral += `let form;try{form=await c.request.formData()}catch{}`;
          else
            fnLiteral += `const form=await c.request.formData()
`;
          return fnLiteral + `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`;
        }
      }
    },
    composeGeneralHandler: {
      parameters: "r",
      createContext(app) {
        let decoratorsLiteral = "";
        let fnLiteral = "";
        const defaultHeaders = app.setHeaders;
        for (const key of Object.keys(app.singleton.decorator))
          decoratorsLiteral += `,${key}: decorator['${key}']`;
        const standardHostname = app.config.handler?.standardHostname ?? true;
        const hasTrace = !!app.event.trace?.length;
        fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?', s + 1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`;
        if (hasTrace)
          fnLiteral += `const id=randomId()
`;
        fnLiteral += `const c={request:r,store,qi,path:p,url:u,redirect,error,set:{headers:`;
        fnLiteral += Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}";
        fnLiteral += `,status:200}`;
        if (app.inference.server)
          fnLiteral += `,get server(){return app.getServer()}`;
        if (hasTrace)
          fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
        fnLiteral += decoratorsLiteral;
        fnLiteral += `}
`;
        return fnLiteral;
      },
      websocket(app) {
        let fnLiteral = "";
        const wsPaths = app.router.static.ws;
        const router = app.router.http;
        router.build();
        if (Object.keys(wsPaths).length || router.root.ws || router.history.find((x) => x["0"] === "ws")) {
          fnLiteral += `if(r.method==='GET'){switch(p){`;
          for (const [path, index] of Object.entries(wsPaths)) {
            fnLiteral += `case'${path}':` + (app.config.strictPath !== true ? `case'${(0, import_utils15.getLoosePath)(path)}':` : "") + `if(r.headers.get('upgrade')==='websocket')return ht[${index}].composed(c)
`;
          }
          fnLiteral += `default:if(r.headers.get('upgrade')==='websocket'){const route=router.find('ws',p)
if(route){c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)}}break}}`;
        }
        return fnLiteral;
      },
      error404(hasEventHook, hasErrorHook) {
        let findDynamicRoute = `if(route===null)return `;
        if (hasErrorHook)
          findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
        else
          findDynamicRoute += hasEventHook ? `new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})` : `error404.clone()`;
        return {
          declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`,
          code: findDynamicRoute
        };
      }
    },
    composeError: {
      mapResponseContext: "",
      validationError: `return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})`,
      unknownError: `return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})`
    },
    listen() {
      return () => {
        throw new Error("WebStandard does not support listen, you might want to export default Elysia.fetch instead");
      };
    }
  };
});

// node_modules/elysia/dist/cjs/adapter/bun/handler.js
var require_handler2 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var handler_exports = {};
  __export2(handler_exports, {
    createNativeStaticHandler: () => createNativeStaticHandler2,
    createStaticHandler: () => import_handler5.createStaticHandler,
    mapCompactResponse: () => import_handler5.mapCompactResponse,
    mapEarlyResponse: () => import_handler5.mapEarlyResponse,
    mapResponse: () => import_handler5.mapResponse
  });
  module.exports = __toCommonJS2(handler_exports);
  var import_handler5 = require_handler();
  var createNativeStaticHandler2 = (handle, hooks, setHeaders = {}) => {
    if (typeof handle === "function" || handle instanceof Blob)
      return;
    if (typeof handle === "object" && handle?.toString() === "[object HTMLBundle]")
      return () => handle;
    const response = (0, import_handler5.mapResponse)(handle, {
      headers: setHeaders
    });
    if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length) {
      if (!response.headers.has("content-type"))
        response.headers.append("content-type", "text/plain;charset=utf-8");
      return response.clone.bind(response);
    }
  };
});

// node_modules/elysia/dist/cjs/ws/index.js
var require_ws = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var ws_exports = {};
  __export2(ws_exports, {
    ElysiaWS: () => ElysiaWS2,
    createHandleWSResponse: () => createHandleWSResponse2,
    createWSMessageParser: () => createWSMessageParser2,
    websocket: () => websocket2
  });
  module.exports = __toCommonJS2(ws_exports);
  var import_utils15 = require_utils3();
  var import_error34 = require_error3();
  var websocket2 = {
    open(ws) {
      ws.data.open?.(ws);
    },
    message(ws, message) {
      ws.data.message?.(ws, message);
    },
    drain(ws) {
      ws.data.drain?.(ws);
    },
    close(ws, code, reason) {
      ws.data.close?.(ws, code, reason);
    }
  };

  class ElysiaWS2 {
    constructor(raw, data, body = undefined) {
      this.raw = raw;
      this.data = data;
      this.body = body;
      this.validator = raw.data?.validator;
      this.sendText = raw.sendText.bind(raw);
      this.sendBinary = raw.sendBinary.bind(raw);
      this.close = raw.close.bind(raw);
      this.terminate = raw.terminate.bind(raw);
      this.publishText = raw.publishText.bind(raw);
      this.publishBinary = raw.publishBinary.bind(raw);
      this.subscribe = raw.subscribe.bind(raw);
      this.unsubscribe = raw.unsubscribe.bind(raw);
      this.isSubscribed = raw.isSubscribed.bind(raw);
      this.cork = raw.cork.bind(raw);
      this.remoteAddress = raw.remoteAddress;
      this.binaryType = raw.binaryType;
      this.data = raw.data;
      this.send = this.send.bind(this);
      this.ping = this.ping.bind(this);
      this.pong = this.pong.bind(this);
      this.publish = this.publish.bind(this);
    }
    get id() {
      return this.data.id;
    }
    send(data, compress) {
      if (Buffer.isBuffer(data))
        return this.raw.send(data, compress);
      if (this.validator?.Check(data) === false)
        return this.raw.send(new import_error34.ValidationError("message", this.validator, data).message);
      if (typeof data === "object")
        data = JSON.stringify(data);
      return this.raw.send(data, compress);
    }
    ping(data) {
      if (Buffer.isBuffer(data))
        return this.raw.ping(data);
      if (this.validator?.Check(data) === false)
        return this.raw.send(new import_error34.ValidationError("message", this.validator, data).message);
      if (typeof data === "object")
        data = JSON.stringify(data);
      return this.raw.ping(data);
    }
    pong(data) {
      if (Buffer.isBuffer(data))
        return this.raw.pong(data);
      if (this.validator?.Check(data) === false)
        return this.raw.send(new import_error34.ValidationError("message", this.validator, data).message);
      if (typeof data === "object")
        data = JSON.stringify(data);
      return this.raw.pong(data);
    }
    publish(topic, data, compress) {
      if (Buffer.isBuffer(data))
        return this.raw.publish(topic, data, compress);
      if (this.validator?.Check(data) === false)
        return this.raw.send(new import_error34.ValidationError("message", this.validator, data).message);
      if (typeof data === "object")
        data = JSON.stringify(data);
      return this.raw.publish(topic, data, compress);
    }
    get readyState() {
      return this.raw.readyState;
    }
  }
  var createWSMessageParser2 = (parse3) => {
    const parsers = typeof parse3 === "function" ? [parse3] : parse3;
    return async function parseMessage(ws, message) {
      if (typeof message === "string") {
        const start = message?.charCodeAt(0);
        if (start === 34 || start === 47 || start === 91 || start === 123)
          try {
            message = JSON.parse(message);
          } catch {}
        else if ((0, import_utils15.isNumericString)(message))
          message = +message;
        else if (message === "true")
          message = true;
        else if (message === "false")
          message = false;
        else if (message === "null")
          message = null;
      }
      if (parsers)
        for (let i = 0;i < parsers.length; i++) {
          let temp = parsers[i](ws, message);
          if (temp instanceof Promise)
            temp = await temp;
          if (temp !== undefined)
            return temp;
        }
      return message;
    };
  };
  var createHandleWSResponse2 = (validateResponse) => {
    const handleWSResponse = (ws, data) => {
      if (data instanceof Promise)
        return data.then((data2) => handleWSResponse(ws, data2));
      if (Buffer.isBuffer(data))
        return ws.send(data.toString());
      if (data === undefined)
        return;
      const send = (datum) => {
        if (validateResponse?.Check(datum) === false)
          return ws.send(new import_error34.ValidationError("message", validateResponse, datum).message);
        if (typeof datum === "object")
          return ws.send(JSON.stringify(datum));
        ws.send(datum);
      };
      if (typeof data?.next !== "function")
        return void send(data);
      const init = data.next();
      if (init instanceof Promise)
        return (async () => {
          const first = await init;
          if (validateResponse?.Check(first) === false)
            return ws.send(new import_error34.ValidationError("message", validateResponse, first).message);
          send(first.value);
          if (!first.done)
            for await (const datum of data)
              send(datum);
        })();
      send(init.value);
      if (!init.done)
        for (const datum of data)
          send(datum);
    };
    return handleWSResponse;
  };
});

// node_modules/elysia/dist/cjs/adapter/bun/index.js
var require_bun = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var bun_exports = {};
  __export2(bun_exports, {
    BunAdapter: () => BunAdapter2
  });
  module.exports = __toCommonJS2(bun_exports);
  var import_web_standard3 = require_web_standard();
  var import_handler5 = require_handler();
  var import_handler22 = require_handler2();
  var import_cookies6 = require_cookies();
  var import_error34 = require_error3();
  var import_utils15 = require_utils3();
  var import_ws2 = require_ws();
  var BunAdapter2 = {
    ...import_web_standard3.WebStandardAdapter,
    name: "bun",
    handler: {
      ...import_web_standard3.WebStandardAdapter.handler,
      createNativeStaticHandler: import_handler22.createNativeStaticHandler
    },
    composeHandler: {
      ...import_web_standard3.WebStandardAdapter.composeHandler,
      headers: import_utils15.hasHeaderShorthand ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
`
    },
    listen(app) {
      return (options, callback) => {
        if (typeof Bun === "undefined")
          throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
        app.compile();
        if (typeof options === "string") {
          if (!(0, import_utils15.isNumericString)(options))
            throw new Error("Port must be a numeric value");
          options = parseInt(options);
        }
        const fetch2 = app.fetch;
        const serve = typeof options === "object" ? {
          development: !import_error34.isProduction,
          reusePort: true,
          ...app.config.serve || {},
          ...options || {},
          static: {
            ...app.router.static.http.static,
            ...app.config.serve?.static
          },
          websocket: {
            ...app.config.websocket || {},
            ...import_ws2.websocket || {}
          },
          fetch: fetch2,
          error: app.outerErrorHandler
        } : {
          development: !import_error34.isProduction,
          reusePort: true,
          ...app.config.serve || {},
          static: app.router.static.http.static,
          websocket: {
            ...app.config.websocket || {},
            ...import_ws2.websocket || {}
          },
          port: options,
          fetch: fetch2,
          error: app.outerErrorHandler
        };
        app.server = Bun?.serve(serve);
        if (app.event.start)
          for (let i = 0;i < app.event.start.length; i++)
            app.event.start[i].fn(app);
        if (callback)
          callback(app.server);
        process.on("beforeExit", () => {
          if (app.server) {
            app.server.stop?.();
            app.server = null;
            if (app.event.stop)
              for (let i = 0;i < app.event.stop.length; i++)
                app.event.stop[i].fn(app);
          }
        });
        app.promisedModules.then(() => {
          Bun?.gc(false);
        });
      };
    },
    ws(app, path, options) {
      const { parse: parse3, body, response, ...rest } = options;
      const validateMessage = (0, import_utils15.getSchemaValidator)(body, {
        modules: app.definitions.typebox,
        models: app.definitions.type,
        normalize: app.config.normalize
      });
      const validateResponse = (0, import_utils15.getSchemaValidator)(response, {
        modules: app.definitions.typebox,
        models: app.definitions.type,
        normalize: app.config.normalize
      });
      app.route("$INTERNALWS", path, async (context) => {
        const server = app.getServer();
        const { set: set2, path: path2, qi, headers, query, params } = context;
        context.validator = validateResponse;
        if (options.upgrade) {
          if (typeof options.upgrade === "function") {
            const temp = options.upgrade(context);
            if (temp instanceof Promise)
              await temp;
          } else if (options.upgrade)
            Object.assign(set2.headers, options.upgrade);
        }
        if (set2.cookie && (0, import_utils15.isNotEmpty)(set2.cookie)) {
          const cookie = (0, import_cookies6.serializeCookie)(set2.cookie);
          if (cookie)
            set2.headers["set-cookie"] = cookie;
        }
        if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
          set2.headers = (0, import_handler5.parseSetCookies)(new Headers(set2.headers), set2.headers["set-cookie"]);
        const handleResponse = (0, import_ws2.createHandleWSResponse)(validateResponse);
        const parseMessage = (0, import_ws2.createWSMessageParser)(parse3);
        let _id;
        const errorHandlers = [
          ...Array.isArray(options.error) ? options.error : [options.error],
          ...(app.event.error ?? []).map((x) => typeof x === "function" ? x : x.fn)
        ];
        const handleErrors = !errorHandlers.length ? () => {} : async (ws, error3) => {
          for (const handleError of errorHandlers) {
            let response2 = handleError(Object.assign(context, { error: error3 }));
            if (response2 instanceof Promise)
              response2 = await response2;
            await handleResponse(ws, response2);
            if (response2)
              break;
          }
        };
        if (server?.upgrade(context.request, {
          headers: (0, import_utils15.isNotEmpty)(set2.headers) ? set2.headers : undefined,
          data: {
            ...context,
            get id() {
              if (_id)
                return _id;
              return _id = (0, import_utils15.randomId)();
            },
            validator: validateResponse,
            ping(data) {
              options.ping?.(data);
            },
            pong(data) {
              options.pong?.(data);
            },
            open(ws) {
              try {
                handleResponse(ws, options.open?.(new import_ws2.ElysiaWS(ws, context)));
              } catch (error3) {
                handleErrors(ws, error3);
              }
            },
            message: async (ws, _message) => {
              const message = await parseMessage(ws, _message);
              if (validateMessage?.Check(message) === false)
                return void ws.send(new import_error34.ValidationError("message", validateMessage, message).message);
              try {
                handleResponse(ws, options.message?.(new import_ws2.ElysiaWS(ws, context, message), message));
              } catch (error3) {
                handleErrors(ws, error3);
              }
            },
            drain(ws) {
              try {
                handleResponse(ws, options.drain?.(new import_ws2.ElysiaWS(ws, context)));
              } catch (error3) {
                handleErrors(ws, error3);
              }
            },
            close(ws, code, reason) {
              try {
                handleResponse(ws, options.close?.(new import_ws2.ElysiaWS(ws, context), code, reason));
              } catch (error3) {
                handleErrors(ws, error3);
              }
            }
          }
        }))
          return;
        set2.status = 400;
        return "Expected a websocket connection";
      }, {
        ...rest,
        websocket: options
      });
    }
  };
});

// node_modules/elysia/dist/cjs/universal/utils.js
var require_utils4 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var utils_exports = {};
  __export2(utils_exports, {
    isBun: () => isBun3,
    isDeno: () => isDeno
  });
  module.exports = __toCommonJS2(utils_exports);
  var isBun3 = typeof Bun !== "undefined";
  var isDeno = typeof Deno !== "undefined";
});

// node_modules/elysia/dist/cjs/universal/env.js
var require_env = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var env_exports = {};
  __export2(env_exports, {
    env: () => env4
  });
  module.exports = __toCommonJS2(env_exports);
  var import_utils15 = require_utils4();
  var env4 = import_utils15.isBun ? Bun.env : typeof process !== "undefined" && process?.env ? process.env : {};
});

// node_modules/elysia/dist/cjs/fast-querystring.js
var require_fast_querystring = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var fast_querystring_exports = {};
  __export2(fast_querystring_exports, {
    parseQuery: () => parseQuery2,
    parseQueryFromURL: () => parseQueryFromURL2
  });
  module.exports = __toCommonJS2(fast_querystring_exports);
  var import_deuri4 = require_deuri();
  var plusRegex2 = /\+/g;
  function parseQueryFromURL2(input) {
    const result = {};
    if (typeof input !== "string")
      return result;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let flags = 0;
    const l = input.length;
    for (let i = 0;i < l; i++) {
      switch (input.charCodeAt(i)) {
        case 38:
          const hasBothKeyValuePair = equalityIndex > startingIndex;
          if (!hasBothKeyValuePair)
            equalityIndex = i;
          key = input.slice(startingIndex + 1, equalityIndex);
          if (hasBothKeyValuePair || key.length > 0) {
            if (flags & 1)
              key = key.replace(plusRegex2, " ");
            if (flags & 2)
              key = (0, import_deuri4.decode)(key) || key;
            if (!result[key]) {
              if (hasBothKeyValuePair) {
                value = input.slice(equalityIndex + 1, i);
                if (flags & 4)
                  value = value.replace(plusRegex2, " ");
                if (flags & 8)
                  value = (0, import_deuri4.decode)(value) || value;
              }
              result[key] = value;
            }
          }
          key = "";
          value = "";
          startingIndex = i;
          equalityIndex = i;
          flags = 0;
          break;
        case 61:
          if (equalityIndex <= startingIndex)
            equalityIndex = i;
          else
            flags |= 8;
          break;
        case 43:
          if (equalityIndex > startingIndex)
            flags |= 4;
          else
            flags |= 1;
          break;
        case 37:
          if (equalityIndex > startingIndex)
            flags |= 8;
          else
            flags |= 2;
          break;
      }
    }
    if (startingIndex < l) {
      const hasBothKeyValuePair = equalityIndex > startingIndex;
      key = input.slice(startingIndex + 1, hasBothKeyValuePair ? equalityIndex : l);
      if (hasBothKeyValuePair || key.length > 0) {
        if (flags & 1)
          key = key.replace(plusRegex2, " ");
        if (flags & 2)
          key = (0, import_deuri4.decode)(key) || key;
        if (!result[key]) {
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, l);
            if (flags & 4)
              value = value.replace(plusRegex2, " ");
            if (flags & 8)
              value = (0, import_deuri4.decode)(value) || value;
          }
          result[key] = value;
        }
      }
    }
    return result;
  }
  var parseQuery2 = (input) => {
    const result = {};
    if (typeof input !== "string")
      return result;
    const inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      if (i !== inputLength)
        c = input.charCodeAt(i);
      else
        c = 38;
      switch (c) {
        case 38: {
          hasBothKeyValuePair = equalityIndex > startingIndex;
          if (!hasBothKeyValuePair)
            equalityIndex = i;
          key = input.slice(startingIndex + 1, equalityIndex);
          if (hasBothKeyValuePair || key.length > 0) {
            if (keyHasPlus)
              key = key.replace(plusRegex2, " ");
            if (shouldDecodeKey)
              key = (0, import_deuri4.decode)(key) || key;
            if (hasBothKeyValuePair) {
              value = input.slice(equalityIndex + 1, i);
              if (valueHasPlus)
                value = value.replace(plusRegex2, " ");
              if (shouldDecodeValue)
                value = (0, import_deuri4.decode)(value) || value;
            }
            const currentValue = result[key];
            if (currentValue === undefined)
              result[key] = value;
            else {
              if (currentValue.pop)
                currentValue.push(value);
              else
                result[key] = [currentValue, value];
            }
          }
          value = "";
          startingIndex = i;
          equalityIndex = i;
          shouldDecodeKey = false;
          shouldDecodeValue = false;
          keyHasPlus = false;
          valueHasPlus = false;
          break;
        }
        case 61:
          if (equalityIndex <= startingIndex)
            equalityIndex = i;
          else
            shouldDecodeValue = true;
          break;
        case 43:
          if (equalityIndex > startingIndex)
            valueHasPlus = true;
          else
            keyHasPlus = true;
          break;
        case 37:
          if (equalityIndex > startingIndex)
            shouldDecodeValue = true;
          else
            shouldDecodeKey = true;
          break;
      }
    }
    return result;
  };
});

// node_modules/elysia/dist/cjs/trace.js
var require_trace = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var trace_exports = {};
  __export2(trace_exports, {
    ELYSIA_TRACE: () => ELYSIA_TRACE3,
    createTracer: () => createTracer2
  });
  module.exports = __toCommonJS2(trace_exports);
  var import_utils15 = require_utils3();
  var ELYSIA_TRACE3 = Symbol("ElysiaTrace");
  var createProcess2 = () => {
    const { promise, resolve: resolve2 } = Promise.withResolvers();
    const { promise: end, resolve: resolveEnd } = Promise.withResolvers();
    const { promise: error3, resolve: resolveError } = Promise.withResolvers();
    const callbacks = [];
    const callbacksEnd = [];
    return [
      (callback) => {
        if (callback)
          callbacks.push(callback);
        return promise;
      },
      (process2) => {
        const processes = [];
        const resolvers = [];
        let groupError = null;
        for (let i = 0;i < (process2.total ?? 0); i++) {
          const { promise: promise2, resolve: resolve22 } = Promise.withResolvers();
          const { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers();
          const { promise: error22, resolve: resolveError2 } = Promise.withResolvers();
          const callbacks2 = [];
          const callbacksEnd2 = [];
          processes.push((callback) => {
            if (callback)
              callbacks2.push(callback);
            return promise2;
          });
          resolvers.push((process22) => {
            const result2 = {
              ...process22,
              end: end2,
              error: error22,
              index: i,
              onStop(callback) {
                if (callback)
                  callbacksEnd2.push(callback);
                return end2;
              }
            };
            resolve22(result2);
            for (let i2 = 0;i2 < callbacks2.length; i2++)
              callbacks2[i2](result2);
            return (error32 = null) => {
              const end3 = performance.now();
              if (error32)
                groupError = error32;
              const detail = {
                end: end3,
                error: error32,
                get elapsed() {
                  return end3 - process22.begin;
                }
              };
              for (let i2 = 0;i2 < callbacksEnd2.length; i2++)
                callbacksEnd2[i2](detail);
              resolveEnd2(end3);
              resolveError2(error32);
            };
          });
        }
        const result = {
          ...process2,
          end,
          error: error3,
          onEvent(callback) {
            for (let i = 0;i < processes.length; i++)
              processes[i](callback);
          },
          onStop(callback) {
            if (callback)
              callbacksEnd.push(callback);
            return end;
          }
        };
        resolve2(result);
        for (let i = 0;i < callbacks.length; i++)
          callbacks[i](result);
        return {
          resolveChild: resolvers,
          resolve(error22 = null) {
            const end2 = performance.now();
            if (!error22 && groupError)
              error22 = groupError;
            const detail = {
              end: end2,
              error: error22,
              get elapsed() {
                return end2 - process2.begin;
              }
            };
            for (let i = 0;i < callbacksEnd.length; i++)
              callbacksEnd[i](detail);
            resolveEnd(end2);
            resolveError(error22);
          }
        };
      }
    ];
  };
  var createTracer2 = (traceListener) => {
    return (context) => {
      const [onRequest, resolveRequest] = createProcess2();
      const [onParse, resolveParse] = createProcess2();
      const [onTransform, resolveTransform] = createProcess2();
      const [onBeforeHandle, resolveBeforeHandle] = createProcess2();
      const [onHandle, resolveHandle] = createProcess2();
      const [onAfterHandle, resolveAfterHandle] = createProcess2();
      const [onError, resolveError] = createProcess2();
      const [onMapResponse, resolveMapResponse] = createProcess2();
      const [onAfterResponse, resolveAfterResponse] = createProcess2();
      traceListener({
        id: context[import_utils15.ELYSIA_REQUEST_ID],
        context,
        set: context.set,
        onRequest,
        onParse,
        onTransform,
        onBeforeHandle,
        onHandle,
        onAfterHandle,
        onMapResponse,
        onAfterResponse,
        onError
      });
      return {
        request: resolveRequest,
        parse: resolveParse,
        transform: resolveTransform,
        beforeHandle: resolveBeforeHandle,
        handle: resolveHandle,
        afterHandle: resolveAfterHandle,
        error: resolveError,
        mapResponse: resolveMapResponse,
        afterResponse: resolveAfterResponse
      };
    };
  };
});

// node_modules/elysia/dist/cjs/compose.js
var require_compose = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var compose_exports = {};
  __export2(compose_exports, {
    composeErrorHandler: () => composeErrorHandler2,
    composeGeneralHandler: () => composeGeneralHandler2,
    composeHandler: () => composeHandler2,
    hasAdditionalProperties: () => hasAdditionalProperties2,
    hasProperty: () => hasProperty2,
    hasRef: () => hasRef,
    hasTransform: () => hasTransform2,
    hasType: () => hasType,
    isAsync: () => isAsync2,
    isAsyncName: () => isAsyncName2,
    isGenerator: () => isGenerator2
  });
  module.exports = __toCommonJS2(compose_exports);
  var import_value27 = require_value5();
  var import_typebox5 = require_cjs2();
  var import_fast_querystring3 = require_fast_querystring();
  var import_deuri4 = require_deuri();
  var import_utils15 = require_utils3();
  var import_error34 = require_error3();
  var import_error210 = require_error3();
  var import_trace4 = require_trace();
  var import_sucrose3 = require_sucrose();
  var import_cookies6 = require_cookies();
  var TypeBoxSymbol2 = {
    optional: Symbol.for("TypeBox.Optional"),
    kind: Symbol.for("TypeBox.Kind")
  };
  var isOptional2 = (validator) => {
    if (!validator)
      return false;
    const schema = validator?.schema;
    if (schema?.[TypeBoxSymbol2.kind] === "Import")
      return validator.References().some(isOptional2);
    return !!schema && TypeBoxSymbol2.optional in schema;
  };
  var allocateIf2 = (value, condition) => condition ? value : "";
  var defaultParsers2 = [
    "json",
    "text",
    "urlencoded",
    "arrayBuffer",
    "formdata",
    "application/json",
    "text/plain",
    "application/x-www-form-urlencoded",
    "application/octet-stream",
    "multipart/form-data"
  ];
  var hasAdditionalProperties2 = (_schema) => {
    if (!_schema)
      return false;
    const schema = _schema?.schema ?? _schema;
    if (schema[TypeBoxSymbol2.kind] === "Import" && _schema.References()) {
      return _schema.References().some(hasAdditionalProperties2);
    }
    if (schema.anyOf)
      return schema.anyOf.some(hasAdditionalProperties2);
    if (schema.someOf)
      return schema.someOf.some(hasAdditionalProperties2);
    if (schema.allOf)
      return schema.allOf.some(hasAdditionalProperties2);
    if (schema.not)
      return schema.not.some(hasAdditionalProperties2);
    if (schema.type === "object") {
      const properties = schema.properties;
      if ("additionalProperties" in schema)
        return schema.additionalProperties;
      if ("patternProperties" in schema)
        return false;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (property.type === "object") {
          if (hasAdditionalProperties2(property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++)
            if (hasAdditionalProperties2(property.anyOf[i]))
              return true;
        }
        return property.additionalProperties;
      }
      return false;
    }
    return false;
  };
  var createReport2 = ({
    context = "c",
    trace = [],
    addFn
  }) => {
    if (!trace.length)
      return () => {
        return {
          resolveChild() {
            return () => {};
          },
          resolve() {}
        };
      };
    for (let i = 0;i < trace.length; i++)
      addFn(`let report${i}, reportChild${i}, reportErr${i}, reportErrChild${i};let trace${i} = ${context}[ELYSIA_TRACE]?.[${i}] ?? trace[${i}](${context});
`);
    return (event, {
      name,
      total = 0
    } = {}) => {
      if (!name)
        name = "anonymous";
      const reporter = event === "error" ? "reportErr" : "report";
      for (let i = 0;i < trace.length; i++)
        addFn(`${reporter}${i} = trace${i}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`);
      return {
        resolve() {
          for (let i = 0;i < trace.length; i++)
            addFn(`${reporter}${i}.resolve()
`);
        },
        resolveChild(name2) {
          for (let i = 0;i < trace.length; i++)
            addFn(`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
          return (binding) => {
            for (let i = 0;i < trace.length; i++) {
              if (binding)
                addFn(`if(${binding} instanceof Error){${reporter}Child${i}?.(${binding}) }else{${reporter}Child${i}?.()}`);
              else
                addFn(`${reporter}Child${i}?.()
`);
            }
          };
        }
      };
    };
  };
  var composeValidationFactory2 = ({
    injectResponse = "",
    normalize = false,
    validator,
    encodeSchema = false
  }) => ({
    composeValidation: (type2, value = `c.${type2}`) => `c.set.status=422;throw new ValidationError('${type2}',validator.${type2},${value})`,
    composeResponseValidation: (name = "r") => {
      let code = injectResponse + `
`;
      code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}const isResponse=${name} instanceof Response
switch(c.set.status){`;
      for (const [status, value] of Object.entries(validator.response)) {
        code += `
case ${status}:if(!isResponse){`;
        if (normalize && "Clean" in value && !hasAdditionalProperties2(value))
          code += `${name}=validator.response['${status}'].Clean(${name})
`;
        if (encodeSchema && (value.hasTransform || typeof value.Decode === "function"))
          code += `${name}=validator.response['${status}'].Encode(${name})
`;
        code += `if(validator.response['${status}'].Check(${name})===false){c.set.status=422
throw new ValidationError('response',validator.response['${status}'],${name})}c.set.status = ${status}}
`;
        code += `break
`;
      }
      return code + "}";
    }
  });
  var KindSymbol2 = Symbol.for("TypeBox.Kind");
  var hasType = (type2, schema) => {
    if (!schema)
      return;
    if (KindSymbol2 in schema && schema[KindSymbol2] === type2)
      return true;
    if (schema.type === "object") {
      const properties = schema.properties;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (property.type === "object") {
          if (hasType(type2, property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++)
            if (hasType(type2, property.anyOf[i]))
              return true;
        }
        if (KindSymbol2 in property && property[KindSymbol2] === type2)
          return true;
      }
      return false;
    }
    return schema.properties && KindSymbol2 in schema.properties && schema.properties[KindSymbol2] === type2;
  };
  var hasProperty2 = (expectedProperty, _schema) => {
    if (!_schema)
      return;
    const schema = _schema.schema ?? _schema;
    if (schema[TypeBoxSymbol2.kind] === "Import")
      return _schema.References().some((schema2) => hasProperty2(expectedProperty, schema2));
    if (schema.type === "object") {
      const properties = schema.properties;
      if (!properties)
        return false;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (expectedProperty in property)
          return true;
        if (property.type === "object") {
          if (hasProperty2(expectedProperty, property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++) {
            if (hasProperty2(expectedProperty, property.anyOf[i]))
              return true;
          }
        }
      }
      return false;
    }
    return expectedProperty in schema;
  };
  var TransformSymbol2 = Symbol.for("TypeBox.Transform");
  var hasRef = (schema) => {
    if (!schema)
      return false;
    if (schema.oneOf) {
      for (let i = 0;i < schema.oneOf.length; i++)
        if (hasRef(schema.oneOf[i]))
          return true;
    }
    if (schema.anyOf) {
      for (let i = 0;i < schema.anyOf.length; i++)
        if (hasRef(schema.anyOf[i]))
          return true;
    }
    if (schema.oneOf) {
      for (let i = 0;i < schema.oneOf.length; i++)
        if (hasRef(schema.oneOf[i]))
          return true;
    }
    if (schema.allOf) {
      for (let i = 0;i < schema.allOf.length; i++)
        if (hasRef(schema.allOf[i]))
          return true;
    }
    if (schema.not && hasRef(schema.not))
      return true;
    if (schema.type === "object" && schema.properties) {
      const properties = schema.properties;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (hasRef(property))
          return true;
        if (property.type === "array" && property.items && hasRef(property.items))
          return true;
      }
    }
    if (schema.type === "array" && schema.items && hasRef(schema.items))
      return true;
    return schema[import_typebox5.Kind] === "Ref" && "$ref" in schema;
  };
  var hasTransform2 = (schema) => {
    if (!schema)
      return false;
    if (schema.$ref && schema.$defs && schema.$ref in schema.$defs && hasTransform2(schema.$defs[schema.$ref]))
      return true;
    if (schema.oneOf) {
      for (let i = 0;i < schema.oneOf.length; i++)
        if (hasTransform2(schema.oneOf[i]))
          return true;
    }
    if (schema.anyOf) {
      for (let i = 0;i < schema.anyOf.length; i++)
        if (hasTransform2(schema.anyOf[i]))
          return true;
    }
    if (schema.allOf) {
      for (let i = 0;i < schema.allOf.length; i++)
        if (hasTransform2(schema.allOf[i]))
          return true;
    }
    if (schema.not && hasTransform2(schema.not))
      return true;
    if (schema.type === "object" && schema.properties) {
      const properties = schema.properties;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (hasTransform2(property))
          return true;
        if (property.type === "array" && property.items && hasTransform2(property.items))
          return true;
      }
    }
    if (schema.type === "array" && schema.items && hasTransform2(schema.items))
      return true;
    return TransformSymbol2 in schema;
  };
  var matchFnReturn2 = /(?:return|=>) \S+\(/g;
  var isAsyncName2 = (v) => {
    const fn = v?.fn ?? v;
    return fn.constructor.name === "AsyncFunction";
  };
  var isAsync2 = (v) => {
    const fn = v?.fn ?? v;
    if (fn.constructor.name === "AsyncFunction")
      return true;
    const literal = fn.toString();
    if (literal.includes("=> response.clone("))
      return false;
    if (literal.includes("await"))
      return true;
    if (literal.includes("async"))
      return true;
    if (literal.includes("=>response.clone("))
      return false;
    return !!literal.match(matchFnReturn2);
  };
  var isGenerator2 = (v) => {
    const fn = v?.fn ?? v;
    return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
  };
  var composeHandler2 = ({
    app,
    path,
    method,
    hooks,
    validator,
    handler,
    allowMeta = false,
    inference,
    asManifest = false
  }) => {
    const adapter = app["~adapter"].composeHandler;
    const adapterHandler = app["~adapter"].handler;
    const isHandleFn = typeof handler === "function";
    if (!isHandleFn) {
      handler = adapterHandler.mapResponse(handler, {
        headers: app.setHeaders ?? {}
      });
      if (hooks.parse?.length && hooks.transform?.length && hooks.beforeHandle?.length && hooks.afterHandle?.length) {
        if (handler instanceof Response)
          return Function("a", `return function(){return a.clone()}`)(handler);
        return Function("a", "return function(){return a}")(handler);
      }
    }
    const handle = isHandleFn ? `handler(c)` : `handler`;
    const hasAfterResponse = !!hooks.afterResponse?.length;
    const hasTrace = !!hooks.trace?.length;
    let fnLiteral = "";
    inference = (0, import_sucrose3.sucrose)(Object.assign({}, hooks, {
      handler
    }), inference);
    if (adapter.declare) {
      const literal = adapter.declare(inference);
      if (literal)
        fnLiteral += literal;
    }
    if (inference.server)
      fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
    validator.createBody?.();
    validator.createQuery?.();
    validator.createHeaders?.();
    validator.createParams?.();
    validator.createCookie?.();
    validator.createResponse?.();
    const hasValidation = validator.body || validator.headers || validator.params || validator.query || validator.cookie || validator.response;
    const hasQuery = inference.query || !!validator.query;
    const requestNoBody = hooks.parse?.length === 1 && hooks.parse[0].fn === "none";
    const hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || !!hooks.parse?.length) && !requestNoBody;
    if (hasBody)
      fnLiteral += `let isParsing=false
`;
    const defaultHeaders = app.setHeaders;
    const hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length;
    const hasHeaders = inference.headers || validator.headers || adapter.preferWebstandardHeaders !== true && inference.body;
    const hasCookie = inference.cookie || !!validator.cookie;
    const cookieValidator = hasCookie ? (0, import_utils15.getCookieValidator)({
      modules: app.definitions.typebox,
      validator: validator.cookie,
      defaultConfig: app.config.cookie,
      dynamic: !!app.config.aot,
      config: validator.cookie?.config ?? {},
      models: app.definitions.type
    }) : undefined;
    const cookieMeta = cookieValidator?.config;
    let encodeCookie = "";
    if (cookieMeta?.sign) {
      if (!cookieMeta.secrets)
        throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
      const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`;
      if (cookieMeta.sign === true) {
        encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
      } else
        for (const name of cookieMeta.sign)
          encodeCookie += `if(_setCookie['${name}']?.value){c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')}`;
      encodeCookie += `}
`;
    }
    const normalize = app.config.normalize;
    const encodeSchema = app.config.experimental?.encodeSchema;
    const { composeValidation, composeResponseValidation } = composeValidationFactory2({
      normalize,
      validator,
      encodeSchema
    });
    if (hasHeaders)
      fnLiteral += adapter.headers;
    if (hasTrace)
      fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
    const report = createReport2({
      trace: hooks.trace,
      addFn: (word) => {
        fnLiteral += word;
      }
    });
    fnLiteral += "try{";
    if (hasCookie) {
      const get = (name, defaultValue) => {
        const value = cookieMeta?.[name] ?? defaultValue;
        if (!value)
          return typeof defaultValue === "string" ? `${name}:"${defaultValue}",` : `${name}:${defaultValue},`;
        if (typeof value === "string")
          return `${name}:'${value}',`;
        if (value instanceof Date)
          return `${name}: new Date(${value.getTime()}),`;
        return `${name}:${value},`;
      };
      const options = cookieMeta ? `{secrets:${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` + get("domain") + get("expires") + get("httpOnly") + get("maxAge") + get("path", "/") + get("priority") + get("sameSite") + get("secure") + "}" : "undefined";
      if (hasHeaders)
        fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
      else
        fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
    }
    if (hasQuery) {
      const destructured = [];
      if (validator.query && validator.query.schema.type === "object") {
        const properties = validator.query.schema.properties;
        if (!hasAdditionalProperties2(validator.query))
          for (let [key, _value] of Object.entries(properties)) {
            let value = _value;
            const isArray = value.type === "array" || !!value.anyOf?.some((v) => v.type === "string" && v.format === "ArrayString");
            if (value && TypeBoxSymbol2.optional in value && value.type === "array" && value.items)
              value = value.items;
            const { type: type2, anyOf } = value;
            destructured.push({
              key,
              isArray,
              isNestedObjectArray: isArray && value.items?.type === "object" || !!value.items?.anyOf?.some((x) => x.type === "object" || x.type === "array"),
              isObject: type2 === "object" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString"),
              anyOf: !!anyOf
            });
          }
      }
      if (!destructured.length) {
        fnLiteral += "if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url.slice(c.qi + 1))}";
      } else {
        fnLiteral += `if(c.qi!==-1){let url='&'+c.url.slice(c.qi + 1)
`;
        let index = 0;
        for (const {
          key,
          isArray,
          isObject: isObject2,
          isNestedObjectArray,
          anyOf
        } of destructured) {
          const init2 = (index === 0 ? "let " : "") + `memory=url.indexOf('&${key}=')
let a${index}
`;
          if (isArray) {
            fnLiteral += init2;
            if (isNestedObjectArray)
              fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)
a${index}=''
else
a${index}+=','
let temp
if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else temp=decodeURIComponent(url.slice(start, memory).replace(/\\+/g,' '))
const charCode=temp.charCodeAt(0)
if(charCode!==91&&charCode !== 123)
temp='"'+temp+'"'
a${index}+=temp
if(memory===-1)break
memory=url.indexOf('&${key}=',memory)
if(memory===-1)break}try{if(a${index}.charCodeAt(0)===91)a${index} = JSON.parse(a${index})
else
a${index}=JSON.parse('['+a${index}+']')}catch{}
`;
            else
              fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)a${index}=[]
if(memory===-1){const temp=decodeURIComponent(url.slice(start)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(decodeURIComponent(url.slice(start)).replace(/\\+/g,' '))}
break}else{const temp=decodeURIComponent(url.slice(start, memory)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(temp)}
}memory=url.indexOf('&${key}=',memory)
if(memory===-1) break
}`;
          } else if (isObject2)
            fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))else a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))if(a${index}!==undefined)try{a${index}=JSON.parse(a${index})}catch{}}`;
          else {
            fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else{a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))`;
            if (anyOf)
              fnLiteral += `
let deepMemory=url.indexOf('&${key}=',memory)
if(deepMemory!==-1){a${index}=[a${index}]
let first=true
while(true){const start=deepMemory+${key.length + 2}
if(first)first=false
else deepMemory = url.indexOf('&', start)
let value
if(deepMemory===-1)value=url.slice(start).replace(/\\+/g,' ')
else value=url.slice(start, deepMemory).replace(/\\+/g,' ')
value=decodeURIComponent(value)
if(value===null){if(deepMemory===-1){break}else{continue}}
const vStart=value.charCodeAt(0)
const vEnd=value.charCodeAt(value.length - 1)
if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))
try{a${index}.push(JSON.parse(value))}catch{a${index}.push(value)}if(deepMemory===-1)break}}`;
            fnLiteral += "}}";
          }
          index++;
          fnLiteral += `
`;
        }
        fnLiteral += `c.query={` + destructured.map(({ key }, index2) => `'${key}':a${index2}`).join(",") + `}`;
        fnLiteral += `} else c.query = {}
`;
      }
    }
    const isAsyncHandler = typeof handler === "function" && isAsync2(handler);
    const saveResponse = hasTrace || hooks.afterResponse?.length ? "c.response= " : "";
    const maybeAsync = hasCookie || hasBody || isAsyncHandler || !!hooks.parse?.length || !!hooks.afterHandle?.some(isAsync2) || !!hooks.beforeHandle?.some(isAsync2) || !!hooks.transform?.some(isAsync2) || !!hooks.mapResponse?.some(isAsync2);
    const maybeStream = (typeof handler === "function" ? isGenerator2(handler) : false) || !!hooks.beforeHandle?.some(isGenerator2) || !!hooks.afterHandle?.some(isGenerator2) || !!hooks.transform?.some(isGenerator2);
    const hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || validator.response || isHandleFn && hasDefaultHeaders || maybeStream;
    const mapResponseContext = adapter.mapResponseContext ? `,${adapter.mapResponseContext}` : "";
    if (hasTrace || inference.route)
      fnLiteral += `c.route=\`${path}\`
`;
    const parseReporter = report("parse", {
      total: hooks.parse?.length
    });
    if (hasBody) {
      const isOptionalBody = isOptional2(validator.body);
      const hasBodyInference = !!hooks.parse?.length || inference.body || validator.body;
      if (adapter.parser.declare)
        fnLiteral += adapter.parser.declare;
      fnLiteral += `
isParsing=true
`;
      const parser = typeof hooks.parse === "string" ? hooks.parse : Array.isArray(hooks.parse) && hooks.parse.length === 1 ? typeof hooks.parse[0] === "string" ? hooks.parse[0] : typeof hooks.parse[0].fn === "string" ? hooks.parse[0].fn : undefined : undefined;
      if (parser && defaultParsers2.includes(parser)) {
        const reporter = report("parse", {
          total: hooks.parse?.length
        });
        switch (parser) {
          case "json":
          case "application/json":
            fnLiteral += adapter.parser.json(isOptionalBody);
            break;
          case "text":
          case "text/plain":
            fnLiteral += adapter.parser.text(isOptionalBody);
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            fnLiteral += adapter.parser.urlencoded(isOptionalBody);
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
            break;
          case "formdata":
          case "multipart/form-data":
            fnLiteral += adapter.parser.formData(isOptionalBody);
            break;
          default:
            if (parser[0] in app["~parser"]) {
              fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
              fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`;
              fnLiteral += `let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`;
            }
            break;
        }
        reporter.resolve();
      } else if (hasBodyInference) {
        fnLiteral += `
`;
        fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
        fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`;
        if (hooks.parse?.length)
          fnLiteral += `let used=false
`;
        const reporter = report("parse", {
          total: hooks.parse?.length
        });
        let hasDefaultParser = false;
        if (hooks.parse)
          for (let i = 0;i < hooks.parse.length; i++) {
            const name = `bo${i}`;
            if (i !== 0)
              fnLiteral += `
if(!used){`;
            if (typeof hooks.parse[i].fn === "string") {
              const endUnit = reporter.resolveChild(hooks.parse[i].fn);
              switch (hooks.parse[i].fn) {
                case "json":
                case "application/json":
                  hasDefaultParser = true;
                  fnLiteral += adapter.parser.json(isOptionalBody);
                  break;
                case "text":
                case "text/plain":
                  hasDefaultParser = true;
                  fnLiteral += adapter.parser.text(isOptionalBody);
                  break;
                case "urlencoded":
                case "application/x-www-form-urlencoded":
                  hasDefaultParser = true;
                  fnLiteral += adapter.parser.urlencoded(isOptionalBody);
                  break;
                case "arrayBuffer":
                case "application/octet-stream":
                  hasDefaultParser = true;
                  fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
                  break;
                case "formdata":
                case "multipart/form-data":
                  hasDefaultParser = true;
                  fnLiteral += adapter.parser.formData(isOptionalBody);
                  break;
                default:
                  fnLiteral += `${name}=parser['${hooks.parse[i].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}
`;
              }
              endUnit();
            } else {
              const endUnit = reporter.resolveChild(hooks.parse[i].fn.name);
              fnLiteral += `let ${name}=e.parse[${i}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`;
              endUnit();
            }
            if (i !== 0)
              fnLiteral += `}`;
            if (hasDefaultParser)
              break;
          }
        reporter.resolve();
        if (!hasDefaultParser) {
          if (hooks.parse?.length)
            fnLiteral += `
if(!used){
if(!contentType) throw new ParseError()
`;
          fnLiteral += `switch(contentType){`;
          fnLiteral += `case 'application/json':
` + adapter.parser.json(isOptionalBody) + `break
case 'text/plain':` + adapter.parser.text(isOptionalBody) + `break
case 'application/x-www-form-urlencoded':` + adapter.parser.urlencoded(isOptionalBody) + `break
case 'application/octet-stream':` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 'multipart/form-data':` + adapter.parser.formData(isOptionalBody) + `break
`;
          for (const key of Object.keys(app["~parser"]))
            fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse)throw result
if(bo${key}!==undefined)c.body=bo${key}
break
`;
          if (hooks.parse?.length)
            fnLiteral += "}";
          fnLiteral += "}";
        }
      }
      fnLiteral += `
delete c.contentType`;
      fnLiteral += `
isParsing=false
`;
    }
    parseReporter.resolve();
    if (hooks?.transform) {
      const reporter = report("transform", {
        total: hooks.transform.length
      });
      if (hooks.transform.length)
        fnLiteral += `let transformed
`;
      for (let i = 0;i < hooks.transform.length; i++) {
        const transform2 = hooks.transform[i];
        const endUnit = reporter.resolveChild(transform2.fn.name);
        fnLiteral += isAsync2(transform2) ? `transformed=await e.transform[${i}](c)
` : `transformed=e.transform[${i}](c)
`;
        if (transform2.subType === "mapDerive")
          fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
        else
          fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else Object.assign(c,transformed)
`;
        endUnit();
      }
      reporter.resolve();
    }
    if (validator) {
      if (validator.headers) {
        if (normalize && "Clean" in validator.headers && !hasAdditionalProperties2(validator.headers))
          fnLiteral += `c.headers=validator.headers.Clean(c.headers);
`;
        if (hasProperty2("default", validator.headers))
          for (const [key, value] of Object.entries(import_value27.Value.Default(validator.headers.schema, {}))) {
            const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
            if (parsed !== undefined)
              fnLiteral += `c.headers['${key}']??=${parsed}
`;
          }
        if (isOptional2(validator.headers))
          fnLiteral += `if(isNotEmpty(c.headers)){`;
        fnLiteral += `if(validator.headers.Check(c.headers) === false){` + composeValidation("headers") + "}";
        if (hasTransform2(validator.headers.schema))
          fnLiteral += `c.headers=validator.headers.Decode(c.headers)
`;
        if (isOptional2(validator.headers))
          fnLiteral += "}";
      }
      if (validator.params) {
        if (hasProperty2("default", validator.params))
          for (const [key, value] of Object.entries(import_value27.Value.Default(validator.params.schema, {}))) {
            const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
            if (parsed !== undefined)
              fnLiteral += `c.params['${key}']??=${parsed}
`;
          }
        fnLiteral += `if(validator.params.Check(c.params)===false){` + composeValidation("params") + "}";
        if (hasTransform2(validator.params.schema))
          fnLiteral += `c.params=validator.params.Decode(c.params)
`;
      }
      if (validator.query) {
        if (normalize && "Clean" in validator.query && !hasAdditionalProperties2(validator.query))
          fnLiteral += `c.query=validator.query.Clean(c.query)
`;
        if (hasProperty2("default", validator.query))
          for (const [key, value] of Object.entries(import_value27.Value.Default(validator.query.schema, {}))) {
            const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
            if (parsed !== undefined)
              fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
          }
        if (isOptional2(validator.query))
          fnLiteral += `if(isNotEmpty(c.query)){`;
        fnLiteral += `if(validator.query.Check(c.query)===false){` + composeValidation("query") + `}`;
        if (hasTransform2(validator.query.schema))
          fnLiteral += `c.query=validator.query.Decode(Object.assign({},c.query))
`;
        if (isOptional2(validator.query))
          fnLiteral += `}`;
      }
      if (validator.body) {
        if (normalize && "Clean" in validator.body && !hasAdditionalProperties2(validator.body))
          fnLiteral += `c.body=validator.body.Clean(c.body)
`;
        const doesHaveTransform = hasTransform2(validator.body.schema);
        if (doesHaveTransform || isOptional2(validator.body))
          fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&isNotEmpty(c.body))
`;
        if (hasProperty2("default", validator.body)) {
          const schema = validator.body.schema;
          const value = import_value27.Value.Default(schema, schema.type === "object" || schema[TypeBoxSymbol2.kind] === "Import" && schema.$defs[schema.$ref][TypeBoxSymbol2.kind] === "Object" ? {} : undefined);
          const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          fnLiteral += `if(validator.body.Check(c.body)===false){`;
          if (value !== undefined && value !== null)
            fnLiteral += `if(typeof c.body==='object')c.body=Object.assign(${parsed},c.body)
else c.body=${parsed}
`;
          if (isOptional2(validator.body))
            fnLiteral += `if(isNotEmptyObject&&validator.body.Check(c.body)===false){` + composeValidation("body") + "}";
          else
            fnLiteral += `if(validator.body.Check(c.body)===false){` + composeValidation("body") + `}`;
          fnLiteral += "}";
        } else {
          if (isOptional2(validator.body))
            fnLiteral += `if(isNotEmptyObject&&validator.body.Check(c.body)===false){` + composeValidation("body") + "}";
          else
            fnLiteral += `if(validator.body.Check(c.body)===false){` + composeValidation("body") + "}";
        }
        if (doesHaveTransform)
          fnLiteral += `if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`;
      }
      if (cookieValidator && (0, import_utils15.isNotEmpty)(cookieValidator?.schema?.properties ?? cookieValidator?.schema?.schema ?? {})) {
        fnLiteral += `const cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`;
        if (hasProperty2("default", cookieValidator))
          for (const [key, value] of Object.entries(import_value27.Value.Default(cookieValidator.schema, {}))) {
            fnLiteral += `cookieValue['${key}'] = ${typeof value === "object" ? JSON.stringify(value) : value}
`;
          }
        if (isOptional2(validator.cookie))
          fnLiteral += `if(isNotEmpty(c.cookie)){`;
        fnLiteral += `if(validator.cookie.Check(cookieValue)===false){` + composeValidation("cookie", "cookieValue") + "}";
        if (hasTransform2(validator.cookie.schema))
          fnLiteral += `for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))c.cookie[key].value=value
`;
        if (isOptional2(validator.cookie))
          fnLiteral += `}`;
      }
    }
    if (hooks?.beforeHandle) {
      const reporter = report("beforeHandle", {
        total: hooks.beforeHandle.length
      });
      let hasResolve = false;
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        const beforeHandle = hooks.beforeHandle[i];
        const endUnit = reporter.resolveChild(beforeHandle.fn.name);
        const returning = (0, import_sucrose3.hasReturn)(beforeHandle);
        const isResolver = beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve";
        if (isResolver) {
          if (!hasResolve) {
            hasResolve = true;
            fnLiteral += `
let resolved
`;
          }
          fnLiteral += isAsync2(beforeHandle) ? `resolved=await e.beforeHandle[${i}](c);
` : `resolved=e.beforeHandle[${i}](c);
`;
          if (beforeHandle.subType === "mapResolve")
            fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else{resolved.request = c.request
resolved.store = c.store
resolved.qi = c.qi
resolved.path = c.path
resolved.url = c.url
resolved.redirect = c.redirect
resolved.set = c.set
resolved.error = c.error
c = resolved}`;
          else
            fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else Object.assign(c, resolved)
`;
        } else if (!returning) {
          fnLiteral += isAsync2(beforeHandle) ? `await e.beforeHandle[${i}](c)
` : `e.beforeHandle[${i}](c)
`;
          endUnit();
        } else {
          fnLiteral += isAsync2(beforeHandle) ? `be=await e.beforeHandle[${i}](c)
` : `be=e.beforeHandle[${i}](c)
`;
          endUnit("be");
          fnLiteral += `if(be!==undefined){`;
          reporter.resolve();
          if (hooks.afterHandle?.length) {
            report("handle", {
              name: isHandleFn ? handler.name : undefined
            }).resolve();
            const reporter2 = report("afterHandle", {
              total: hooks.afterHandle.length
            });
            for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
              const hook = hooks.afterHandle[i2];
              const returning2 = (0, import_sucrose3.hasReturn)(hook);
              const endUnit2 = reporter2.resolveChild(hook.fn.name);
              fnLiteral += `c.response = be
`;
              if (!returning2) {
                fnLiteral += isAsync2(hook.fn) ? `await e.afterHandle[${i2}](c, be)
` : `e.afterHandle[${i2}](c, be)
`;
              } else {
                fnLiteral += isAsync2(hook.fn) ? `af = await e.afterHandle[${i2}](c)
` : `af = e.afterHandle[${i2}](c)
`;
                fnLiteral += `if(af!==undefined) c.response=be=af
`;
              }
              endUnit2("af");
            }
            reporter2.resolve();
          }
          if (validator.response)
            fnLiteral += composeResponseValidation("be");
          const mapResponseReporter = report("mapResponse", {
            total: hooks.mapResponse?.length
          });
          if (hooks.mapResponse?.length) {
            fnLiteral += `c.response=be
`;
            for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
              const mapResponse3 = hooks.mapResponse[i2];
              const endUnit2 = mapResponseReporter.resolveChild(mapResponse3.fn.name);
              fnLiteral += `if(mr===undefined){mr=${isAsyncName2(mapResponse3) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)be=c.response=mr}`;
              endUnit2();
            }
          }
          mapResponseReporter.resolve();
          fnLiteral += encodeCookie;
          fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`;
        }
      }
      reporter.resolve();
    }
    if (hooks.afterHandle?.length) {
      const handleReporter = report("handle", {
        name: isHandleFn ? handler.name : undefined
      });
      if (hooks.afterHandle.length)
        fnLiteral += isAsyncHandler ? `let r=c.response=await ${handle}
` : `let r=c.response=${handle}
`;
      else
        fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
      handleReporter.resolve();
      const reporter = report("afterHandle", {
        total: hooks.afterHandle.length
      });
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        const hook = hooks.afterHandle[i];
        const returning = (0, import_sucrose3.hasReturn)(hook);
        const endUnit = reporter.resolveChild(hook.fn.name);
        if (!returning) {
          fnLiteral += isAsync2(hook.fn) ? `await e.afterHandle[${i}](c)
` : `e.afterHandle[${i}](c)
`;
          endUnit();
        } else {
          fnLiteral += isAsync2(hook.fn) ? `af=await e.afterHandle[${i}](c)
` : `af=e.afterHandle[${i}](c)
`;
          endUnit("af");
          if (validator.response) {
            fnLiteral += `if(af!==undefined){`;
            reporter.resolve();
            fnLiteral += composeResponseValidation("af");
            fnLiteral += `c.response=af}`;
          } else {
            fnLiteral += `if(af!==undefined){`;
            reporter.resolve();
            fnLiteral += `c.response=af}`;
          }
        }
      }
      reporter.resolve();
      fnLiteral += `r=c.response
`;
      if (validator.response)
        fnLiteral += composeResponseValidation();
      fnLiteral += encodeCookie;
      const mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse?.length
      });
      if (hooks.mapResponse?.length) {
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          const mapResponse3 = hooks.mapResponse[i];
          const endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
          fnLiteral += `mr=${isAsyncName2(mapResponse3) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr
`;
          endUnit();
        }
      }
      mapResponseReporter.resolve();
      if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
    } else {
      const handleReporter = report("handle", {
        name: isHandleFn ? handler.name : undefined
      });
      if (validator.response || hooks.mapResponse?.length) {
        fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
        handleReporter.resolve();
        if (validator.response)
          fnLiteral += composeResponseValidation();
        report("afterHandle").resolve();
        const mapResponseReporter = report("mapResponse", {
          total: hooks.mapResponse?.length
        });
        if (hooks.mapResponse?.length) {
          fnLiteral += `
c.response=r
`;
          for (let i = 0;i < hooks.mapResponse.length; i++) {
            const mapResponse3 = hooks.mapResponse[i];
            const endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
            fnLiteral += `
if(mr===undefined){mr=${isAsyncName2(mapResponse3) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}
`;
            endUnit();
          }
        }
        mapResponseReporter.resolve();
        fnLiteral += encodeCookie;
        if (handler instanceof Response) {
          fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})else return ${handle}.clone()` : `return ${handle}.clone()`;
          fnLiteral += `
`;
        } else if (hasSet)
          fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
        else
          fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
      } else if (hasCookie || hasTrace) {
        fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
        handleReporter.resolve();
        report("afterHandle").resolve();
        const mapResponseReporter = report("mapResponse", {
          total: hooks.mapResponse?.length
        });
        if (hooks.mapResponse?.length) {
          fnLiteral += `c.response= r
`;
          for (let i = 0;i < hooks.mapResponse.length; i++) {
            const mapResponse3 = hooks.mapResponse[i];
            const endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
            fnLiteral += `if(mr===undefined){mr=${isAsyncName2(mapResponse3) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}`;
            endUnit();
          }
        }
        mapResponseReporter.resolve();
        fnLiteral += encodeCookie;
        if (hasSet)
          fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
        else
          fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
      } else {
        handleReporter.resolve();
        const handled = isAsyncHandler ? `await ${handle}` : handle;
        report("afterHandle").resolve();
        if (handler instanceof Response) {
          fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
` : `return ${handle}.clone()
`;
        } else if (hasSet)
          fnLiteral += `return mapResponse(${saveResponse}${handled},c.set${mapResponseContext})
`;
        else
          fnLiteral += `return mapCompactResponse(${saveResponse}${handled}${mapResponseContext})
`;
      }
    }
    fnLiteral += `
}catch(error){`;
    if (hasBody)
      fnLiteral += `if(isParsing)error=new ParseError()
`;
    if (!maybeAsync)
      fnLiteral += `return(async()=>{`;
    fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`;
    if (hasTrace && hooks.trace)
      for (let i = 0;i < hooks.trace.length; i++)
        fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)
`;
    const errorReporter = report("error", {
      total: hooks.error?.length
    });
    if (hooks.error?.length) {
      fnLiteral += `c.error=error
`;
      if (hasValidation)
        fnLiteral += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}`;
      else
        fnLiteral += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`;
      fnLiteral += `let er
`;
      for (let i = 0;i < hooks.error.length; i++) {
        const endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
        if (isAsync2(hooks.error[i]))
          fnLiteral += `er=await e.error[${i}](c)
`;
        else
          fnLiteral += `er=e.error[${i}](c)
if(er instanceof Promise)er=await er
`;
        endUnit();
        const mapResponseReporter = report("mapResponse", {
          total: hooks.mapResponse?.length
        });
        if (hooks.mapResponse?.length) {
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            const mapResponse3 = hooks.mapResponse[i2];
            const endUnit2 = mapResponseReporter.resolveChild(mapResponse3.fn.name);
            fnLiteral += `c.response=er
er=e.mapResponse[${i2}](c)
if(er instanceof Promise)er=await er
`;
            endUnit2();
          }
        }
        mapResponseReporter.resolve();
        fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`;
        fnLiteral += `if(er){`;
        if (hasTrace && hooks.trace) {
          for (let i2 = 0;i2 < hooks.trace.length; i2++)
            fnLiteral += `report${i2}.resolve()
`;
          errorReporter.resolve();
        }
        fnLiteral += `return er}`;
      }
    }
    errorReporter.resolve();
    fnLiteral += `return handleError(c,error,true)`;
    if (!maybeAsync)
      fnLiteral += "})()";
    fnLiteral += "}";
    if (hasAfterResponse || hasTrace) {
      fnLiteral += `finally{ `;
      if (!maybeAsync)
        fnLiteral += ";(async()=>{";
      const reporter = report("afterResponse", {
        total: hooks.afterResponse?.length
      });
      if (hasAfterResponse && hooks.afterResponse) {
        for (let i = 0;i < hooks.afterResponse.length; i++) {
          const endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name);
          fnLiteral += `
await e.afterResponse[${i}](c)
`;
          endUnit();
        }
      }
      reporter.resolve();
      if (!maybeAsync)
        fnLiteral += "})()";
      fnLiteral += `}`;
    }
    const adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
    let init = `const {handler,handleError,hooks:e, ` + allocateIf2(`validator,`, hasValidation) + `mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{` + allocateIf2(`parseQuery,`, hasBody) + allocateIf2(`parseQueryFromURL,`, hasQuery) + `},error:{` + allocateIf2(`ValidationError,`, hasValidation) + `InternalServerError,` + allocateIf2(`ParseError`, hasBody) + `},schema,definitions,ERROR_CODE,` + allocateIf2(`parseCookie,`, hasCookie) + allocateIf2(`signCookie,`, hasCookie) + allocateIf2(`decodeURIComponent,`, hasQuery) + `ElysiaCustomStatusResponse,` + allocateIf2(`ELYSIA_TRACE,`, hasTrace) + allocateIf2(`ELYSIA_REQUEST_ID,`, hasTrace) + allocateIf2("parser,", hooks.parse?.length) + allocateIf2(`getServer,`, inference.server) + adapterVariables + allocateIf2("TypeBoxError", hasValidation) + `}=hooks
const trace=e.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
return ${maybeAsync ? "async " : ""}function handle(c){`;
    if (hooks.beforeHandle?.length)
      init += `let be
`;
    if (hooks.afterHandle?.length)
      init += `let af
`;
    if (hooks.mapResponse?.length)
      init += `let mr
`;
    if (allowMeta)
      init += `c.schema = schema
c.defs = definitions
`;
    init += fnLiteral + "}";
    try {
      if (asManifest)
        return Function("hooks", init);
      return Function("hooks", init)({
        handler,
        hooks: (0, import_utils15.lifeCycleToFn)(hooks),
        validator: hasValidation ? validator : undefined,
        handleError: app.handleError,
        mapResponse: adapterHandler.mapResponse,
        mapCompactResponse: adapterHandler.mapCompactResponse,
        mapEarlyResponse: adapterHandler.mapEarlyResponse,
        isNotEmpty: import_utils15.isNotEmpty,
        utils: {
          parseQuery: hasBody ? import_fast_querystring3.parseQuery : undefined,
          parseQueryFromURL: hasQuery ? import_fast_querystring3.parseQueryFromURL : undefined
        },
        error: {
          ValidationError: hasValidation ? import_error210.ValidationError : undefined,
          InternalServerError: import_error210.InternalServerError,
          ParseError: hasBody ? import_error34.ParseError : undefined
        },
        schema: app.router.history,
        definitions: app.definitions.type,
        ERROR_CODE: import_error210.ERROR_CODE,
        parseCookie: hasCookie ? import_cookies6.parseCookie : undefined,
        signCookie: hasCookie ? import_utils15.signCookie : undefined,
        decodeURIComponent: hasQuery ? import_deuri4.decode : undefined,
        ElysiaCustomStatusResponse: import_error210.ElysiaCustomStatusResponse,
        ELYSIA_TRACE: hasTrace ? import_trace4.ELYSIA_TRACE : undefined,
        ELYSIA_REQUEST_ID: hasTrace ? import_utils15.ELYSIA_REQUEST_ID : undefined,
        getServer: () => app.getServer(),
        TypeBoxError: hasValidation ? import_typebox5.TypeBoxError : undefined,
        parser: app["~parser"],
        ...adapter.inject
      });
    } catch (error22) {
      const debugHooks = (0, import_utils15.lifeCycleToFn)(hooks);
      console.log("[Composer] failed to generate optimized handler");
      console.log("---");
      console.log({
        handler: typeof handler === "function" ? handler.toString() : handler,
        instruction: init,
        hooks: {
          ...debugHooks,
          transform: debugHooks?.transform?.map?.((x) => x.toString()),
          resolve: debugHooks?.resolve?.map?.((x) => x.toString()),
          beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()),
          afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()),
          mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()),
          parse: debugHooks?.parse?.map?.((x) => x.toString()),
          error: debugHooks?.error?.map?.((x) => x.toString()),
          afterResponse: debugHooks?.afterResponse?.map?.((x) => x.toString()),
          stop: debugHooks?.stop?.map?.((x) => x.toString())
        },
        validator,
        definitions: app.definitions.type,
        error: error22,
        fnLiteral
      });
      console.log("---");
      process.exit(1);
    }
  };
  var composeGeneralHandler2 = (app, { asManifest = false } = {}) => {
    const adapter = app["~adapter"].composeGeneralHandler;
    app.router.http.build();
    const error404 = adapter.error404(!!app.event.request?.length, !!app.event.error?.length);
    const hasTrace = app.event.trace?.length;
    let fnLiteral = "";
    const router = app.router;
    let findDynamicRoute = `const route=router.find(r.method,p)`;
    findDynamicRoute += router.http.root.ALL ? `??router.find("ALL",p)
` : `
`;
    findDynamicRoute += error404.code;
    findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)
`;
    let switchMap = ``;
    for (const [path, v] of Object.entries(router.static.http.map)) {
      switchMap += `case'${path}':`;
      if (app.config.strictPath !== true)
        switchMap += `case'${(0, import_utils15.getLoosePath)(path)}':`;
      const encoded = (0, import_utils15.encodePath)(path);
      if (path !== encoded)
        switchMap += `case'${encoded}':`;
      switchMap += `switch(r.method){${v.code}
` + (v.all ?? `default: break map`) + "}";
    }
    const maybeAsync = !!app.event.request?.some(isAsync2);
    const adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
    fnLiteral += `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,error,redirect,` + allocateIf2(`ELYSIA_TRACE,`, hasTrace) + allocateIf2(`ELYSIA_REQUEST_ID,`, hasTrace) + adapterVariables + `}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`;
    if (app.event.request?.length)
      fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
    fnLiteral += error404.declare;
    if (app.event.trace?.length)
      fnLiteral += `const ` + app.event.trace.map((_, i) => `tr${i}=app.event.trace[${i}].fn`).join(",") + `
`;
    fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`;
    if (app.event.request?.length)
      fnLiteral += `let re
`;
    fnLiteral += adapter.createContext(app);
    if (app.event.trace?.length)
      fnLiteral += `c[ELYSIA_TRACE]=[` + app.event.trace.map((_, i) => `tr${i}(c)`).join(",") + `]
`;
    const report = createReport2({
      trace: app.event.trace,
      addFn(word) {
        fnLiteral += word;
      }
    });
    const reporter = report("request", {
      total: app.event.request?.length
    });
    if (app.event.request?.length) {
      fnLiteral += `try{`;
      for (let i = 0;i < app.event.request.length; i++) {
        const hook = app.event.request[i];
        const withReturn = (0, import_sucrose3.hasReturn)(hook);
        const maybeAsync2 = isAsync2(hook);
        const endUnit = reporter.resolveChild(app.event.request[i].fn.name);
        if (withReturn) {
          fnLiteral += `re=mapEarlyResponse(${maybeAsync2 ? "await " : ""}onRequest[${i}](c),c.set)
`;
          endUnit("re");
          fnLiteral += `if(re!==undefined)return re
`;
        } else {
          fnLiteral += `${maybeAsync2 ? "await " : ""}onRequest[${i}](c)
`;
          endUnit();
        }
      }
      fnLiteral += `}catch(error){return app.handleError(c,error,false)}`;
    }
    reporter.resolve();
    fnLiteral += adapter.websocket(app);
    fnLiteral += `
map:switch(p){
` + switchMap + `default:break}` + findDynamicRoute + `}
`;
    if (app.extender.higherOrderFunctions.length) {
      let handler = "map";
      for (let i = 0;i < app.extender.higherOrderFunctions.length; i++)
        handler = `hoc[${i}](${handler},${adapter.parameters})`;
      fnLiteral += `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
    } else
      fnLiteral += `return map`;
    const handleError = composeErrorHandler2(app);
    app.handleError = handleError;
    return Function("data", fnLiteral)({
      app,
      mapEarlyResponse: app["~adapter"]["handler"].mapEarlyResponse,
      NotFoundError: import_error210.NotFoundError,
      randomId: import_utils15.randomId,
      handleError,
      error: import_error34.error,
      redirect: import_utils15.redirect,
      ELYSIA_TRACE: hasTrace ? import_trace4.ELYSIA_TRACE : undefined,
      ELYSIA_REQUEST_ID: hasTrace ? import_utils15.ELYSIA_REQUEST_ID : undefined,
      ...adapter.inject
    });
  };
  var composeErrorHandler2 = (app) => {
    const hooks = app.event;
    let fnLiteral = "";
    const adapter = app["~adapter"].composeError;
    const adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
    const hasTrace = !!app.event.trace?.length;
    fnLiteral += `const {app:{event:{error:onErrorContainer,afterResponse:resContainer,mapResponse:_onMapResponse,trace:_trace}},mapResponse,ERROR_CODE,ElysiaCustomStatusResponse,` + allocateIf2(`ELYSIA_TRACE,`, hasTrace) + allocateIf2(`ELYSIA_REQUEST_ID,`, hasTrace) + adapterVariables + `}=inject
`;
    fnLiteral += `const trace=_trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const onMapResponse=[]
if(_onMapResponse)for(let i=0;i<_onMapResponse.length;i++)onMapResponse.push(_onMapResponse[i].fn??_onMapResponse[i])
delete _onMapResponse
const onError=onErrorContainer?.map(x=>x.fn)??[]
const res=resContainer?.map(x=>x.fn)??[]
return ${app.event.error?.find(isAsync2) || app.event.mapResponse?.find(isAsync2) ? "async " : ""}function(context,error,skipGlobal){`;
    fnLiteral += "";
    if (hasTrace)
      fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
    const report = createReport2({
      context: "context",
      trace: hooks.trace,
      addFn: (word) => {
        fnLiteral += word;
      }
    });
    fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`;
    if (adapter.declare)
      fnLiteral += adapter.declare;
    const saveResponse = hasTrace || !!hooks.afterResponse?.length || !!hooks.afterResponse?.length ? "context.response = " : "";
    if (app.event.error)
      for (let i = 0;i < app.event.error.length; i++) {
        const handler = app.event.error[i];
        const response = `${isAsync2(handler) ? "await " : ""}onError[${i}](context)
`;
        fnLiteral += "if(skipGlobal!==true){";
        if ((0, import_sucrose3.hasReturn)(handler)) {
          fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response)return mapResponse(_r,set${adapter.mapResponseContext})
if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
          const mapResponseReporter2 = report("mapResponse", {
            total: hooks.mapResponse?.length,
            name: "context"
          });
          if (hooks.mapResponse?.length) {
            for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
              const mapResponse3 = hooks.mapResponse[i2];
              const endUnit = mapResponseReporter2.resolveChild(mapResponse3.fn.name);
              fnLiteral += `context.response=_r_r=${isAsyncName2(mapResponse3) ? "await " : ""}onMapResponse[${i2}](context)
`;
              endUnit();
            }
          }
          mapResponseReporter2.resolve();
          fnLiteral += `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`;
        } else
          fnLiteral += response;
        fnLiteral += "}";
      }
    fnLiteral += `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){if(error.error)error=error.error
set.status=error.status??422
` + adapter.validationError + `}`;
    fnLiteral += `if(error instanceof Error){` + adapter.unknownError + `}`;
    const mapResponseReporter = report("mapResponse", {
      total: hooks.mapResponse?.length,
      name: "context"
    });
    fnLiteral += `
if(!context.response)context.response=error.message??error
`;
    if (hooks.mapResponse?.length) {
      fnLiteral += `let mr
`;
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        const mapResponse3 = hooks.mapResponse[i];
        const endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
        fnLiteral += `if(mr===undefined){mr=${isAsyncName2(mapResponse3) ? "await " : ""}onMapResponse[${i}](context)
if(mr!==undefined)error=context.response=mr}`;
        endUnit();
      }
    }
    mapResponseReporter.resolve();
    fnLiteral += `
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`;
    return Function("inject", fnLiteral)({
      app,
      mapResponse: app["~adapter"].handler.mapResponse,
      ERROR_CODE: import_error210.ERROR_CODE,
      ElysiaCustomStatusResponse: import_error210.ElysiaCustomStatusResponse,
      ELYSIA_TRACE: hasTrace ? import_trace4.ELYSIA_TRACE : undefined,
      ELYSIA_REQUEST_ID: hasTrace ? import_utils15.ELYSIA_REQUEST_ID : undefined,
      ...adapter.inject
    });
  };
});

// node_modules/elysia/dist/cjs/dynamic-handle.js
var require_dynamic_handle = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dynamic_handle_exports = {};
  __export2(dynamic_handle_exports, {
    createDynamicErrorHandler: () => createDynamicErrorHandler2,
    createDynamicHandler: () => createDynamicHandler2
  });
  module.exports = __toCommonJS2(dynamic_handle_exports);
  var import_error34 = require_error3();
  var import_fast_querystring3 = require_fast_querystring();
  var import_utils15 = require_utils3();
  var import_cookies6 = require_cookies();
  var import_value27 = require_value5();
  var injectDefaultValues2 = (typeChecker, obj) => {
    for (const [key, keySchema] of Object.entries(typeChecker.schema.properties)) {
      obj[key] ??= keySchema.default;
    }
  };
  var createDynamicHandler2 = (app) => {
    const { mapResponse: mapResponse3, mapEarlyResponse: mapEarlyResponse3 } = app["~adapter"].handler;
    return async (request) => {
      const url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi);
      const set2 = {
        cookie: {},
        status: 200,
        headers: {}
      };
      const context = Object.assign({}, app.singleton.decorator, {
        set: set2,
        store: app.singleton.store,
        request,
        path,
        qi,
        error: import_error34.error,
        redirect: import_utils15.redirect
      });
      try {
        if (app.event.request)
          for (let i = 0;i < app.event.request.length; i++) {
            const onRequest = app.event.request[i].fn;
            let response2 = onRequest(context);
            if (response2 instanceof Promise)
              response2 = await response2;
            response2 = mapEarlyResponse3(response2, set2);
            if (response2)
              return context.response = response2;
          }
        const handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find("ALL", path);
        if (!handler)
          throw new import_error34.NotFoundError;
        const { handle, hooks, validator, content, route } = handler.store;
        let body;
        if (request.method !== "GET" && request.method !== "HEAD") {
          if (content) {
            switch (content) {
              case "application/json":
                body = await request.json();
                break;
              case "text/plain":
                body = await request.text();
                break;
              case "application/x-www-form-urlencoded":
                body = (0, import_fast_querystring3.parseQuery)(await request.text());
                break;
              case "application/octet-stream":
                body = await request.arrayBuffer();
                break;
              case "multipart/form-data":
                body = {};
                const form3 = await request.formData();
                for (const key of form3.keys()) {
                  if (body[key])
                    continue;
                  const value = form3.getAll(key);
                  if (value.length === 1)
                    body[key] = value[0];
                  else
                    body[key] = value;
                }
                break;
            }
          } else {
            let contentType = request.headers.get("content-type");
            if (contentType) {
              const index = contentType.indexOf(";");
              if (index !== -1)
                contentType = contentType.slice(0, index);
              context.contentType = contentType;
              if (hooks.parse)
                for (let i = 0;i < hooks.parse.length; i++) {
                  const hook = hooks.parse[i].fn;
                  let temp = hook(context, contentType);
                  if (temp instanceof Promise)
                    temp = await temp;
                  if (temp) {
                    body = temp;
                    break;
                  }
                }
              delete context.contentType;
              if (body === undefined) {
                switch (contentType) {
                  case "application/json":
                    body = await request.json();
                    break;
                  case "text/plain":
                    body = await request.text();
                    break;
                  case "application/x-www-form-urlencoded":
                    body = (0, import_fast_querystring3.parseQuery)(await request.text());
                    break;
                  case "application/octet-stream":
                    body = await request.arrayBuffer();
                    break;
                  case "multipart/form-data":
                    body = {};
                    const form3 = await request.formData();
                    for (const key of form3.keys()) {
                      if (body[key])
                        continue;
                      const value = form3.getAll(key);
                      if (value.length === 1)
                        body[key] = value[0];
                      else
                        body[key] = value;
                    }
                    break;
                }
              }
            }
          }
        }
        context.route = route;
        context.body = body;
        context.params = handler?.params || undefined;
        context.query = qi === -1 ? {} : (0, import_fast_querystring3.parseQuery)(url.substring(qi + 1));
        context.headers = {};
        for (const [key, value] of request.headers.entries())
          context.headers[key] = value;
        const cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config);
        const cookieHeaderValue = request.headers.get("cookie");
        context.cookie = await (0, import_cookies6.parseCookie)(context.set, cookieHeaderValue, cookieMeta ? {
          secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
          sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
        } : undefined);
        const headerValidator = validator?.createHeaders?.();
        if (headerValidator)
          injectDefaultValues2(headerValidator, context.headers);
        const paramsValidator = validator?.createParams?.();
        if (paramsValidator)
          injectDefaultValues2(paramsValidator, context.params);
        const queryValidator = validator?.createQuery?.();
        if (queryValidator)
          injectDefaultValues2(queryValidator, context.query);
        if (hooks.transform)
          for (let i = 0;i < hooks.transform.length; i++) {
            const hook = hooks.transform[i];
            const operation = hook.fn(context);
            if (hook.subType === "derive") {
              if (operation instanceof Promise)
                Object.assign(context, await operation);
              else
                Object.assign(context, operation);
            } else if (operation instanceof Promise)
              await operation;
          }
        if (validator) {
          if (headerValidator) {
            const _header = structuredClone(context.headers);
            for (const [key, value] of request.headers)
              _header[key] = value;
            if (validator.headers.Check(_header) === false)
              throw new import_error34.ValidationError("header", validator.headers, _header);
          } else if (validator.headers?.Decode)
            context.headers = validator.headers.Decode(context.headers);
          if (paramsValidator?.Check(context.params) === false) {
            throw new import_error34.ValidationError("params", validator.params, context.params);
          } else if (validator.params?.Decode)
            context.params = validator.params.Decode(context.params);
          if (queryValidator?.Check(context.query) === false)
            throw new import_error34.ValidationError("query", validator.query, context.query);
          else if (validator.query?.Decode)
            context.query = validator.query.Decode(context.query);
          if (validator.createCookie?.()) {
            let cookieValue = {};
            for (const [key, value] of Object.entries(context.cookie))
              cookieValue[key] = value.value;
            if (validator.cookie.Check(cookieValue) === false)
              throw new import_error34.ValidationError("cookie", validator.cookie, cookieValue);
            else if (validator.cookie?.Decode)
              cookieValue = validator.cookie.Decode(cookieValue);
          }
          if (validator.createBody?.()?.Check(body) === false)
            throw new import_error34.ValidationError("body", validator.body, body);
          else if (validator.body?.Decode)
            context.body = validator.body.Decode(body);
        }
        if (hooks.beforeHandle)
          for (let i = 0;i < hooks.beforeHandle.length; i++) {
            const hook = hooks.beforeHandle[i];
            let response2 = hook.fn(context);
            if (hook.subType === "resolve") {
              if (response2 instanceof import_error34.ElysiaCustomStatusResponse) {
                const result = mapEarlyResponse3(response2, context.set);
                if (result)
                  return context.response = result;
              }
              if (response2 instanceof Promise)
                Object.assign(context, await response2);
              else
                Object.assign(context, response2);
              continue;
            } else if (response2 instanceof Promise)
              response2 = await response2;
            if (response2 !== undefined) {
              context.response = response2;
              if (hooks.afterHandle)
                for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
                  let newResponse = hooks.afterHandle[i2].fn(context);
                  if (newResponse instanceof Promise)
                    newResponse = await newResponse;
                  if (newResponse)
                    response2 = newResponse;
                }
              const result = mapEarlyResponse3(response2, context.set);
              if (result)
                return context.response = result;
            }
          }
        let response = typeof handle === "function" ? handle(context) : handle;
        if (response instanceof Promise)
          response = await response;
        if (hooks.afterHandle)
          if (!hooks.afterHandle.length) {
            const status = response instanceof import_error34.ElysiaCustomStatusResponse ? response.code : set2.status ? typeof set2.status === "string" ? import_utils15.StatusMap[set2.status] : set2.status : 200;
            const responseValidator = validator?.createResponse?.()?.[status];
            if (responseValidator?.Check(response) === false)
              throw new import_error34.ValidationError("response", responseValidator, response);
            else if (responseValidator?.Decode)
              response = responseValidator.Decode(response);
          } else {
            context.response = response;
            for (let i = 0;i < hooks.afterHandle.length; i++) {
              let newResponse = hooks.afterHandle[i].fn(context);
              if (newResponse instanceof Promise)
                newResponse = await newResponse;
              const result = mapEarlyResponse3(newResponse, context.set);
              if (result !== undefined) {
                const responseValidator = validator?.response?.[result.status];
                if (responseValidator?.Check(result) === false)
                  throw new import_error34.ValidationError("response", responseValidator, result);
                else if (responseValidator?.Decode)
                  response = responseValidator.Decode(response);
                return context.response = result;
              }
            }
          }
        if (context.set.cookie && cookieMeta?.sign) {
          const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
          if (cookieMeta.sign === true)
            for (const [key, cookie] of Object.entries(context.set.cookie))
              context.set.cookie[key].value = await (0, import_utils15.signCookie)(cookie.value, "${secret}");
          else {
            const properties = validator?.cookie?.schema?.properties;
            for (const name of cookieMeta.sign) {
              if (!(name in properties))
                continue;
              if (context.set.cookie[name]?.value) {
                context.set.cookie[name].value = await (0, import_utils15.signCookie)(context.set.cookie[name].value, secret);
              }
            }
          }
        }
        return mapResponse3(context.response = response, context.set);
      } catch (error22) {
        const reportedError = error22 instanceof import_value27.TransformDecodeError && error22.error ? error22.error : error22;
        return app.handleError(context, reportedError);
      } finally {
        if (app.event.afterResponse)
          for (const afterResponse of app.event.afterResponse)
            await afterResponse.fn(context);
      }
    };
  };
  var createDynamicErrorHandler2 = (app) => {
    const { mapResponse: mapResponse3 } = app["~adapter"].handler;
    return async (context, error22) => {
      const errorContext = Object.assign(context, { error: error22, code: error22.code });
      errorContext.set = context.set;
      if (app.event.error)
        for (let i = 0;i < app.event.error.length; i++) {
          const hook = app.event.error[i];
          let response = hook.fn(errorContext);
          if (response instanceof Promise)
            response = await response;
          if (response !== undefined && response !== null)
            return context.response = mapResponse3(response, context.set);
        }
      return new Response(typeof error22.cause === "string" ? error22.cause : error22.message, {
        headers: context.set.headers,
        status: error22.status ?? 500
      });
    };
  };
});

// node_modules/elysia/dist/cjs/universal/file.js
var require_file = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var file_exports = {};
  __export2(file_exports, {
    ElysiaFile: () => ElysiaFile3,
    file: () => file3,
    getFileExtension: () => getFileExtension,
    mime: () => mime
  });
  module.exports = __toCommonJS2(file_exports);
  var import_utils15 = require_utils4();
  var mime = {
    aac: "audio/aac",
    abw: "application/x-abiword",
    ai: "application/postscript",
    arc: "application/octet-stream",
    avi: "video/x-msvideo",
    azw: "application/vnd.amazon.ebook",
    bin: "application/octet-stream",
    bz: "application/x-bzip",
    bz2: "application/x-bzip2",
    csh: "application/x-csh",
    css: "text/css",
    csv: "text/csv",
    doc: "application/msword",
    dll: "application/octet-stream",
    eot: "application/vnd.ms-fontobject",
    epub: "application/epub+zip",
    gif: "image/gif",
    htm: "text/html",
    html: "text/html",
    ico: "image/x-icon",
    ics: "text/calendar",
    jar: "application/java-archive",
    jpeg: "image/jpeg",
    jpg: "image/jpeg",
    js: "application/javascript",
    json: "application/json",
    mid: "audio/midi",
    midi: "audio/midi",
    mp2: "audio/mpeg",
    mp3: "audio/mpeg",
    mp4: "video/mp4",
    mpa: "video/mpeg",
    mpe: "video/mpeg",
    mpeg: "video/mpeg",
    mpkg: "application/vnd.apple.installer+xml",
    odp: "application/vnd.oasis.opendocument.presentation",
    ods: "application/vnd.oasis.opendocument.spreadsheet",
    odt: "application/vnd.oasis.opendocument.text",
    oga: "audio/ogg",
    ogv: "video/ogg",
    ogx: "application/ogg",
    otf: "font/otf",
    png: "image/png",
    pdf: "application/pdf",
    ppt: "application/vnd.ms-powerpoint",
    rar: "application/x-rar-compressed",
    rtf: "application/rtf",
    sh: "application/x-sh",
    svg: "image/svg+xml",
    swf: "application/x-shockwave-flash",
    tar: "application/x-tar",
    tif: "image/tiff",
    tiff: "image/tiff",
    ts: "application/typescript",
    ttf: "font/ttf",
    txt: "text/plain",
    vsd: "application/vnd.visio",
    wav: "audio/x-wav",
    weba: "audio/webm",
    webm: "video/webm",
    webp: "image/webp",
    woff: "font/woff",
    woff2: "font/woff2",
    xhtml: "application/xhtml+xml",
    xls: "application/vnd.ms-excel",
    xlsx: "application/vnd.ms-excel",
    xlsx_OLD: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    xml: "application/xml",
    xul: "application/vnd.mozilla.xul+xml",
    zip: "application/zip",
    "3gp": "video/3gpp",
    "3gp_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp",
    "3gp2": "video/3gpp2",
    "3gp2_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp2",
    "7z": "application/x-7z-compressed"
  };
  var getFileExtension = (path) => {
    const index = path.lastIndexOf(".");
    if (index === -1)
      return "";
    return path.slice(index + 1);
  };
  var file3 = (path) => new ElysiaFile3(path);
  var createReadStream;
  var stat3;

  class ElysiaFile3 {
    constructor(path) {
      this.path = path;
      if (import_utils15.isBun)
        this.value = Bun.file(path);
      else {
        if (typeof window !== "undefined") {
          console.warn("Browser environment does not support file");
        } else {
          if (!createReadStream || !stat3) {
            try {
              this.value = import("fs").then((fs) => {
                createReadStream = fs.createReadStream;
                return fs.createReadStream(path);
              });
              this.stats = import("fs/promises").then((fs) => {
                stat3 = fs.stat;
                return fs.stat(path);
              });
            } catch {}
          } else {
            this.value = createReadStream(path);
            this.stats = stat3(path);
          }
        }
      }
    }
    get type() {
      return mime[getFileExtension(this.path)] || "application/octet-stream";
    }
    get length() {
      if (import_utils15.isBun)
        return this.value.size;
      return this.stats?.then((x) => x.size) ?? 0;
    }
  }
});

// node_modules/elysia/dist/cjs/index.js
var require_cjs3 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Cookie: () => import_cookies6.Cookie,
    ELYSIA_FORM_DATA: () => import_utils32.ELYSIA_FORM_DATA,
    ELYSIA_REQUEST_ID: () => import_utils32.ELYSIA_REQUEST_ID,
    ELYSIA_TRACE: () => import_trace22.ELYSIA_TRACE,
    ERROR_CODE: () => import_error210.ERROR_CODE,
    Elysia: () => Elysia2,
    ElysiaFile: () => import_file2.ElysiaFile,
    InternalServerError: () => import_error210.InternalServerError,
    InvalidCookieSignature: () => import_error210.InvalidCookieSignature,
    InvertedStatusMap: () => import_utils32.InvertedStatusMap,
    NotFoundError: () => import_error210.NotFoundError,
    ParseError: () => import_error210.ParseError,
    StatusMap: () => import_utils32.StatusMap,
    TypeSystemPolicy: () => import_system4.TypeSystemPolicy,
    ValidationError: () => import_error210.ValidationError,
    checksum: () => import_utils32.checksum,
    cloneInference: () => import_utils32.cloneInference,
    deduplicateChecksum: () => import_utils32.deduplicateChecksum,
    default: () => Elysia2,
    env: () => import_env22.env,
    error: () => import_error210.error,
    file: () => import_file2.file,
    form: () => import_utils32.form,
    getResponseSchemaValidator: () => import_utils32.getResponseSchemaValidator,
    getSchemaValidator: () => import_utils32.getSchemaValidator,
    mapValueError: () => import_error210.mapValueError,
    mergeHook: () => import_utils32.mergeHook,
    mergeObjectArray: () => import_utils32.mergeObjectArray,
    redirect: () => import_utils32.redirect,
    replaceSchemaType: () => import_utils32.replaceSchemaType,
    replaceUrlPath: () => import_utils32.replaceUrlPath,
    serializeCookie: () => import_cookies6.serializeCookie,
    t: () => import_type_system22.t
  });
  module.exports = __toCommonJS2(src_exports);
  var import_memoirist2 = require_cjs();
  var import_type_system4 = require_type_system();
  var import_sucrose3 = require_sucrose();
  var import_bun2 = require_bun();
  var import_web_standard3 = require_web_standard();
  var import_env3 = require_env();
  var import_utils15 = require_utils3();
  var import_compose2 = require_compose();
  var import_trace4 = require_trace();
  var import_utils22 = require_utils3();
  var import_dynamic_handle2 = require_dynamic_handle();
  var import_error34 = require_error3();
  var import_type_system22 = require_type_system();
  var import_cookies6 = require_cookies();
  var import_trace22 = require_trace();
  var import_utils32 = require_utils3();
  var import_error210 = require_error3();
  var import_env22 = require_env();
  var import_file2 = require_file();
  var import_system4 = require_system2();

  class Elysia2 {
    constructor(config = {}) {
      this.server = null;
      this.dependencies = {};
      this._routes = {};
      this._types = {
        Prefix: "",
        Singleton: {},
        Definitions: {},
        Metadata: {}
      };
      this._ephemeral = {};
      this._volatile = {};
      this.singleton = {
        decorator: {},
        store: {},
        derive: {},
        resolve: {}
      };
      this.definitions = {
        typebox: import_type_system4.t.Module({}),
        type: {},
        error: {}
      };
      this.extender = {
        macros: [],
        higherOrderFunctions: []
      };
      this.validator = {
        global: null,
        scoped: null,
        local: null,
        getCandidate() {
          return (0, import_utils15.mergeSchemaValidator)((0, import_utils15.mergeSchemaValidator)(this.global, this.scoped), this.local);
        }
      };
      this.event = {};
      this.telemetry = {
        stack: undefined
      };
      this.router = {
        "~http": undefined,
        get http() {
          if (!this["~http"])
            this["~http"] = new import_memoirist2.Memoirist({ lazy: true });
          return this["~http"];
        },
        "~dynamic": undefined,
        get dynamic() {
          if (!this["~dynamic"])
            this["~dynamic"] = new import_memoirist2.Memoirist;
          return this["~dynamic"];
        },
        static: {
          http: {
            static: {},
            map: {},
            all: ""
          },
          ws: {}
        },
        history: []
      };
      this.routeTree = /* @__PURE__ */ new Map;
      this.inference = {
        body: false,
        cookie: false,
        headers: false,
        query: false,
        set: false,
        server: false,
        request: false,
        route: false
      };
      this["~parser"] = {};
      this.handle = async (request) => this.fetch(request);
      this.fetch = (request) => {
        return (this.fetch = this.config.aot ? (0, import_compose2.composeGeneralHandler)(this) : (0, import_dynamic_handle2.createDynamicHandler)(this))(request);
      };
      this.handleError = async (context, error22) => {
        return (this.handleError = this.config.aot ? (0, import_compose2.composeErrorHandler)(this) : (0, import_dynamic_handle2.createDynamicErrorHandler)(this))(context, error22);
      };
      this.outerErrorHandler = (error22) => new Response(error22.message || error22.name || "Error", {
        status: error22?.status ?? 500
      });
      this.listen = (options, callback) => {
        this["~adapter"].listen(this)(options, callback);
        return this;
      };
      this.stop = async (closeActiveConnections) => {
        if (!this.server)
          throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
        if (this.server) {
          this.server.stop(closeActiveConnections);
          this.server = null;
          if (this.event.stop?.length)
            for (let i = 0;i < this.event.stop.length; i++)
              this.event.stop[i].fn(this);
        }
      };
      if (config.tags) {
        if (!config.detail)
          config.detail = {
            tags: config.tags
          };
        else
          config.detail.tags = config.tags;
      }
      if (config.nativeStaticResponse === undefined)
        config.nativeStaticResponse = true;
      this.config = {};
      this.applyConfig(config ?? {});
      this["~adapter"] = config.adapter ?? (typeof Bun !== "undefined" ? import_bun2.BunAdapter : import_web_standard3.WebStandardAdapter);
      if (config?.analytic && (config?.name || config?.seed !== undefined))
        this.telemetry.stack = new Error().stack;
    }
    get store() {
      return this.singleton.store;
    }
    get decorator() {
      return this.singleton.decorator;
    }
    get routes() {
      return this.router.history;
    }
    getGlobalRoutes() {
      return this.router.history;
    }
    getServer() {
      return this.server;
    }
    getParent() {
      return null;
    }
    get promisedModules() {
      if (!this._promisedModules)
        this._promisedModules = new import_utils15.PromiseGroup;
      return this._promisedModules;
    }
    env(model, _env = import_env3.env) {
      const validator = (0, import_utils22.getSchemaValidator)(model, {
        modules: this.definitions.typebox,
        dynamic: true,
        additionalProperties: true,
        coerce: true
      });
      if (validator.Check(_env) === false) {
        const error22 = new import_error34.ValidationError("env", model, _env);
        throw new Error(error22.all.map((x) => x.summary).join(`
`));
      }
      return this;
    }
    wrap(fn) {
      this.extender.higherOrderFunctions.push({
        checksum: (0, import_utils22.checksum)(JSON.stringify({
          name: this.config.name,
          seed: this.config.seed,
          content: fn.toString()
        })),
        fn
      });
      return this;
    }
    applyMacro(localHook) {
      if (this.extender.macros.length) {
        const manage = (0, import_utils22.createMacroManager)({
          globalHook: this.event,
          localHook
        });
        const manager = {
          events: {
            global: this.event,
            local: localHook
          },
          get onParse() {
            return manage("parse");
          },
          get onTransform() {
            return manage("transform");
          },
          get onBeforeHandle() {
            return manage("beforeHandle");
          },
          get onAfterHandle() {
            return manage("afterHandle");
          },
          get mapResponse() {
            return manage("mapResponse");
          },
          get onAfterResponse() {
            return manage("afterResponse");
          },
          get onError() {
            return manage("error");
          }
        };
        for (const macro of this.extender.macros)
          (0, import_utils22.traceBackMacro)(macro.fn(manager), localHook, manage);
      }
    }
    applyConfig(config) {
      this.config = {
        prefix: "",
        aot: import_env3.env.ELYSIA_AOT !== "false",
        normalize: true,
        ...config,
        cookie: {
          path: "/",
          ...config?.cookie
        },
        experimental: config?.experimental ?? {},
        seed: config?.seed === undefined ? "" : config?.seed
      };
      return this;
    }
    get models() {
      const models = {};
      for (const name of Object.keys(this.definitions.type))
        models[name] = (0, import_utils22.getSchemaValidator)(this.definitions.typebox.Import(name));
      models.modules = this.definitions.typebox;
      return models;
    }
    add(method, path, handle, localHook, { allowMeta = false, skipPrefix = false } = {
      allowMeta: false,
      skipPrefix: false
    }) {
      localHook = (0, import_utils15.compressHistoryHook)((0, import_utils15.localHookToLifeCycleStore)(localHook));
      if (path !== "" && path.charCodeAt(0) !== 47)
        path = "/" + path;
      if (this.config.prefix && !skipPrefix)
        path = this.config.prefix + path;
      if (localHook?.type)
        switch (localHook.type) {
          case "text":
            localHook.type = "text/plain";
            break;
          case "json":
            localHook.type = "application/json";
            break;
          case "formdata":
            localHook.type = "multipart/form-data";
            break;
          case "urlencoded":
            localHook.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            localHook.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const models = this.definitions.type;
      const dynamic = !this.config.aot;
      const instanceValidator = { ...this.validator.getCandidate() };
      const cloned = {
        body: localHook?.body ?? instanceValidator?.body,
        headers: localHook?.headers ?? instanceValidator?.headers,
        params: localHook?.params ?? instanceValidator?.params,
        query: localHook?.query ?? instanceValidator?.query,
        cookie: localHook?.cookie ?? instanceValidator?.cookie,
        response: localHook?.response ?? instanceValidator?.response
      };
      const cookieValidator = () => cloned.cookie ? (0, import_utils22.getCookieValidator)({
        modules,
        validator: cloned.cookie,
        defaultConfig: this.config.cookie,
        config: cloned.cookie?.config ?? {},
        dynamic,
        models
      }) : undefined;
      const normalize = this.config.normalize;
      const modules = this.definitions.typebox;
      const validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? {
        body: (0, import_utils22.getSchemaValidator)(cloned.body, {
          modules,
          dynamic,
          models,
          normalize,
          additionalCoerce: (0, import_utils15.coercePrimitiveRoot)()
        }),
        headers: (0, import_utils22.getSchemaValidator)(cloned.headers, {
          modules,
          dynamic,
          models,
          additionalProperties: !this.config.normalize,
          coerce: true,
          additionalCoerce: (0, import_utils15.stringToStructureCoercions)()
        }),
        params: (0, import_utils22.getSchemaValidator)(cloned.params, {
          modules,
          dynamic,
          models,
          coerce: true,
          additionalCoerce: (0, import_utils15.stringToStructureCoercions)()
        }),
        query: (0, import_utils22.getSchemaValidator)(cloned.query, {
          modules,
          dynamic,
          models,
          normalize,
          coerce: true,
          additionalCoerce: (0, import_utils15.stringToStructureCoercions)()
        }),
        cookie: cookieValidator(),
        response: (0, import_utils22.getResponseSchemaValidator)(cloned.response, {
          modules,
          dynamic,
          models,
          normalize
        })
      } : {
        createBody() {
          if (this.body)
            return this.body;
          return this.body = (0, import_utils22.getSchemaValidator)(cloned.body, {
            modules,
            dynamic,
            models,
            normalize,
            additionalCoerce: (0, import_utils15.coercePrimitiveRoot)()
          });
        },
        createHeaders() {
          if (this.headers)
            return this.headers;
          return this.headers = (0, import_utils22.getSchemaValidator)(cloned.headers, {
            modules,
            dynamic,
            models,
            additionalProperties: !normalize,
            coerce: true,
            additionalCoerce: (0, import_utils15.stringToStructureCoercions)()
          });
        },
        createParams() {
          if (this.params)
            return this.params;
          return this.params = (0, import_utils22.getSchemaValidator)(cloned.params, {
            modules,
            dynamic,
            models,
            coerce: true,
            additionalCoerce: (0, import_utils15.stringToStructureCoercions)()
          });
        },
        createQuery() {
          if (this.query)
            return this.query;
          return this.query = (0, import_utils22.getSchemaValidator)(cloned.query, {
            modules,
            dynamic,
            models,
            coerce: true,
            additionalCoerce: (0, import_utils15.stringToStructureCoercions)()
          });
        },
        createCookie() {
          if (this.cookie)
            return this.cookie;
          return this.cookie = cookieValidator();
        },
        createResponse() {
          if (this.response)
            return this.response;
          return this.response = (0, import_utils22.getResponseSchemaValidator)(cloned.response, {
            modules,
            dynamic,
            models,
            normalize
          });
        }
      };
      localHook = (0, import_utils22.mergeHook)(localHook, (0, import_utils15.compressHistoryHook)(instanceValidator));
      if (localHook.tags) {
        if (!localHook.detail)
          localHook.detail = {
            tags: localHook.tags
          };
        else
          localHook.detail.tags = localHook.tags;
      }
      if ((0, import_utils15.isNotEmpty)(this.config.detail))
        localHook.detail = (0, import_utils15.mergeDeep)(Object.assign({}, this.config.detail), localHook.detail);
      this.applyMacro(localHook);
      const hooks = (0, import_utils15.compressHistoryHook)((0, import_utils22.mergeHook)(this.event, localHook));
      if (this.config.aot === false) {
        this.router.dynamic.add(method, path, {
          validator,
          hooks,
          content: localHook?.type,
          handle,
          route: path
        });
        const encoded = (0, import_utils15.encodePath)(path, { dynamic: true });
        if (path !== encoded) {
          this.router.dynamic.add(method, encoded, {
            validator,
            hooks,
            content: localHook?.type,
            handle,
            route: path
          });
        }
        if (this.config.strictPath === false) {
          const loosePath = (0, import_utils15.getLoosePath)(path);
          this.router.dynamic.add(method, loosePath, {
            validator,
            hooks,
            content: localHook?.type,
            handle,
            route: path
          });
          const encoded2 = (0, import_utils15.encodePath)(loosePath);
          if (loosePath !== encoded2)
            this.router.dynamic.add(method, loosePath, {
              validator,
              hooks,
              content: localHook?.type,
              handle,
              route: path
            });
        }
        this.router.history.push({
          method,
          path,
          composed: null,
          handler: handle,
          hooks
        });
        return;
      }
      const shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true;
      const inference = (0, import_utils15.cloneInference)(this.inference);
      const adapter = this["~adapter"].handler;
      const staticHandler = typeof handle !== "function" && typeof adapter.createStaticHandler === "function" ? adapter.createStaticHandler(handle, hooks, this.setHeaders) : undefined;
      const nativeStaticHandler = typeof handle !== "function" ? adapter.createNativeStaticHandler?.(handle, hooks, this.setHeaders) : undefined;
      if (this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
        this.router.static.http.static[path] = nativeStaticHandler();
      let compile = (asManifest = false) => (0, import_compose2.composeHandler)({
        app: this,
        path,
        method,
        hooks,
        validator,
        handler: typeof handle !== "function" && typeof adapter.createStaticHandler !== "function" ? () => handle : handle,
        allowMeta,
        inference,
        asManifest
      });
      let oldIndex;
      if (this.routeTree.has(method + path))
        for (let i = 0;i < this.router.history.length; i++) {
          const route = this.router.history[i];
          if (route.path === path && route.method === method) {
            oldIndex = i;
            break;
          }
        }
      else
        this.routeTree.set(method + path, this.router.history.length);
      const history = this.router.history;
      const index = oldIndex ?? this.router.history.length;
      const mainHandler = shouldPrecompile ? compile() : (ctx) => {
        const temp = (history[index].composed = compile())(ctx);
        compile = undefined;
        return temp;
      };
      if (shouldPrecompile)
        compile = undefined;
      const isWebSocket = method === "$INTERNALWS";
      if (oldIndex !== undefined)
        this.router.history[oldIndex] = Object.assign({
          method,
          path,
          composed: mainHandler,
          handler: handle,
          hooks
        }, localHook.webSocket ? { websocket: localHook.websocket } : {});
      else
        this.router.history.push(Object.assign({
          method,
          path,
          composed: mainHandler,
          handler: handle,
          hooks
        }, localHook.webSocket ? { websocket: localHook.websocket } : {}));
      const staticRouter = this.router.static.http;
      const handler = {
        handler: shouldPrecompile ? mainHandler : undefined,
        compile() {
          return this.handler = compile();
        }
      };
      if (isWebSocket) {
        this.router.http.add("ws", path, handler);
        if (!this.config.strictPath)
          this.router.http.add("ws", (0, import_utils15.getLoosePath)(path), handler);
        const encoded = (0, import_utils15.encodePath)(path, { dynamic: true });
        if (encoded !== path)
          this.router.http.add("ws", encoded, handler);
        return;
      }
      if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
        if (!staticRouter.map[path])
          staticRouter.map[path] = {
            code: ""
          };
        const ctx = staticHandler ? "" : "c";
        if (method === "ALL")
          staticRouter.map[path].all = `default:return ht[${index}].composed(${ctx})
`;
        else
          staticRouter.map[path].code = `case '${method}':return ht[${index}].composed(${ctx})
${staticRouter.map[path].code}`;
        if (!this.config.strictPath && this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
          this.router.static.http.static[(0, import_utils15.getLoosePath)(path)] = nativeStaticHandler();
      } else {
        this.router.http.add(method, path, handler);
        if (!this.config.strictPath) {
          const loosePath = (0, import_utils15.getLoosePath)(path);
          if (this.config.nativeStaticResponse === true && staticHandler && (method === "GET" || method === "ALL"))
            this.router.static.http.static[loosePath] = staticHandler();
          this.router.http.add(method, loosePath, handler);
        }
        const encoded = (0, import_utils15.encodePath)(path, { dynamic: true });
        if (path !== encoded) {
          this.router.http.add(method, encoded, handler);
          if (this.config.nativeStaticResponse === true && staticHandler && (method === "GET" || method === "ALL"))
            this.router.static.http.static[encoded] = staticHandler();
          this.router.http.add(method, encoded, handler);
        }
      }
    }
    headers(header) {
      if (!header)
        return this;
      if (!this.setHeaders)
        this.setHeaders = {};
      this.setHeaders = (0, import_utils15.mergeDeep)(this.setHeaders, header);
      return this;
    }
    onStart(handler) {
      this.on("start", handler);
      return this;
    }
    onRequest(handler) {
      this.on("request", handler);
      return this;
    }
    onParse(options, handler) {
      if (!handler) {
        if (typeof options === "string")
          return this.on("parse", this["~parser"][options]);
        return this.on("parse", options);
      }
      return this.on(options, "parse", handler);
    }
    parser(name, parser) {
      this["~parser"][name] = parser;
      return this;
    }
    onTransform(options, handler) {
      if (!handler)
        return this.on("transform", options);
      return this.on(options, "transform", handler);
    }
    resolve(optionsOrResolve, resolve2) {
      if (!resolve2) {
        resolve2 = optionsOrResolve;
        optionsOrResolve = { as: "local" };
      }
      const hook = {
        subType: "resolve",
        fn: resolve2
      };
      return this.onBeforeHandle(optionsOrResolve, hook);
    }
    mapResolve(optionsOrResolve, mapper) {
      if (!mapper) {
        mapper = optionsOrResolve;
        optionsOrResolve = { as: "local" };
      }
      const hook = {
        subType: "mapResolve",
        fn: mapper
      };
      return this.onBeforeHandle(optionsOrResolve, hook);
    }
    onBeforeHandle(options, handler) {
      if (!handler)
        return this.on("beforeHandle", options);
      return this.on(options, "beforeHandle", handler);
    }
    onAfterHandle(options, handler) {
      if (!handler)
        return this.on("afterHandle", options);
      return this.on(options, "afterHandle", handler);
    }
    mapResponse(options, handler) {
      if (!handler)
        return this.on("mapResponse", options);
      return this.on(options, "mapResponse", handler);
    }
    onAfterResponse(options, handler) {
      if (!handler)
        return this.on("afterResponse", options);
      return this.on(options, "afterResponse", handler);
    }
    trace(options, handler) {
      if (!handler) {
        handler = options;
        options = { as: "local" };
      }
      if (!Array.isArray(handler))
        handler = [handler];
      for (const fn of handler)
        this.on(options, "trace", (0, import_trace4.createTracer)(fn));
      return this;
    }
    error(name, error22) {
      switch (typeof name) {
        case "string":
          error22.prototype[import_error34.ERROR_CODE] = name;
          this.definitions.error[name] = error22;
          return this;
        case "function":
          this.definitions.error = name(this.definitions.error);
          return this;
      }
      for (const [code, error3] of Object.entries(name)) {
        error3.prototype[import_error34.ERROR_CODE] = code;
        this.definitions.error[code] = error3;
      }
      return this;
    }
    onError(options, handler) {
      if (!handler)
        return this.on("error", options);
      return this.on(options, "error", handler);
    }
    onStop(handler) {
      this.on("stop", handler);
      return this;
    }
    on(optionsOrType, typeOrHandlers, handlers) {
      let type2;
      switch (typeof optionsOrType) {
        case "string":
          type2 = optionsOrType;
          handlers = typeOrHandlers;
          break;
        case "object":
          type2 = typeOrHandlers;
          if (!Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
            handlers = typeOrHandlers;
          break;
      }
      if (Array.isArray(handlers))
        handlers = (0, import_utils15.fnToContainer)(handlers);
      else {
        if (typeof handlers === "function")
          handlers = [
            {
              fn: handlers
            }
          ];
        else
          handlers = [handlers];
      }
      const handles = handlers;
      for (const handle of handles) {
        handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local";
        if (type2 === "resolve" || type2 === "derive")
          handle.subType = type2;
      }
      if (type2 !== "trace")
        (0, import_sucrose3.sucrose)({
          [type2]: handles.map((x) => x.fn)
        }, this.inference);
      for (const handle of handles) {
        const fn = (0, import_utils22.asHookType)(handle, "global", { skipIfHasType: true });
        switch (type2) {
          case "start":
            this.event.start ??= [];
            this.event.start.push(fn);
            break;
          case "request":
            this.event.request ??= [];
            this.event.request.push(fn);
            break;
          case "parse":
            this.event.parse ??= [];
            this.event.parse.push(fn);
            break;
          case "transform":
            this.event.transform ??= [];
            this.event.transform.push(fn);
            break;
          case "derive":
            this.event.transform ??= [];
            this.event.transform.push((0, import_utils15.fnToContainer)(fn, "derive"));
            break;
          case "beforeHandle":
            this.event.beforeHandle ??= [];
            this.event.beforeHandle.push(fn);
            break;
          case "resolve":
            this.event.beforeHandle ??= [];
            this.event.beforeHandle.push((0, import_utils15.fnToContainer)(fn, "resolve"));
            break;
          case "afterHandle":
            this.event.afterHandle ??= [];
            this.event.afterHandle.push(fn);
            break;
          case "mapResponse":
            this.event.mapResponse ??= [];
            this.event.mapResponse.push(fn);
            break;
          case "afterResponse":
            this.event.afterResponse ??= [];
            this.event.afterResponse.push(fn);
            break;
          case "trace":
            this.event.trace ??= [];
            this.event.trace.push(fn);
            break;
          case "error":
            this.event.error ??= [];
            this.event.error.push(fn);
            break;
          case "stop":
            this.event.stop ??= [];
            this.event.stop.push(fn);
            break;
        }
      }
      return this;
    }
    propagate() {
      (0, import_utils15.promoteEvent)(this.event.parse);
      (0, import_utils15.promoteEvent)(this.event.transform);
      (0, import_utils15.promoteEvent)(this.event.beforeHandle);
      (0, import_utils15.promoteEvent)(this.event.afterHandle);
      (0, import_utils15.promoteEvent)(this.event.mapResponse);
      (0, import_utils15.promoteEvent)(this.event.afterResponse);
      (0, import_utils15.promoteEvent)(this.event.trace);
      (0, import_utils15.promoteEvent)(this.event.error);
      return this;
    }
    as(type2) {
      const castType = { plugin: "scoped", scoped: "scoped", global: "global" }[type2];
      (0, import_utils15.promoteEvent)(this.event.parse, castType);
      (0, import_utils15.promoteEvent)(this.event.transform, castType);
      (0, import_utils15.promoteEvent)(this.event.beforeHandle, castType);
      (0, import_utils15.promoteEvent)(this.event.afterHandle, castType);
      (0, import_utils15.promoteEvent)(this.event.mapResponse, castType);
      (0, import_utils15.promoteEvent)(this.event.afterResponse, castType);
      (0, import_utils15.promoteEvent)(this.event.trace, castType);
      (0, import_utils15.promoteEvent)(this.event.error, castType);
      if (type2 === "plugin") {
        this.validator.scoped = (0, import_utils15.mergeSchemaValidator)(this.validator.scoped, this.validator.local);
        this.validator.local = null;
      } else if (type2 === "global") {
        this.validator.global = (0, import_utils15.mergeSchemaValidator)(this.validator.global, (0, import_utils15.mergeSchemaValidator)(this.validator.scoped, this.validator.local));
        this.validator.scoped = null;
        this.validator.local = null;
      }
      return this;
    }
    group(prefix, schemaOrRun, run) {
      const instance = new Elysia2({
        ...this.config,
        prefix: ""
      });
      instance.singleton = { ...this.singleton };
      instance.definitions = { ...this.definitions };
      instance.getServer = () => this.getServer();
      instance.inference = (0, import_utils15.cloneInference)(this.inference);
      instance.extender = { ...this.extender };
      const isSchema = typeof schemaOrRun === "object";
      const sandbox = (isSchema ? run : schemaOrRun)(instance);
      this.singleton = (0, import_utils15.mergeDeep)(this.singleton, instance.singleton);
      this.definitions = (0, import_utils15.mergeDeep)(this.definitions, instance.definitions);
      if (sandbox.event.request?.length)
        this.event.request = [
          ...this.event.request || [],
          ...sandbox.event.request || []
        ];
      if (sandbox.event.mapResponse?.length)
        this.event.mapResponse = [
          ...this.event.mapResponse || [],
          ...sandbox.event.mapResponse || []
        ];
      this.model(sandbox.definitions.type);
      Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
        path = (isSchema ? "" : this.config.prefix) + prefix + path;
        if (isSchema) {
          const hook = schemaOrRun;
          const localHook = hooks;
          this.add(method, path, handler, (0, import_utils22.mergeHook)(hook, {
            ...localHook || {},
            error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
              ...localHook.error || {},
              ...sandbox.event.error || {}
            ] : [
              localHook.error,
              ...sandbox.event.error || {}
            ]
          }));
        } else {
          this.add(method, path, handler, (0, import_utils22.mergeHook)(hooks, {
            error: sandbox.event.error
          }), {
            skipPrefix: true
          });
        }
      });
      return this;
    }
    guard(hook, run) {
      if (!run) {
        if (typeof hook === "object") {
          this.applyMacro(hook);
          const type2 = hook.as ?? "local";
          this.validator[type2] = {
            body: hook.body ?? this.validator[type2]?.body,
            headers: hook.headers ?? this.validator[type2]?.headers,
            params: hook.params ?? this.validator[type2]?.params,
            query: hook.query ?? this.validator[type2]?.query,
            response: hook.response ?? this.validator[type2]?.response,
            cookie: hook.cookie ?? this.validator[type2]?.cookie
          };
          if (hook.parse)
            this.on({ as: type2 }, "parse", hook.parse);
          if (hook.transform)
            this.on({ as: type2 }, "transform", hook.transform);
          if (hook.derive)
            this.on({ as: type2 }, "derive", hook.derive);
          if (hook.beforeHandle)
            this.on({ as: type2 }, "beforeHandle", hook.beforeHandle);
          if (hook.resolve)
            this.on({ as: type2 }, "resolve", hook.resolve);
          if (hook.afterHandle)
            this.on({ as: type2 }, "afterHandle", hook.afterHandle);
          if (hook.mapResponse)
            this.on({ as: type2 }, "mapResponse", hook.mapResponse);
          if (hook.afterResponse)
            this.on({ as: type2 }, "afterResponse", hook.afterResponse);
          if (hook.error)
            this.on({ as: type2 }, "error", hook.error);
          if (hook.detail) {
            if (this.config.detail)
              this.config.detail = (0, import_utils15.mergeDeep)(Object.assign({}, this.config.detail), hook.detail);
            else
              this.config.detail = hook.detail;
          }
          if (hook?.tags) {
            if (!this.config.detail)
              this.config.detail = {
                tags: hook.tags
              };
            else
              this.config.detail.tags = hook.tags;
          }
          return this;
        }
        return this.guard({}, hook);
      }
      const instance = new Elysia2({
        ...this.config,
        prefix: ""
      });
      instance.singleton = { ...this.singleton };
      instance.definitions = { ...this.definitions };
      instance.inference = (0, import_utils15.cloneInference)(this.inference);
      instance.extender = { ...this.extender };
      const sandbox = run(instance);
      this.singleton = (0, import_utils15.mergeDeep)(this.singleton, instance.singleton);
      this.definitions = (0, import_utils15.mergeDeep)(this.definitions, instance.definitions);
      sandbox.getServer = () => this.server;
      if (sandbox.event.request?.length)
        this.event.request = [
          ...this.event.request || [],
          ...sandbox.event.request || []
        ];
      if (sandbox.event.mapResponse?.length)
        this.event.mapResponse = [
          ...this.event.mapResponse || [],
          ...sandbox.event.mapResponse || []
        ];
      this.model(sandbox.definitions.type);
      Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
        this.add(method, path, handler, (0, import_utils22.mergeHook)(hook, {
          ...localHook || {},
          error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
            ...localHook.error || {},
            ...sandbox.event.error || []
          ] : [
            localHook.error,
            ...sandbox.event.error || []
          ]
        }));
      });
      return this;
    }
    use(plugin, options) {
      if (Array.isArray(plugin)) {
        let app = this;
        for (const p of plugin)
          app = app.use(p);
        return app;
      }
      if (options?.scoped)
        return this.guard({}, (app) => app.use(plugin));
      if (Array.isArray(plugin)) {
        let current = this;
        for (const p of plugin)
          current = this.use(p);
        return current;
      }
      if (plugin instanceof Promise) {
        this.promisedModules.add(plugin.then((plugin2) => {
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (plugin2 instanceof Elysia2)
            return this._use(plugin2).compile();
          if (plugin2.constructor.name === "Elysia")
            return this._use(plugin2).compile();
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          if (plugin2.default instanceof Elysia2)
            return this._use(plugin2.default);
          if (plugin2.constructor.name === "Elysia")
            return this._use(plugin2.default);
          if (plugin2.constructor.name === "_Elysia")
            return this._use(plugin2.default);
          try {
            return this._use(plugin2.default);
          } catch (error22) {
            console.error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
            throw error22;
          }
        }).then((v) => {
          if (v && typeof v.compile === "function")
            v.compile();
          return v;
        }));
        return this;
      }
      return this._use(plugin);
    }
    propagatePromiseModules(plugin) {
      if (plugin.promisedModules.size <= 0)
        return this;
      for (const promise of plugin.promisedModules.promises)
        this.promisedModules.add(promise.then((v) => {
          if (!v)
            return;
          const t3 = this._use(v);
          if (t3 instanceof Promise)
            return t3.then((v2) => {
              if (v2)
                v2.compile();
              else
                v.compile();
            });
          return v.compile();
        }));
      return this;
    }
    _use(plugin) {
      if (typeof plugin === "function") {
        const instance = plugin(this);
        if (instance instanceof Promise) {
          this.promisedModules.add(instance.then((plugin2) => {
            if (plugin2 instanceof Elysia2) {
              plugin2.getServer = () => this.getServer();
              plugin2.getGlobalRoutes = () => this.getGlobalRoutes();
              plugin2.model(this.definitions.type);
              plugin2.error(this.definitions.error);
              for (const {
                method,
                path,
                handler,
                hooks
              } of Object.values(plugin2.router.history))
                this.add(method, path, handler, (0, import_utils22.mergeHook)(hooks, {
                  error: plugin2.event.error
                }));
              plugin2.compile();
              if (plugin2 === this)
                return;
              this.propagatePromiseModules(plugin2);
              return plugin2;
            }
            if (typeof plugin2 === "function")
              return plugin2(this);
            if (typeof plugin2.default === "function")
              return plugin2.default(this);
            return this._use(plugin2);
          }).then((v) => {
            if (v && typeof v.compile === "function")
              v.compile();
            return v;
          }));
          return this;
        }
        return instance;
      }
      this.propagatePromiseModules(plugin);
      const { name, seed } = plugin.config;
      plugin.getParent = () => this;
      plugin.getServer = () => this.getServer();
      plugin.getGlobalRoutes = () => this.getGlobalRoutes();
      plugin.model(this.definitions.type);
      plugin.error(this.definitions.error);
      this["~parser"] = {
        ...plugin["~parser"],
        ...this["~parser"]
      };
      this.headers(plugin.setHeaders);
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? (0, import_utils22.checksum)(name + JSON.stringify(seed)) : 0;
        if (!this.dependencies[name].some(({ checksum: checksum3 }) => current === checksum3)) {
          this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
          this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
        }
      } else {
        this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
        this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
      }
      (0, import_utils15.deduplicateChecksum)(this.extender.macros);
      (0, import_utils15.deduplicateChecksum)(this.extender.higherOrderFunctions);
      const hofHashes = [];
      for (let i = 0;i < this.extender.higherOrderFunctions.length; i++) {
        const hof = this.extender.higherOrderFunctions[i];
        if (hof.checksum) {
          if (hofHashes.includes(hof.checksum)) {
            this.extender.higherOrderFunctions.splice(i, 1);
            i--;
          }
          hofHashes.push(hof.checksum);
        }
      }
      this.inference = {
        body: this.inference.body || plugin.inference.body,
        cookie: this.inference.cookie || plugin.inference.cookie,
        headers: this.inference.headers || plugin.inference.headers,
        query: this.inference.query || plugin.inference.query,
        set: this.inference.set || plugin.inference.set,
        server: this.inference.server || plugin.inference.server,
        request: this.inference.request || plugin.inference.request,
        route: this.inference.route || plugin.inference.route
      };
      this.decorate(plugin.singleton.decorator);
      this.state(plugin.singleton.store);
      this.model(plugin.definitions.type);
      this.error(plugin.definitions.error);
      plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      for (const { method, path, handler, hooks } of Object.values(plugin.router.history)) {
        this.add(method, path, handler, (0, import_utils22.mergeHook)(hooks, {
          error: plugin.event.error
        }));
      }
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? (0, import_utils22.checksum)(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum3 }) => current === checksum3))
          return this;
        this.dependencies[name].push(this.config?.analytic ? {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies,
          stack: plugin.telemetry.stack,
          routes: plugin.router.history,
          decorators: plugin.singleton,
          store: plugin.singleton.store,
          error: plugin.definitions.error,
          derive: plugin.event.transform?.filter((x) => x?.subType === "derive").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          })),
          resolve: plugin.event.transform?.filter((x) => x?.subType === "resolve").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          }))
        } : {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies
        });
        this.event = (0, import_utils22.mergeLifeCycle)(this.event, (0, import_utils22.filterGlobalHook)(plugin.event), current);
      } else {
        this.event = (0, import_utils22.mergeLifeCycle)(this.event, (0, import_utils22.filterGlobalHook)(plugin.event));
      }
      this.validator.global = (0, import_utils22.mergeHook)(this.validator.global, {
        ...plugin.validator.global
      });
      this.validator.local = (0, import_utils22.mergeHook)(this.validator.local, {
        ...plugin.validator.scoped
      });
      return this;
    }
    macro(macro) {
      if (typeof macro === "function") {
        const hook = {
          checksum: (0, import_utils22.checksum)(JSON.stringify({
            name: this.config.name,
            seed: this.config.seed,
            content: macro.toString()
          })),
          fn: macro
        };
        this.extender.macros.push(hook);
      } else if (typeof macro === "object") {
        for (const name of Object.keys(macro))
          if (typeof macro[name] === "object") {
            const actualValue = { ...macro[name] };
            macro[name] = (v) => {
              if (v === true)
                return actualValue;
            };
          }
        const hook = {
          checksum: (0, import_utils22.checksum)(JSON.stringify({
            name: this.config.name,
            seed: this.config.seed,
            content: Object.entries(macro).map(([k, v]) => `${k}+${v}`).join(",")
          })),
          fn: () => macro
        };
        this.extender.macros.push(hook);
      }
      return this;
    }
    mount(path, handle) {
      if (path instanceof Elysia2 || typeof path === "function" || path.length === 0 || path === "/") {
        const run = typeof path === "function" ? path : path instanceof Elysia2 ? path.compile().fetch : handle instanceof Elysia2 ? handle.compile().fetch : handle;
        const handler2 = ({ request, path: path2 }) => run(new Request((0, import_utils22.replaceUrlPath)(request.url, path2), {
          method: request.method,
          headers: request.headers,
          signal: request.signal,
          credentials: request.credentials,
          referrerPolicy: request.referrerPolicy,
          duplex: request.duplex,
          redirect: request.redirect,
          mode: request.mode,
          keepalive: request.keepalive,
          integrity: request.integrity,
          body: request.body
        }));
        this.all("/*", handler2, {
          parse: "none"
        });
        return this;
      }
      if (!handle)
        return this;
      const length = path.length - (path.endsWith("*") ? 1 : 0);
      if (handle instanceof Elysia2)
        handle = handle.compile().fetch;
      const handler = ({ request, path: path2 }) => handle(new Request((0, import_utils22.replaceUrlPath)(request.url, path2.slice(length) || "/"), {
        method: request.method,
        headers: request.headers,
        signal: request.signal,
        credentials: request.credentials,
        referrerPolicy: request.referrerPolicy,
        duplex: request.duplex,
        redirect: request.redirect,
        mode: request.mode,
        keepalive: request.keepalive,
        integrity: request.integrity,
        body: request.body
      }));
      this.all(path, handler, {
        parse: "none"
      });
      this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
        parse: "none"
      });
      return this;
    }
    get(path, handler, hook) {
      this.add("GET", path, handler, hook);
      return this;
    }
    post(path, handler, hook) {
      this.add("POST", path, handler, hook);
      return this;
    }
    put(path, handler, hook) {
      this.add("PUT", path, handler, hook);
      return this;
    }
    patch(path, handler, hook) {
      this.add("PATCH", path, handler, hook);
      return this;
    }
    delete(path, handler, hook) {
      this.add("DELETE", path, handler, hook);
      return this;
    }
    options(path, handler, hook) {
      this.add("OPTIONS", path, handler, hook);
      return this;
    }
    all(path, handler, hook) {
      this.add("ALL", path, handler, hook);
      return this;
    }
    head(path, handler, hook) {
      this.add("HEAD", path, handler, hook);
      return this;
    }
    connect(path, handler, hook) {
      this.add("CONNECT", path, handler, hook);
      return this;
    }
    route(method, path, handler, hook) {
      this.add(method.toUpperCase(), path, handler, hook, hook?.config);
      return this;
    }
    ws(path, options) {
      if (this["~adapter"].ws)
        this["~adapter"].ws(this, path, options);
      else
        console.warn(`Current adapter doesn't support WebSocket`);
      return this;
    }
    state(options, name, value) {
      if (name === undefined) {
        value = options;
        options = { as: "append" };
        name = "";
      } else if (value === undefined) {
        if (typeof options === "string") {
          value = name;
          name = options;
          options = { as: "append" };
        } else if (typeof options === "object") {
          value = name;
          name = "";
        }
      }
      const { as } = options;
      if (typeof name !== "string")
        return this;
      switch (typeof value) {
        case "object":
          if (name) {
            if (name in this.singleton.store)
              this.singleton.store[name] = (0, import_utils15.mergeDeep)(this.singleton.store[name], value, {
                override: as === "override"
              });
            else
              this.singleton.store[name] = value;
            return this;
          }
          if (value === null)
            return this;
          this.singleton.store = (0, import_utils15.mergeDeep)(this.singleton.store, value, {
            override: as === "override"
          });
          return this;
        case "function":
          if (name) {
            if (as === "override" || !(name in this.singleton.store))
              this.singleton.store[name] = value;
          } else
            this.singleton.store = value(this.singleton.store);
          return this;
        default:
          if (as === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value;
          return this;
      }
    }
    decorate(options, name, value) {
      if (name === undefined) {
        value = options;
        options = { as: "append" };
        name = "";
      } else if (value === undefined) {
        if (typeof options === "string") {
          value = name;
          name = options;
          options = { as: "append" };
        } else if (typeof options === "object") {
          value = name;
          name = "";
        }
      }
      const { as } = options;
      if (typeof name !== "string")
        return this;
      switch (typeof value) {
        case "object":
          if (name) {
            if (name in this.singleton.decorator)
              this.singleton.decorator[name] = (0, import_utils15.mergeDeep)(this.singleton.decorator[name], value, {
                override: as === "override"
              });
            else
              this.singleton.decorator[name] = value;
            return this;
          }
          if (value === null)
            return this;
          this.singleton.decorator = (0, import_utils15.mergeDeep)(this.singleton.decorator, value, {
            override: as === "override"
          });
          return this;
        case "function":
          if (name) {
            if (as === "override" || !(name in this.singleton.decorator))
              this.singleton.decorator[name] = value;
          } else
            this.singleton.decorator = value(this.singleton.decorator);
          return this;
        default:
          if (as === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value;
          return this;
      }
    }
    derive(optionsOrTransform, transform2) {
      if (!transform2) {
        transform2 = optionsOrTransform;
        optionsOrTransform = { as: "local" };
      }
      const hook = {
        subType: "derive",
        fn: transform2
      };
      return this.onTransform(optionsOrTransform, hook);
    }
    model(name, model) {
      const coerce = (schema) => (0, import_utils15.replaceSchemaType)(schema, [
        {
          from: import_type_system4.t.Number(),
          to: (options) => import_type_system4.t.Numeric(options),
          untilObjectFound: true
        },
        {
          from: import_type_system4.t.Boolean(),
          to: (options) => import_type_system4.t.BooleanString(options),
          untilObjectFound: true
        }
      ]);
      switch (typeof name) {
        case "object":
          const parsedSchemas = {};
          const kvs = Object.entries(name);
          for (const [key, value] of kvs) {
            if (key in this.definitions.type)
              continue;
            parsedSchemas[key] = this.definitions.type[key] = coerce(value);
            parsedSchemas[key].$id ??= `#/components/schemas/${key}`;
          }
          this.definitions.typebox = import_type_system4.t.Module({
            ...this.definitions.typebox["$defs"],
            ...parsedSchemas
          });
          return this;
        case "function":
          const result = coerce(name(this.definitions.type));
          this.definitions.type = result;
          this.definitions.typebox = import_type_system4.t.Module(result);
          return this;
        case "string":
          if (!model)
            break;
          const newModel = {
            ...model,
            id: model.$id ?? `#/components/schemas/${name}`
          };
          this.definitions.type[name] = model;
          this.definitions.typebox = import_type_system4.t.Module({
            ...this.definitions.typebox["$defs"],
            ...newModel
          });
          return this;
      }
      this.definitions.type[name] = model;
      this.definitions.typebox = import_type_system4.t.Module({
        ...this.definitions.typebox["$defs"],
        [name]: model
      });
      return this;
    }
    mapDerive(optionsOrDerive, mapper) {
      if (!mapper) {
        mapper = optionsOrDerive;
        optionsOrDerive = { as: "local" };
      }
      const hook = {
        subType: "mapDerive",
        fn: mapper
      };
      return this.onTransform(optionsOrDerive, hook);
    }
    affix(base, type2, word) {
      if (word === "")
        return this;
      const delimieter = ["_", "-", " "];
      const capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1);
      const joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix);
      const remap = (type22) => {
        const store = {};
        switch (type22) {
          case "decorator":
            for (const key in this.singleton.decorator) {
              store[joinKey(word, key)] = this.singleton.decorator[key];
            }
            this.singleton.decorator = store;
            break;
          case "state":
            for (const key in this.singleton.store)
              store[joinKey(word, key)] = this.singleton.store[key];
            this.singleton.store = store;
            break;
          case "model":
            for (const key in this.definitions.type)
              store[joinKey(word, key)] = this.definitions.type[key];
            this.definitions.type = store;
            break;
          case "error":
            for (const key in this.definitions.error)
              store[joinKey(word, key)] = this.definitions.error[key];
            this.definitions.error = store;
            break;
        }
      };
      const types = Array.isArray(type2) ? type2 : [type2];
      for (const type22 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
        remap(type22);
      return this;
    }
    prefix(type2, word) {
      return this.affix("prefix", type2, word);
    }
    suffix(type2, word) {
      return this.affix("suffix", type2, word);
    }
    compile() {
      if (this["~adapter"].isWebStandard) {
        this.fetch = this.config.aot ? (0, import_compose2.composeGeneralHandler)(this) : (0, import_dynamic_handle2.createDynamicHandler)(this);
        if (typeof this.server?.reload === "function")
          this.server.reload({
            ...this.server || {},
            fetch: this.fetch
          });
        return this;
      }
      if (typeof this.server?.reload === "function")
        this.server.reload(this.server || {});
      this._handle = (0, import_compose2.composeGeneralHandler)(this);
      return this;
    }
    get modules() {
      return this.promisedModules;
    }
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS((exports) => {
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse3;
  exports.serialize = serialize2;
  var __toString = Object.prototype.toString;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  function parse3(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode3;
    var index = 0;
    while (index < str.length) {
      var eqIdx = str.indexOf("=", index);
      if (eqIdx === -1) {
        break;
      }
      var endIdx = str.indexOf(";", index);
      if (endIdx === -1) {
        endIdx = str.length;
      } else if (endIdx < eqIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var key = str.slice(index, eqIdx).trim();
      if (obj[key] === undefined) {
        var val = str.slice(eqIdx + 1, endIdx).trim();
        if (val.charCodeAt(0) === 34) {
          val = val.slice(1, -1);
        }
        obj[key] = tryDecode(val, dec);
      }
      index = endIdx + 1;
    }
    return obj;
  }
  function serialize2(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode2;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function decode3(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  }
  function encode2(val) {
    return encodeURIComponent(val);
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
  }
  function tryDecode(str, decode4) {
    try {
      return decode4(str);
    } catch (e) {
      return str;
    }
  }
});

// node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS((exports) => {
  var crypto2 = __require("crypto");
  exports.sign = function(val, secret) {
    if (typeof val != "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (secret == null)
      throw new TypeError("Secret key must be provided.");
    return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
  };
  exports.unsign = function(input, secret) {
    if (typeof input != "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (secret == null)
      throw new TypeError("Secret key must be provided.");
    var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = exports.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
    return expectedBuffer.length === inputBuffer.length && crypto2.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
  };
});

// node_modules/@elysiajs/cookie/dist/cjs/index.js
var require_cjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cookie = undefined;
  var elysia_1 = require_cjs3();
  var cookie_1 = require_cookie();
  var cookie_signature_1 = require_cookie_signature();
  var cookie = (options = {}) => {
    const { signed, secret: secretKey, ...defaultOptions } = options;
    const secret = !secretKey ? undefined : typeof secretKey === "string" ? secretKey : secretKey[0];
    const isStringKey = typeof secret === "string";
    return new elysia_1.Elysia({
      name: "@elysiajs/cookie",
      seed: options
    }).decorate("unsignCookie", (value) => {
      if (!secret)
        throw new Error("No secret is provided to cookie plugin");
      let unsigned = isStringKey ? (0, cookie_signature_1.unsign)(value, secret) : false;
      if (isStringKey === false)
        for (let i = 0;i < secret.length; i++) {
          const temp = (0, cookie_signature_1.unsign)(value, secret[i]);
          if (temp) {
            unsigned = temp;
            break;
          }
        }
      return {
        valid: unsigned !== false,
        value: unsigned || undefined
      };
    }).derive((context) => {
      let _cookie;
      const getCookie = () => {
        if (_cookie)
          return _cookie;
        try {
          const headerCookie = context.request.headers.get("cookie");
          _cookie = headerCookie ? (0, cookie_1.parse)(headerCookie) : {};
        } catch (error3) {
          _cookie = {};
        }
        return _cookie;
      };
      return {
        get cookie() {
          return getCookie();
        },
        setCookie(name, value, { signed: signed2 = false, ...options2 } = {}) {
          if (signed2) {
            if (!secret)
              throw new Error("No secret is provided to cookie plugin");
            value = (0, cookie_signature_1.sign)(value, secret);
          }
          if (!Array.isArray(context.set.headers["Set-Cookie"]))
            context.set.headers["Set-Cookie"] = [];
          context.set.headers["Set-Cookie"].push((0, cookie_1.serialize)(name, value, {
            path: "/",
            ...defaultOptions,
            ...options2
          }));
          if (!_cookie)
            getCookie();
          _cookie[name] = value;
        },
        removeCookie(name) {
          if (!getCookie()[name])
            return;
          context.set.headers["Set-Cookie"] = (0, cookie_1.serialize)(name, "", {
            expires: new Date("Thu, Jan 01 1970 00:00:00 UTC")
          });
          delete _cookie[name];
        }
      };
    });
  };
  exports.cookie = cookie;
  exports.default = exports.cookie;
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  var util3 = __require("util");
  module.exports = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util3.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this;
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {});
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message2 = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message2));
  };
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports, module) => {
  var util3 = __require("util");
  var Stream = __require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module.exports = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util3.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this;
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message2 = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message2));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types4) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type2) {
      var mime = db[type2];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type2] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types4[extension2]) {
          var from = preference.indexOf(db[types4[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types4[extension2] !== "application/octet-stream" && (from > to || from === to && types4[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types4[extension2] = type2;
      }
    });
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports, module) => {
  module.exports = defer;
  function defer(fn) {
    var nextTick2 = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick2) {
      nextTick2(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports, module) => {
  var defer = require_defer();
  module.exports = async;
  function async(callback) {
    var isAsync2 = false;
    defer(function() {
      isAsync2 = true;
    });
    return function async_callback(err, result) {
      if (isAsync2) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports, module) => {
  module.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean2.bind(state));
    state.jobs = {};
  }
  function clean2(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports, module) => {
  var async = require_async();
  var abort = require_abort();
  module.exports = iterate;
  function iterate(list, iterator, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error3, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error3) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error3, state.results);
    });
  }
  function runJob(iterator, key, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async(callback));
    } else {
      aborter = iterator(item, key, async(callback));
    }
    return aborter;
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports, module) => {
  module.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports, module) => {
  var abort = require_abort();
  var async = require_async();
  module.exports = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = parallel;
  function parallel(list, iterator, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator, state, function(error3, result) {
        if (error3) {
          callback(error3, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = serialOrdered;
  module.exports.ascending = ascending;
  module.exports.descending = descending;
  function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error3, result) {
      if (error3) {
        callback(error3, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS((exports, module) => {
  var serialOrdered = require_serialOrdered();
  module.exports = serial;
  function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports, module) => {
  module.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports, module) => {
  module.exports = Object;
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
  module.exports = Error;
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
  module.exports = EvalError;
});

// node_modules/es-errors/range.js
var require_range = __commonJS((exports, module) => {
  module.exports = RangeError;
});

// node_modules/es-errors/ref.js
var require_ref3 = __commonJS((exports, module) => {
  module.exports = ReferenceError;
});

// node_modules/es-errors/syntax.js
var require_syntax2 = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// node_modules/es-errors/type.js
var require_type7 = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
  module.exports = URIError;
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports, module) => {
  module.exports = Math.abs;
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports, module) => {
  module.exports = Math.floor;
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports, module) => {
  module.exports = Math.max;
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports, module) => {
  module.exports = Math.min;
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports, module) => {
  module.exports = Math.pow;
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS((exports, module) => {
  module.exports = Math.round;
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS((exports, module) => {
  module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
  };
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS((exports, module) => {
  var $isNaN = require_isNaN();
  module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
  module.exports = Object.getOwnPropertyDescriptor;
});

// node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
  module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS((exports, module) => {
  var $Object = require_es_object_atoms();
  module.exports = $Object.getPrototypeOf || null;
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports, module) => {
  module.exports = Function.prototype.call;
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports, module) => {
  module.exports = Function.prototype.apply;
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports, module) => {
  var bind2 = require_function_bind();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var $reflectApply = require_reflectApply();
  module.exports = $reflectApply || bind2.call($call, $apply);
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports, module) => {
  var bind2 = require_function_bind();
  var $TypeError = require_type7();
  var $call = require_functionCall();
  var $actualApply = require_actualApply();
  module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS((exports, module) => {
  var callBind = require_call_bind_apply_helpers();
  var gOPD = require_gopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS((exports, module) => {
  var reflectGetProto = require_Reflect_getPrototypeOf();
  var originalGetProto = require_Object_getPrototypeOf();
  var getDunderProto = require_get();
  module.exports = reflectGetProto ? function getProto(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto(O) {
    return getDunderProto(O);
  } : null;
});

// node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = require_function_bind();
  module.exports = bind2.call(call, $hasOwn);
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
  var undefined2;
  var $Object = require_es_object_atoms();
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range();
  var $ReferenceError = require_ref3();
  var $SyntaxError = require_syntax2();
  var $TypeError = require_type7();
  var $URIError = require_uri();
  var abs = require_abs();
  var floor = require_floor();
  var max = require_max();
  var min = require_min();
  var pow = require_pow();
  var round = require_round();
  var sign3 = require_sign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
  };
  var $gOPD = require_gopd();
  var $defineProperty = require_es_define_property();
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = require_get_proto();
  var $ObjectGPO = require_Object_getPrototypeOf();
  var $ReflectGPO = require_Reflect_getPrototypeOf();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs,
    "%Math.floor%": floor,
    "%Math.max%": max,
    "%Math.min%": min,
    "%Math.pow%": pow,
    "%Math.round%": round,
    "%Math.sign%": sign3,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = require_function_bind();
  var hasOwn = require_hasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS((exports, module) => {
  var hasSymbols = require_shams();
  module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
  };
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasToStringTag = require_shams2()();
  var hasOwn = require_hasown();
  var $TypeError = require_type7();
  var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
  module.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
      throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
    }
    if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
      if ($defineProperty) {
        $defineProperty(object, toStringTag, {
          configurable: !nonConfigurable,
          enumerable: false,
          value,
          writable: false
        });
      } else {
        object[toStringTag] = value;
      }
    }
  };
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports, module) => {
  module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports, module) => {
  var CombinedStream = require_combined_stream();
  var util3 = __require("util");
  var path = __require("path");
  var http = __require("http");
  var https = __require("https");
  var parseUrl = __require("url").parse;
  var fs = __require("fs");
  var Stream = __require("stream").Stream;
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var setToStringTag = require_es_set_tostringtag();
  var populate = require_populate();
  module.exports = FormData2;
  util3.inherits(FormData2, CombinedStream);
  function FormData2(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData2.LINE_BREAK = `\r
`;
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (Array.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (Object.prototype.hasOwnProperty.call(value, "fd")) {
      if (value.end != null && value.end != Infinity && value.start != null) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat3) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat3.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (Object.prototype.hasOwnProperty.call(value, "httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (Object.prototype.hasOwnProperty.call(headers, prop)) {
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      filename = path.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next2) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next2(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length;i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0;i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request, options, defaults = { method: "post" };
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error3, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error3, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
  setToStringTag(FormData2, "FormData");
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS((exports) => {
  var parseUrl = __require("url").parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url2) {
    var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  exports.getProxyForUrl = getProxyForUrl;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse3(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse3(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env4) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env4).forEach((key) => {
      createDebug[key] = env4[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash3 = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i);
        hash3 |= 0;
      }
      return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error3) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error3) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error3) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error3) {
      return "[UnexpectedJSONParseError]: " + error3.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util3 = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util3.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error3) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util3.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug;
  module.exports = function() {
    if (!debug) {
      try {
        debug = require_src()("follow-redirects");
      } catch (error3) {}
      if (typeof debug !== "function") {
        debug = function() {};
      }
    }
    debug.apply(null, arguments);
  };
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports, module) => {
  var url2 = __require("url");
  var URL2 = url2.URL;
  var http = __require("http");
  var https = __require("https");
  var Writable = __require("stream").Writable;
  var assert2 = __require("assert");
  var debug = require_debug();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction2(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert2(new URL2(""));
  } catch (error3) {
    useNativeURL = error3.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
  var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
  var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
  var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
  var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  var destroy = Writable.prototype.destroy || noop2;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      try {
        self2._processResponse(response);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error3) {
    destroyRequest(this._currentRequest, error3);
    destroy.call(this, error3);
    return this;
  };
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError;
    }
    if (!isString2(data) && !isBuffer2(data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({ data, encoding });
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError);
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (isFunction2(data)) {
      callback = data;
      data = encoding = null;
    } else if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events) {
      request.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : this._options.path;
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error3) {
        if (request === self2._currentRequest) {
          if (error3) {
            self2.emit("error", error3);
          } else if (i < buffers.length) {
            var buffer = buffers[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError;
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        Host: response.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction2(beforeRedirect)) {
      var responseDetails = {
        headers: response.headers,
        statusCode
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap(protocols) {
    var exports2 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString2(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction2(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports2.maxRedirects,
          maxBodyLength: exports2.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString2(options.host) && !isString2(options.hostname)) {
          options.hostname = "::1";
        }
        assert2.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request, configurable: true, enumerable: true, writable: true },
        get: { value: get, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports2;
  }
  function noop2() {}
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url2.parse(input));
      if (!isString2(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base) {
    return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields) {
      spread[key] = urlObject[key];
    }
    if (spread.hostname.startsWith("[")) {
      spread.hostname = spread.hostname.slice(1, -1);
    }
    if (spread.port !== "") {
      spread.port = Number(spread.port);
    }
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
  }
  function removeMatchingHeaders(regex2, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex2.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
  }
  function createErrorType(code, message2, baseClass) {
    function CustomError(properties) {
      if (isFunction2(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message2 + ": " + this.cause.message : message2;
    }
    CustomError.prototype = new (baseClass || Error);
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request, error3) {
    for (var event of events) {
      request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop2);
    request.destroy(error3);
  }
  function isSubdomain(subdomain, domain) {
    assert2(isString2(subdomain) && isString2(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  }
  function isString2(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function isBuffer2(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  module.exports = wrap({ http, https });
  module.exports.wrap = wrap;
});

// node_modules/memoirist/dist/index.mjs
var createNode = (part, inert) => {
  const inertMap = inert?.length ? {} : null;
  if (inertMap)
    for (const child of inert)
      inertMap[child.part.charCodeAt(0)] = child;
  return {
    part,
    store: null,
    inert: inertMap,
    params: null,
    wildcardStore: null
  };
};
var cloneNode = (node, part) => ({
  ...node,
  part
});
var createParamNode = (name) => ({
  name,
  store: null,
  inert: null
});
var Memoirist = class _Memoirist {
  constructor(config = {}) {
    this.config = config;
    if (config.lazy)
      this.find = this.lazyFind;
  }
  root = {};
  history = [];
  deferred = [];
  static regex = {
    static: /:.+?(?=\/|$)/,
    params: /:.+?(?=\/|$)/g,
    optionalParams: /:.+?\?(?=\/|$)/g
  };
  lazyFind = (method, url) => {
    if (!this.config.lazy)
      return this.find;
    this.build();
    return this.find(method, url);
  };
  build() {
    if (!this.config.lazy)
      return;
    for (const [method, path, store] of this.deferred)
      this.add(method, path, store, { lazy: false, ignoreHistory: true });
    this.deferred = [];
    this.find = (method, url) => {
      const root = this.root[method];
      if (!root)
        return null;
      return matchRoute(url, url.length, root, 0);
    };
  }
  add(method, path, store, {
    ignoreError = false,
    ignoreHistory = false,
    lazy = this.config.lazy
  } = {}) {
    if (lazy) {
      this.find = this.lazyFind;
      this.deferred.push([method, path, store]);
      return store;
    }
    if (typeof path !== "string")
      throw new TypeError("Route path must be a string");
    if (path === "")
      path = "/";
    else if (path[0] !== "/")
      path = `/${path}`;
    const isWildcard = path[path.length - 1] === "*";
    const optionalParams = path.match(_Memoirist.regex.optionalParams);
    if (optionalParams) {
      const originalPath = path.replaceAll("?", "");
      this.add(method, originalPath, store, {
        ignoreError,
        ignoreHistory,
        lazy
      });
      for (let i = 0;i < optionalParams.length; i++) {
        let newPath = path.replace("/" + optionalParams[i], "");
        this.add(method, newPath, store, {
          ignoreError: true,
          ignoreHistory,
          lazy
        });
      }
      return store;
    }
    if (optionalParams)
      path = path.replaceAll("?", "");
    if (this.history.find(([m, p, s]) => m === method && p === path))
      return store;
    if (isWildcard || optionalParams && path.charCodeAt(path.length - 1) === 63)
      path = path.slice(0, -1);
    if (!ignoreHistory)
      this.history.push([method, path, store]);
    const inertParts = path.split(_Memoirist.regex.static);
    const paramParts = path.match(_Memoirist.regex.params) || [];
    if (inertParts[inertParts.length - 1] === "")
      inertParts.pop();
    let node;
    if (!this.root[method])
      node = this.root[method] = createNode("/");
    else
      node = this.root[method];
    let paramPartsIndex = 0;
    for (let i = 0;i < inertParts.length; ++i) {
      let part = inertParts[i];
      if (i > 0) {
        const param = paramParts[paramPartsIndex++].slice(1);
        if (node.params === null)
          node.params = createParamNode(param);
        else if (node.params.name !== param) {
          if (ignoreError)
            return store;
          else
            throw new Error(`Cannot create route "${path}" with parameter "${param}" because a route already exists with a different parameter name ("${node.params.name}") in the same location`);
        }
        const params = node.params;
        if (params.inert === null) {
          node = params.inert = createNode(part);
          continue;
        }
        node = params.inert;
      }
      for (let j = 0;; ) {
        if (j === part.length) {
          if (j < node.part.length) {
            const childNode = cloneNode(node, node.part.slice(j));
            Object.assign(node, createNode(part, [childNode]));
          }
          break;
        }
        if (j === node.part.length) {
          if (node.inert === null)
            node.inert = {};
          const inert = node.inert[part.charCodeAt(j)];
          if (inert) {
            node = inert;
            part = part.slice(j);
            j = 0;
            continue;
          }
          const childNode = createNode(part.slice(j));
          node.inert[part.charCodeAt(j)] = childNode;
          node = childNode;
          break;
        }
        if (part[j] !== node.part[j]) {
          const existingChild = cloneNode(node, node.part.slice(j));
          const newChild = createNode(part.slice(j));
          Object.assign(node, createNode(node.part.slice(0, j), [
            existingChild,
            newChild
          ]));
          node = newChild;
          break;
        }
        ++j;
      }
    }
    if (paramPartsIndex < paramParts.length) {
      const param = paramParts[paramPartsIndex];
      const name = param.slice(1);
      if (node.params === null)
        node.params = createParamNode(name);
      else if (node.params.name !== name) {
        if (ignoreError)
          return store;
        else
          throw new Error(`Cannot create route "${path}" with parameter "${name}" because a route already exists with a different parameter name ("${node.params.name}") in the same location`);
      }
      if (node.params.store === null)
        node.params.store = store;
      return node.params.store;
    }
    if (isWildcard) {
      if (node.wildcardStore === null)
        node.wildcardStore = store;
      return node.wildcardStore;
    }
    if (node.store === null)
      node.store = store;
    return node.store;
  }
  find(method, url) {
    const root = this.root[method];
    if (!root)
      return null;
    return matchRoute(url, url.length, root, 0);
  }
};
var matchRoute = (url, urlLength, node, startIndex) => {
  const part = node.part;
  const length = part.length;
  const endIndex = startIndex + length;
  if (length > 1) {
    if (endIndex > urlLength)
      return null;
    if (length < 15) {
      for (let i = 1, j = startIndex + 1;i < length; ++i, ++j)
        if (part.charCodeAt(i) !== url.charCodeAt(j))
          return null;
    } else if (url.slice(startIndex, endIndex) !== part)
      return null;
  }
  if (endIndex === urlLength) {
    if (node.store !== null)
      return {
        store: node.store,
        params: {}
      };
    if (node.wildcardStore !== null)
      return {
        store: node.wildcardStore,
        params: { "*": "" }
      };
    return null;
  }
  if (node.inert !== null) {
    const inert = node.inert[url.charCodeAt(endIndex)];
    if (inert !== undefined) {
      const route = matchRoute(url, urlLength, inert, endIndex);
      if (route !== null)
        return route;
    }
  }
  if (node.params !== null) {
    const { store, name, inert } = node.params;
    const slashIndex = url.indexOf("/", endIndex);
    if (slashIndex !== endIndex) {
      if (slashIndex === -1 || slashIndex >= urlLength) {
        if (store !== null) {
          const params = {};
          params[name] = url.substring(endIndex, urlLength);
          return {
            store,
            params
          };
        }
      } else if (inert !== null) {
        const route = matchRoute(url, urlLength, inert, slashIndex);
        if (route !== null) {
          route.params[name] = url.substring(endIndex, slashIndex);
          return route;
        }
      }
    }
  }
  if (node.wildcardStore !== null)
    return {
      store: node.wildcardStore,
      params: {
        "*": url.substring(endIndex, urlLength)
      }
    };
  return null;
};

// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined,
  IsUint8Array: () => IsUint8Array,
  IsSymbol: () => IsSymbol,
  IsString: () => IsString,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject,
  IsNumber: () => IsNumber,
  IsNull: () => IsNull,
  IsIterator: () => IsIterator,
  IsFunction: () => IsFunction,
  IsDate: () => IsDate,
  IsBoolean: () => IsBoolean,
  IsBigInt: () => IsBigInt,
  IsAsyncIterator: () => IsAsyncIterator,
  IsArray: () => IsArray,
  HasPropertyKey: () => HasPropertyKey
});
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === undefined ? Clone(schema) : Clone({ ...options, ...schema });
}

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.asyncIterator in value;
}
function IsIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject2(value) && (globalThis.Object.getPrototypeOf(value) === Object.prototype || globalThis.Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof globalThis.Promise;
}
function IsDate2(value) {
  return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
function IsMap(value) {
  return value instanceof globalThis.Map;
}
function IsSet(value) {
  return value instanceof globalThis.Set;
}
function IsTypedArray(value) {
  return globalThis.ArrayBuffer.isView(value);
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
  return key in value;
}
function IsObject2(value) {
  return value !== null && typeof value === "object";
}
function IsArray2(value) {
  return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
  return value === undefined;
}
function IsNull2(value) {
  return value === null;
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return globalThis.Number.isInteger(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsString2(value) {
  return typeof value === "string";
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNull2(value) || IsNumber2(value) || IsString2(value) || IsSymbol2(value) || IsUndefined2(value);
}

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy2;
(function(TypeSystemPolicy3) {
  TypeSystemPolicy3.InstanceMode = "default";
  TypeSystemPolicy3.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy3.AllowArrayObject = false;
  TypeSystemPolicy3.AllowNaN = false;
  TypeSystemPolicy3.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy3.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy3.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject2(value);
    return TypeSystemPolicy3.AllowArrayObject ? isObject : isObject && !IsArray2(value);
  }
  TypeSystemPolicy3.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy3.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy3.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
  }
  TypeSystemPolicy3.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined2(value);
    return TypeSystemPolicy3.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy3.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy2 || (TypeSystemPolicy2 = {}));

// node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
  return value;
}
function ImmutableUint8Array(value) {
  return value;
}
function ImmutableRegExp(value) {
  return value;
}
function ImmutableObject(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value) {
  return IsArray(value) ? ImmutableArray(value) : IsDate(value) ? ImmutableDate(value) : IsUint8Array(value) ? ImmutableUint8Array(value) : IsRegExp(value) ? ImmutableRegExp(value) : IsObject(value) ? ImmutableObject(value) : value;
}

// node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy2.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArgument(value) {
  return IsKindOf(value, "Argument");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
  return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArgument(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsComputed(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type = {};
__export(exports_type, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue2,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsImport: () => IsImport,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsComputed: () => IsComputed2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsArgument: () => IsArgument2,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
  return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
  return IsKindOf2(value, "Computed") && IsString(value.target) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsImport(value) {
  return IsKindOf2(value, "Import") && HasPropertyKey(value, "$defs") && IsObject(value.$defs) && IsProperties(value.$defs) && HasPropertyKey(value, "$ref") && IsString(value.$ref) && value.$ref in value.$defs;
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArgument2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsComputed2(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys(type));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
  return [...new Set(IsTemplateLiteral(type) ? FromTemplateLiteral(type) : IsUnion(type) ? FromUnion2(type.anyOf) : IsLiteral(type) ? FromLiteral(type.const) : IsNumber3(type) ? ["[number]"] : IsInteger2(type) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type, mappedResult, options) {
  return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
  const properties = FromMappedResult(type, mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
  return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
  return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion3(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple(type.items ?? [], propertyKey) : IsArray3(type) ? FromArray(type.items, propertyKey) : IsObject3(type) ? FromProperty(type.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    const error2 = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type) || !IsSchema(key))
      throw new TypeBoxError(error2);
    return Computed("Index", [type, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
  return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type, left, options) };
  }, {});
}
function MappedIndexProperties(type, mappedKey, options) {
  return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
  const properties = MappedIndexProperties(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  const options = { ...T };
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items), options) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item), options) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
  return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union(FromRest3(types));
}
function FromPromise(type) {
  return Awaited(type);
}
function FromRest3(types) {
  return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
  return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect2(type.allOf) : IsUnion(type) ? FromUnion4(type.anyOf) : IsPromise2(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(type) {
  return IsIntersect(type) ? FromIntersect3(type.allOf) : IsUnion(type) ? FromUnion5(type.anyOf) : IsTuple(type) ? FromTuple2(type.items ?? []) : IsArray3(type) ? FromArray2(type.items) : IsObject3(type) ? FromProperties5(type.properties) : IsRecord(type) ? FromPatternProperties(type.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern = keys.map((key) => `(${key})`);
  return `^(${pattern.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
  const propertyKeys = KeyOfPropertyKeys(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(type, options) {
  return IsComputed(type) ? FromComputed2(type.target, type.parameters) : IsRef(type) ? FromRef2(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}

// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T, options) {
  return CreateType(FromValue(T, true), options);
}

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type.IsNever(right) || exports_type.IsIntersect(right) || exports_type.IsUnion(right) || exports_type.IsUnknown(right) || exports_type.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) && right.anyOf.some((schema) => exports_type.IsAny(schema) || exports_type.IsUnknown(schema)) ? ExtendsResult.True : exports_type.IsUnion(right) ? ExtendsResult.Union : exports_type.IsUnknown(right) ? ExtendsResult.True : exports_type.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return exports_type.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return exports_type.IsNot(left) ? Visit3(UnwrapTNot(left), right) : exports_type.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type.IsLiteralNumber(left) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type.IsString(schema.properties.description.anyOf[0]) && exports_type.IsUndefined(schema.properties.description.anyOf[1]) || exports_type.IsString(schema.properties.description.anyOf[1]) && exports_type.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type.IsOptional(left) && !exports_type.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) || exports_type.IsLiteralString(left) && IsObjectStringLike(right) || exports_type.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type.IsString(left) && IsObjectStringLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsNumber(left) && IsObjectNumberLike(right) || exports_type.IsInteger(left) && IsObjectNumberLike(right) || exports_type.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type.IsDate(left) && IsObjectDateLike(right) || exports_type.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type.IsRecord(left) && exports_type.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type.IsRecord(left) && exports_type.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : !exports_type.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type.IsLiteralString(left) && exports_type.IsNumber(Key) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type.IsUint8Array(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsString(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsArray(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L = exports_type.IsRegExp(left) ? String2() : left;
  const R = exports_type.IsRegExp(right) ? String2() : right;
  return Visit3(L, R);
}
function FromStringRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return exports_type.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : exports_type.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type.IsNever(left) ? ExtendsResult.True : exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsVoid(right) ? FromVoidRight(left, right) : exports_type.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type.IsArray(right) ? FromArrayRight(left, right) : exports_type.IsTuple(right) ? FromTupleRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type.IsUndefined(left) ? ExtendsResult.True : exports_type.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return exports_type.IsTemplateLiteral(left) || exports_type.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : exports_type.IsRegExp(left) || exports_type.IsRegExp(right) ? FromRegExp(left, right) : exports_type.IsNot(left) || exports_type.IsNot(right) ? FromNot(left, right) : exports_type.IsAny(left) ? FromAny(left, right) : exports_type.IsArray(left) ? FromArray4(left, right) : exports_type.IsBigInt(left) ? FromBigInt(left, right) : exports_type.IsBoolean(left) ? FromBoolean(left, right) : exports_type.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : exports_type.IsConstructor(left) ? FromConstructor(left, right) : exports_type.IsDate(left) ? FromDate(left, right) : exports_type.IsFunction(left) ? FromFunction(left, right) : exports_type.IsInteger(left) ? FromInteger(left, right) : exports_type.IsIntersect(left) ? FromIntersect4(left, right) : exports_type.IsIterator(left) ? FromIterator(left, right) : exports_type.IsLiteral(left) ? FromLiteral2(left, right) : exports_type.IsNever(left) ? FromNever(left, right) : exports_type.IsNull(left) ? FromNull(left, right) : exports_type.IsNumber(left) ? FromNumber(left, right) : exports_type.IsObject(left) ? FromObject(left, right) : exports_type.IsRecord(left) ? FromRecord(left, right) : exports_type.IsString(left) ? FromString(left, right) : exports_type.IsSymbol(left) ? FromSymbol(left, right) : exports_type.IsTuple(left) ? FromTuple3(left, right) : exports_type.IsPromise(left) ? FromPromise2(left, right) : exports_type.IsUint8Array(left) ? FromUint8Array(left, right) : exports_type.IsUndefined(left) ? FromUndefined(left, right) : exports_type.IsUnion(left) ? FromUnion6(left, right) : exports_type.IsUnknown(left) ? FromUnknown(left, right) : exports_type.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, Clone(options))
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
  return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
  return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
  const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_, type, options) {
  return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
  return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) : IsLiteral(key) ? FromLiteralKey(key.const, type, options) : IsBoolean3(key) ? FromBooleanKey(key, type, options) : IsInteger2(key) ? FromIntegerKey(key, type, options) : IsNumber3(key) ? FromNumberKey(key, type, options) : IsRegExp2(key) ? FromRegExpKey(key, type, options) : IsString3(key) ? FromStringKey(key, type, options) : IsAny(key) ? FromAnyKey(key, type, options) : IsNever(key) ? FromNeverKey(key, type, options) : Never(options);
}
function RecordPattern(record) {
  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
  const pattern = RecordPattern(type);
  return pattern === PatternStringExact ? String2() : pattern === PatternNumberExact ? Number2() : String2({ pattern });
}
function RecordValue2(type) {
  return type.patternProperties[RecordPattern(type)];
}

// node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromFunction2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromIntersect5(args, type) {
  type.allOf = FromTypes(args, type.allOf);
  return type;
}
function FromUnion7(args, type) {
  type.anyOf = FromTypes(args, type.anyOf);
  return type;
}
function FromTuple4(args, type) {
  if (IsUndefined(type.items))
    return type;
  type.items = FromTypes(args, type.items);
  return type;
}
function FromArray5(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromAsyncIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromPromise3(args, type) {
  type.item = FromType(args, type.item);
  return type;
}
function FromObject2(args, type) {
  const mappedProperties = FromProperties11(args, type.properties);
  return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
  const mappedKey = FromType(args, RecordKey2(type));
  const mappedValue = FromType(args, RecordValue2(type));
  const result = Record(mappedKey, mappedValue);
  return { ...type, ...result };
}
function FromArgument(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
  const isReadonly = IsReadonly(type);
  const isOptional = IsOptional(type);
  const mapped = FromType(args, type);
  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;
}
function FromProperties11(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args, properties[key]) };
  }, {});
}
function FromTypes(args, types) {
  return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
  return IsConstructor(type) ? FromConstructor2(args, type) : IsFunction3(type) ? FromFunction2(args, type) : IsIntersect(type) ? FromIntersect5(args, type) : IsUnion(type) ? FromUnion7(args, type) : IsTuple(type) ? FromTuple4(args, type) : IsArray3(type) ? FromArray5(args, type) : IsAsyncIterator3(type) ? FromAsyncIterator2(args, type) : IsIterator3(type) ? FromIterator2(args, type) : IsPromise2(type) ? FromPromise3(args, type) : IsObject3(type) ? FromObject2(args, type) : IsRecord(type) ? FromRecord2(args, type) : IsArgument(type) ? FromArgument(args, type) : type;
}
function Instantiate(type, args) {
  return FromType(args, CloneType(type));
}

// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest5(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest5(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : CreateType(schema, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
}
function FromProperties13(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Omit(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type, typeKey], options) : CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
  return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type, LK, options) };
  }, {});
}
function FromMappedKey3(type, mappedKey, options) {
  return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey3(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties14(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject4(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
}
function Pick(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
  return {
    [key]: Pick(type, [key], Clone(options))
  };
}
function FromPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type, leftKey, options) };
  }, {});
}
function FromMappedKey4(type, mappedKey, options) {
  return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey4(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject5(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
  return IsComputed(type) ? FromComputed3(type.target, type.parameters) : IsRef(type) ? FromRef3(type.$ref) : IsIntersect(type) ? Intersect(FromRest6(type.allOf)) : IsUnion(type) ? Union(FromRest6(type.anyOf)) : IsObject3(type) ? FromObject5(type) : IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : Object2({});
}
function Partial(type, options) {
  if (IsMappedResult(type)) {
    return PartialFromMappedResult(type, options);
  } else {
    return CreateType({ ...PartialResolve(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R, options) {
  return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject6(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
  return IsComputed(type) ? FromComputed4(type.target, type.parameters) : IsRef(type) ? FromRef4(type.$ref) : IsIntersect(type) ? Intersect(FromRest7(type.allOf)) : IsUnion(type) ? Union(FromRest7(type.anyOf)) : IsObject3(type) ? FromObject6(type) : IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : Object2({});
}
function Required(type, options) {
  if (IsMappedResult(type)) {
    return RequiredFromMappedResult(type, options);
  } else {
    return CreateType({ ...RequiredResolve(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
  return types.map((type) => {
    return IsRef(type) ? Dereference(moduleProperties, type.$ref) : FromType2(moduleProperties, type);
  });
}
function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromArray6(moduleProperties, type) {
  return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
  return AsyncIterator(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction3(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromIntersect8(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
  return Iterator(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord3(moduleProperties, type) {
  const [value, pattern] = [FromType2(moduleProperties, RecordValue2(type)), RecordPattern(type)];
  const result = CloneType(type);
  result.patternProperties[pattern] = value;
  return result;
}
function FromTransform(moduleProperties, transform) {
  return IsRef(transform) ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] } : transform;
}
function FromTuple5(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
  return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
  return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
  return IsOptional(type) ? CreateType(FromType2(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType2(moduleProperties, Discard(type, [ReadonlyKind])), type) : IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) : IsArray3(type) ? CreateType(FromArray6(moduleProperties, type.items), type) : IsAsyncIterator3(type) ? CreateType(FromAsyncIterator3(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed5(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor3(moduleProperties, type.parameters, type.returns), type) : IsFunction3(type) ? CreateType(FromFunction3(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect8(moduleProperties, type.allOf), type) : IsIterator3(type) ? CreateType(FromIterator3(moduleProperties, type.items), type) : IsObject3(type) ? CreateType(FromObject7(moduleProperties, type.properties), type) : IsRecord(type) ? CreateType(FromRecord3(moduleProperties, type)) : IsTuple(type) ? CreateType(FromTuple5(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion10(moduleProperties, type.anyOf), type) : type;
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
class TModule {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
}
function Module(properties) {
  return new TModule(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type, options) {
  return CreateType({ [Kind]: "Not", not: type }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? T.items ?? [] : [];
}
function Rest(T) {
  return RestResolve(T);
}

// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
}

class TransformEncodeBuilder {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value) => schema[TransformKind].Encode(encode(value));
    const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
}
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Module: () => Module,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  Instantiate: () => Instantiate,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Argument: () => Argument,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error2) {
  switch (error2.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error2.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error2.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error2.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error2.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error2.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error2.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error2.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error2.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$ref}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit4(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit4(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit4(key);
    Visit4(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
  if (IsArray2(value))
    return ArrayType2(value);
  if (IsBoolean2(value))
    return BooleanType(value);
  if (IsBigInt2(value))
    return BigIntType(value);
  if (IsDate2(value))
    return DateType2(value);
  if (IsNull2(value))
    return NullType(value);
  if (IsNumber2(value))
    return NumberType(value);
  if (IsObject2(value))
    return ObjectType2(value);
  if (IsString2(value))
    return StringType(value);
  if (IsSymbol2(value))
    return SymbolType(value);
  if (IsUint8Array2(value))
    return Uint8ArrayType2(value);
  if (IsUndefined2(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value);
  return Accumulator;
}

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
  return value !== undefined;
}
function FromAny2(schema, references, value) {
  return true;
}
function FromArgument2(schema, references, value) {
  return true;
}
function FromArray7(schema, references, value) {
  if (!IsArray2(value))
    return false;
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit5(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit5(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator4(schema, references, value) {
  return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
  if (!IsBigInt2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean2(schema, references, value) {
  return IsBoolean2(value);
}
function FromConstructor4(schema, references, value) {
  return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
  if (!IsDate2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction4(schema, references, value) {
  return IsFunction2(value);
}
function FromImport(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect9(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator4(schema, references, value) {
  return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
  return value === schema.const;
}
function FromNever2(schema, references, value) {
  return false;
}
function FromNot2(schema, references, value) {
  return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
  return IsNull2(value);
}
function FromNumber2(schema, references, value) {
  if (!TypeSystemPolicy2.IsNumberLike(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject8(schema, references, value) {
  if (!TypeSystemPolicy2.IsObjectLike(value))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy2.IsExactOptionalProperty(value, knownKey) && !Visit5(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise4(schema, references, value) {
  return IsPromise(value);
}
function FromRecord4(schema, references, value) {
  if (!TypeSystemPolicy2.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit5(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit5(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString2(schema, references, value) {
  if (!IsString2(value)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol2(schema, references, value) {
  return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromTuple6(schema, references, value) {
  if (!IsArray2(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit5(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined2(schema, references, value) {
  return IsUndefined2(value);
}
function FromUnion11(schema, references, value) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
  if (!IsUint8Array2(value)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown2(schema, references, value) {
  return true;
}
function FromVoid2(schema, references, value) {
  return TypeSystemPolicy2.IsVoidLike(value);
}
function FromKind(schema, references, value) {
  if (!exports_type2.Has(schema[Kind]))
    return false;
  const func = exports_type2.Get(schema[Kind]);
  return func(schema, value);
}
function Visit5(schema, references, value) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value);
    case "Argument":
      return FromArgument2(schema_, references_, value);
    case "Array":
      return FromArray7(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_, value);
    case "BigInt":
      return FromBigInt2(schema_, references_, value);
    case "Boolean":
      return FromBoolean2(schema_, references_, value);
    case "Constructor":
      return FromConstructor4(schema_, references_, value);
    case "Date":
      return FromDate2(schema_, references_, value);
    case "Function":
      return FromFunction4(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger2(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Iterator":
      return FromIterator4(schema_, references_, value);
    case "Literal":
      return FromLiteral3(schema_, references_, value);
    case "Never":
      return FromNever2(schema_, references_, value);
    case "Not":
      return FromNot2(schema_, references_, value);
    case "Null":
      return FromNull2(schema_, references_, value);
    case "Number":
      return FromNumber2(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Promise":
      return FromPromise4(schema_, references_, value);
    case "Record":
      return FromRecord4(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "RegExp":
      return FromRegExp2(schema_, references_, value);
    case "String":
      return FromString2(schema_, references_, value);
    case "Symbol":
      return FromSymbol2(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple6(schema_, references_, value);
    case "Undefined":
      return FromUndefined2(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value);
    case "Unknown":
      return FromUnknown2(schema_, references_, value);
    case "Void":
      return FromVoid2(schema_, references_, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path, value, errors = []) {
  return {
    type: errorType,
    schema,
    path,
    value,
    message: GetErrorFunction()({ errorType, path, schema, value, errors }),
    errors
  };
}
function* FromAny3(schema, references, path, value) {}
function* FromArgument3(schema, references, path, value) {}
function* FromArray8(schema, references, path, value) {
  if (!IsArray2(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit6(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit6(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator5(schema, references, path, value) {
  if (!IsAsyncIterator2(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt3(schema, references, path, value) {
  if (!IsBigInt2(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean3(schema, references, path, value) {
  if (!IsBoolean2(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor5(schema, references, path, value) {
  yield* Visit6(schema.returns, references, path, value.prototype);
}
function* FromDate3(schema, references, path, value) {
  if (!IsDate2(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction5(schema, references, path, value) {
  if (!IsFunction2(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport2(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path, value);
}
function* FromInteger3(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect10(schema, references, path, value) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error2 of Visit6(inner, references, path, value)) {
      hasError = true;
      yield error2;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path, value);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit6(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator5(schema, references, path, value) {
  if (!IsIterator2(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral4(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever3(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot3(schema, references, path, value) {
  if (Visit6(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull3(schema, references, path, value) {
  if (!IsNull2(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber3(schema, references, path, value) {
  if (!TypeSystemPolicy2.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject9(schema, references, path, value) {
  if (!TypeSystemPolicy2.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy2.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise5(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord5(schema, references, path, value) {
  if (!TypeSystemPolicy2.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromRegExp3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString2(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol3(schema, references, path, value) {
  if (!IsSymbol2(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral5(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis2(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromTuple7(schema, references, path, value) {
  if (!IsArray2(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit6(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined3(schema, references, path, value) {
  if (!IsUndefined2(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion12(schema, references, path, value) {
  if (Check(schema, references, value))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path, value)));
  yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array3(schema, references, path, value) {
  if (!IsUint8Array2(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown3(schema, references, path, value) {}
function* FromVoid3(schema, references, path, value) {
  if (!TypeSystemPolicy2.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind2(schema, references, path, value) {
  const check = exports_type2.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit6(schema, references, path, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path, value);
    case "Argument":
      return yield* FromArgument3(schema_, references_, path, value);
    case "Array":
      return yield* FromArray8(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator5(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor5(schema_, references_, path, value);
    case "Date":
      return yield* FromDate3(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction5(schema_, references_, path, value);
    case "Import":
      return yield* FromImport2(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect10(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator5(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path, value);
    case "Never":
      return yield* FromNever3(schema_, references_, path, value);
    case "Not":
      return yield* FromNot3(schema_, references_, path, value);
    case "Null":
      return yield* FromNull3(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber3(schema_, references_, path, value);
    case "Object":
      return yield* FromObject9(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise5(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord5(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef6(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path, value);
    case "String":
      return yield* FromString3(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path, value);
    case "This":
      return yield* FromThis2(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple7(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion12(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid3(schema_, references_, path, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator = args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(error2 instanceof Error ? error2.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error2) {
    throw new TransformDecodeError(schema, path, value, error2);
  }
}
function FromArray9(schema, references, path, value) {
  return IsArray2(value) ? Default(schema, path, value.map((value2, index) => Visit7(schema.items, references, `${path}/${index}`, value2))) : Default(schema, path, value);
}
function FromIntersect11(schema, references, path, value) {
  if (!IsObject2(value) || IsValueType(value))
    return Default(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit7(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromImport3(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Visit7(target, [...references, ...additional], path, value);
  return Default(schema, path, result);
}
function FromNot4(schema, references, path, value) {
  return Default(schema, path, Visit7(schema.not, references, path, value));
}
function FromObject10(schema, references, path, value) {
  if (!IsObject2(value))
    return Default(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy2.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit7(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromRecord6(schema, references, path, value) {
  if (!IsObject2(value))
    return Default(schema, path, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit7(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromRef7(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default(schema, path, Visit7(target, references, path, value));
}
function FromThis3(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default(schema, path, Visit7(target, references, path, value));
}
function FromTuple8(schema, references, path, value) {
  return IsArray2(value) && IsArray2(schema.items) ? Default(schema, path, schema.items.map((schema2, index) => Visit7(schema2, references, `${path}/${index}`, value[index]))) : Default(schema, path, value);
}
function FromUnion13(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit7(subschema, references, path, value);
    return Default(schema, path, decoded);
  }
  return Default(schema, path, value);
}
function Visit7(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, path, value);
    case "Import":
      return FromImport3(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value);
    case "Not":
      return FromNot4(schema_, references_, path, value);
    case "Object":
      return FromObject10(schema_, references_, path, value);
    case "Record":
      return FromRecord6(schema_, references_, path, value);
    case "Ref":
      return FromRef7(schema_, references_, path, value);
    case "Symbol":
      return Default(schema_, path, value);
    case "This":
      return FromThis3(schema_, references_, path, value);
    case "Tuple":
      return FromTuple8(schema_, references_, path, value);
    case "Union":
      return FromUnion13(schema_, references_, path, value);
    default:
      return Default(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit7(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default2(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error2) {
    throw new TransformEncodeError(schema, path, value, error2);
  }
}
function FromArray10(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  return IsArray2(defaulted) ? defaulted.map((value2, index) => Visit8(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromImport4(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Default2(schema, path, value);
  return Visit8(target, [...references, ...additional], path, result);
}
function FromIntersect12(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit8(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot5(schema, references, path, value) {
  return Default2(schema.not, path, Default2(schema, path, value));
}
function FromObject11(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy2.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit8(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord7(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit8(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default2(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef8(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit8(target, references, path, value);
  return Default2(schema, path, resolved);
}
function FromThis4(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit8(target, references, path, value);
  return Default2(schema, path, resolved);
}
function FromTuple9(schema, references, path, value) {
  const value1 = Default2(schema, path, value);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit8(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit8(subschema, references, path, value);
    return Default2(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit8(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default2(schema, path, value1);
  }
  return Default2(schema, path, value);
}
function Visit8(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, path, value);
    case "Import":
      return FromImport4(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject11(schema_, references_, path, value);
    case "Record":
      return FromRecord7(schema_, references_, path, value);
    case "Ref":
      return FromRef8(schema_, references_, path, value);
    case "This":
      return FromThis4(schema_, references_, path, value);
    case "Tuple":
      return FromTuple9(schema_, references_, path, value);
    case "Union":
      return FromUnion14(schema_, references_, path, value);
    default:
      return Default2(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit8(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray11(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromAsyncIterator6(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromFunction6(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit9(schema2, references));
}
function FromImport5(schema, references) {
  const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
  const target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit9(target, [...additional, ...references]);
}
function FromIterator6(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromNot6(schema, references) {
  return IsTransform(schema) || Visit9(schema.not, references);
}
function FromObject12(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit9(schema2, references)) || IsSchema(schema.additionalProperties) && Visit9(schema.additionalProperties, references);
}
function FromPromise6(schema, references) {
  return IsTransform(schema) || Visit9(schema.item, references);
}
function FromRecord8(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform(schema) || Visit9(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
}
function FromRef9(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref(schema, references), references);
}
function FromThis5(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref(schema, references), references);
}
function FromTuple10(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit9(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit9(schema2, references));
}
function Visit9(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Not":
      return FromNot6(schema_, references_);
    case "Object":
      return FromObject12(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord8(schema_, references_);
    case "Ref":
      return FromRef9(schema_, references_);
    case "This":
      return FromThis5(schema_, references_);
    case "Tuple":
      return FromTuple10(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit9(schema, references);
}

// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck2 {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Schema() {
    return this.schema;
  }
  References() {
    return this.references;
  }
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  Check(value) {
    return this.checkFunc(value);
  }
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape2(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape2;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy2.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy2.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy2.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler2;
(function(TypeCompiler3) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny4(schema, references, value) {
    yield "true";
  }
  function* FromArgument4(schema, references, value) {
    yield "true";
  }
  function* FromArray12(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator7(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt4(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean4(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor7(schema, references, value) {
    yield* Visit10(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate4(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromImport6(schema, references, value) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit10(Ref(schema.$ref), [...references, ...members], value);
  }
  function* FromInteger4(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect14(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral5(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever4(schema, references, value) {
    yield `false`;
  }
  function* FromNot7(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull4(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber4(schema, references, value) {
    yield Policy.IsNumberLike(value);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject13(schema, references, value) {
    yield Policy.IsObjectLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit10(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise7(schema, references, value) {
    yield `${value} instanceof Promise`;
  }
  function* FromRecord9(schema, references, value) {
    yield Policy.IsRecordLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef10(schema, references, value) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit10(target, references, value);
  }
  function* FromRegExp4(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString4(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol4(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral6(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis6(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple11(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === undefined)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined4(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion16(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array4(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown4(schema, references, value) {
    yield "true";
  }
  function* FromVoid4(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  function* FromKind3(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  function* Visit10(schema, references, value, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny4(schema_, references_, value);
      case "Argument":
        return yield* FromArgument4(schema_, references_, value);
      case "Array":
        return yield* FromArray12(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt4(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean4(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor7(schema_, references_, value);
      case "Date":
        return yield* FromDate4(schema_, references_, value);
      case "Function":
        return yield* FromFunction7(schema_, references_, value);
      case "Import":
        return yield* FromImport6(schema_, references_, value);
      case "Integer":
        return yield* FromInteger4(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect14(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral5(schema_, references_, value);
      case "Never":
        return yield* FromNever4(schema_, references_, value);
      case "Not":
        return yield* FromNot7(schema_, references_, value);
      case "Null":
        return yield* FromNull4(schema_, references_, value);
      case "Number":
        return yield* FromNumber4(schema_, references_, value);
      case "Object":
        return yield* FromObject13(schema_, references_, value);
      case "Promise":
        return yield* FromPromise7(schema_, references_, value);
      case "Record":
        return yield* FromRecord9(schema_, references_, value);
      case "Ref":
        return yield* FromRef10(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp4(schema_, references_, value);
      case "String":
        return yield* FromString4(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol4(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral6(schema_, references_, value);
      case "This":
        return yield* FromThis6(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple11(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined4(schema_, references_, value);
      case "Union":
        return yield* FromUnion16(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array4(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown4(schema_, references_, value);
      case "Void":
        return yield* FromVoid4(schema_, references_, value);
      default:
        if (!exports_type2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind3(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit10(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit10(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray2(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray2(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler3.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!exports_type2.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type2.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format, value) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck2(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler3.Compile = Compile;
})(TypeCompiler2 || (TypeCompiler2 = {}));
// node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;

class AssertError extends TypeBoxError {
  constructor(iterator) {
    const error2 = iterator.First();
    super(error2 === undefined ? "Invalid Value" : error2.message);
    _AssertError_instances.add(this);
    _AssertError_iterator.set(this, undefined);
    __classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
    this.error = error2;
  }
  Errors() {
    return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
  }
}
_AssertError_iterator = new WeakMap, _AssertError_instances = new WeakSet, _AssertError_Iterator = function* _AssertError_Iterator2() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
function AssertValue(schema, references, value) {
  if (Check(schema, references, value))
    return;
  throw new AssertError(Errors(schema, references, value));
}
function Assert(...args) {
  return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject13(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function FromArray12(value) {
  return value.map((element) => Clone2(element));
}
function FromTypedArray(value) {
  return value.slice();
}
function FromMap(value) {
  return new Map(Clone2([...value.entries()]));
}
function FromSet(value) {
  return new Set(Clone2([...value.entries()]));
}
function FromDate4(value) {
  return new Date(value.toISOString());
}
function FromValue2(value) {
  return value;
}
function Clone2(value) {
  if (IsArray2(value))
    return FromArray12(value);
  if (IsDate2(value))
    return FromDate4(value);
  if (IsTypedArray(value))
    return FromTypedArray(value);
  if (IsMap(value))
    return FromMap(value);
  if (IsSet(value))
    return FromSet(value);
  if (IsObject2(value))
    return FromObject13(value);
  if (IsValueType(value))
    return FromValue2(value);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return IsFunction2(value) ? value() : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArgument4(schema, references) {
  return {};
}
function FromArray13(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit10(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {}();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit10(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit10(schema.returns, references);
  }
}
function FromImport6(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit10(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect14(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit10(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {}();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject14(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit10(subschema, references);
    }
    return Acc;
  }
}
function FromPromise7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit10(schema.item, references));
  }
}
function FromRecord9(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit10(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef10(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit10(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis6(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit10(Deref(schema, references), references);
  }
}
function FromTuple11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit10(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion16(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit10(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit10(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Argument":
      return FromArgument4(schema_, references_);
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator7(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor7(schema_, references_);
    case "Date":
      return FromDate5(schema_, references_);
    case "Function":
      return FromFunction7(schema_, references_);
    case "Import":
      return FromImport6(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect14(schema_, references_);
    case "Iterator":
      return FromIterator7(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject14(schema_, references_);
    case "Promise":
      return FromPromise7(schema_, references_);
    case "Record":
      return FromRecord9(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral6(schema_, references_);
    case "This":
      return FromThis6(schema_, references_);
    case "Tuple":
      return FromTuple11(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion16(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit10(args[0], args[1]) : Visit10(args[0], []);
}

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull2(value)) {
    const object = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union, references, value) {
  const schemas = union.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union, references, value) {
  if ("default" in union) {
    return typeof value === "function" ? union.default : Clone2(union.default);
  } else {
    const schema = SelectUnion(union, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default3(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray14(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray2(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber2(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber2(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit11(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor8(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {};
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit11(property, references, value.prototype[key]);
  }
  return result;
}
function FromImport7(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit11(target, [...references, ...definitions], value);
}
function FromIntersect15(schema, references, value) {
  const created = Create2(schema, references);
  const mapped = IsObject2(created) && IsObject2(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped) ? mapped : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject15(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit11(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit11(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord10(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit11(subschema, references, propValue);
  }
  return result;
}
function FromRef11(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple12(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray2(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit11(schema2, references, value[index]));
}
function FromUnion17(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit11(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray14(schema_, references_, value);
    case "Constructor":
      return FromConstructor8(schema_, references_, value);
    case "Import":
      return FromImport7(schema_, references_, value);
    case "Intersect":
      return FromIntersect15(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject15(schema_, references_, value);
    case "Record":
      return FromRecord10(schema_, references_, value);
    case "Ref":
      return FromRef11(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple12(schema_, references_, value);
    case "Union":
      return FromUnion17(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default3(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray15(schema, references, value) {
  if (!IsArray2(value))
    return value;
  return value.map((value2) => Visit12(schema.items, references, value2));
}
function FromImport8(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit12(target, [...references, ...definitions], value);
}
function FromIntersect16(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit12(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject2(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject2(value) || !IsObject2(composite) || !IsKind(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit12(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject16(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (HasPropertyKey2(schema.properties, key)) {
      value[key] = Visit12(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit12(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord11(schema, references, value) {
  if (!IsObject2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit12(propertySchema, references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit12(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef12(schema, references, value) {
  return Visit12(Deref(schema, references), references, value);
}
function FromThis8(schema, references, value) {
  return Visit12(Deref(schema, references), references, value);
}
function FromTuple13(schema, references, value) {
  if (!IsArray2(value))
    return value;
  if (IsUndefined2(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit12(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion18(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit12(inner, references, value);
    }
  }
  return value;
}
function Visit12(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray15(schema_, references_, value);
    case "Import":
      return FromImport8(schema_, references_, value);
    case "Intersect":
      return FromIntersect16(schema_, references_, value);
    case "Object":
      return FromObject16(schema_, references_, value);
    case "Record":
      return FromRecord11(schema_, references_, value);
    case "Ref":
      return FromRef12(schema_, references_, value);
    case "This":
      return FromThis8(schema_, references_, value);
    case "Tuple":
      return FromTuple13(schema_, references_, value);
    case "Union":
      return FromUnion18(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit12(args[0], args[1], args[2]) : Visit12(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString2(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNumber2(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber2(value) && value === 1 || IsBigInt2(value) && value === BigInt("1") || IsString2(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber2(value) && (value === 0 || Object.is(value, -0)) || IsBigInt2(value) && value === BigInt("0") || IsString2(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString2(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber2(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean2(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : value;
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  const truncateInteger = (value2) => value2.split(".")[0];
  return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : IsNumber2(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsSymbol2(value) && value.description !== undefined ? value.description.toString() : IsValueToString(value) ? value.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber2(value) ? Math.trunc(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString2(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString2(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate2(value) ? value : IsNumber2(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default4(value) {
  return value;
}
function FromArray16(schema, references, value) {
  const elements = IsArray2(value) ? value : [value];
  return elements.map((element) => Visit13(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate6(schema, references, value) {
  return TryConvertDate(value);
}
function FromImport9(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit13(target, [...references, ...definitions], value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect17(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit13(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject17(schema, references, value) {
  if (!IsObject2(value))
    return value;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey2(value, propertyKey))
      continue;
    value[propertyKey] = Visit13(schema.properties[propertyKey], references, value[propertyKey]);
  }
  return value;
}
function FromRecord12(schema, references, value) {
  const isConvertable = IsObject2(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value)) {
    value[propKey] = Visit13(property, references, propValue);
  }
  return value;
}
function FromRef13(schema, references, value) {
  return Visit13(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString2(value) || IsNumber2(value) ? Symbol(value) : value;
}
function FromThis9(schema, references, value) {
  return Visit13(Deref(schema, references), references, value);
}
function FromTuple14(schema, references, value) {
  const isConvertable = IsArray2(value) && !IsUndefined2(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit13(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion19(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit13(subschema, references, Clone2(value));
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit13(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray16(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate6(schema_, references_, value);
    case "Import":
      return FromImport9(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect17(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject17(schema_, references_, value);
    case "Record":
      return FromRecord12(schema_, references_, value);
    case "Ref":
      return FromRef13(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis9(schema_, references_, value);
    case "Tuple":
      return FromTuple14(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion19(schema_, references_, value);
    default:
      return Default4(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit13(args[0], args[1], args[2]) : Visit13(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : undefined;
  const clone = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
  return IsUndefined2(value) ? clone : IsObject2(value) && IsObject2(clone) ? Object.assign(clone, value) : value;
}
function HasDefaultProperty(schema) {
  return IsKind(schema) && "default" in schema;
}
function FromArray17(schema, references, value) {
  if (IsArray2(value)) {
    for (let i = 0;i < value.length; i++) {
      value[i] = Visit14(schema.items, references, value[i]);
    }
    return value;
  }
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit14(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromDate7(schema, references, value) {
  return IsDate2(value) ? value : ValueOrDefault(schema, value);
}
function FromImport10(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit14(target, [...references, ...definitions], value);
}
function FromIntersect18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit14(schema2, references, defaulted);
    return IsObject2(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
    if (IsUndefined2(propertyValue))
      continue;
    defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord13(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
      continue;
    defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef14(schema, references, value) {
  return Visit14(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis10(schema, references, value) {
  return Visit14(Deref(schema, references), references, value);
}
function FromTuple15(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted) || IsUndefined2(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit14(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion20(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit14(inner, references, Clone2(defaulted));
    if (Check(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit14(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray17(schema_, references_, value);
    case "Date":
      return FromDate7(schema_, references_, value);
    case "Import":
      return FromImport10(schema_, references_, value);
    case "Intersect":
      return FromIntersect18(schema_, references_, value);
    case "Object":
      return FromObject18(schema_, references_, value);
    case "Record":
      return FromRecord13(schema_, references_, value);
    case "Ref":
      return FromRef14(schema_, references_, value);
    case "This":
      return FromThis10(schema_, references_, value);
    case "Tuple":
      return FromTuple15(schema_, references_, value);
    case "Union":
      return FromUnion20(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default5(...args) {
  return args.length === 3 ? Visit14(args[0], args[1], args[2]) : Visit14(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType3(left, right) {
  if (!IsObject2(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType3(left, right) {
  return IsDate2(right) && left.getTime() === right.getTime();
}
function ArrayType3(left, right) {
  if (!IsArray2(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsDate2(left))
    return DateType3(left, right);
  if (IsTypedArray(left))
    return TypedArrayType(left, right);
  if (IsArray2(left))
    return ArrayType3(left, right);
  if (IsObject2(left))
    return ObjectType3(left, right);
  if (IsValueType(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDiffError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function AssertDiffable(value) {
  if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
    throw new ValueDiffError(value, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current, next) {
  AssertDiffable(current);
  AssertDiffable(next);
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (const key of nextKeys) {
    if (HasPropertyKey2(current, key))
      continue;
    yield CreateInsert(`${path}/${key}`, next[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey2(next, key))
      continue;
    if (Equal(current, next))
      continue;
    yield* Visit15(`${path}/${key}`, current[key], next[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey2(next, key))
      continue;
    yield CreateDelete(`${path}/${key}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray2(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray2(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
  return [...Visit15("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone, edit.path);
        break;
      }
    }
  }
  return clone;
}
// node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
  return encoded;
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject2(value) {
  return IsObject2(value) && !IsArray2(value);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType5(root, path, current, next) {
  if (!IsStandardObject2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType5(root, path, current, next) {
  if (!IsArray2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit16(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType3(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType3(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit16(root, path, current, next) {
  if (IsArray2(next))
    return ArrayType5(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType3(root, path, current, next);
  if (IsStandardObject2(next))
    return ObjectType5(root, path, current, next);
  if (IsValueType(next))
    return ValueType3(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject2(current) && IsArray2(next) || IsArray2(current) && IsStandardObject2(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit16(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
class ParseError2 extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
var ParseRegistry;
(function(ParseRegistry2) {
  const registry = new Map([
    ["Assert", (type, references, value) => {
      Assert(type, references, value);
      return value;
    }],
    ["Cast", (type, references, value) => Cast(type, references, value)],
    ["Clean", (type, references, value) => Clean(type, references, value)],
    ["Clone", (_type, _references, value) => Clone2(value)],
    ["Convert", (type, references, value) => Convert(type, references, value)],
    ["Decode", (type, references, value) => HasTransform(type, references) ? TransformDecode(type, references, value) : value],
    ["Default", (type, references, value) => Default5(type, references, value)],
    ["Encode", (type, references, value) => HasTransform(type, references) ? TransformEncode(type, references, value) : value]
  ]);
  function Delete5(key) {
    registry.delete(key);
  }
  ParseRegistry2.Delete = Delete5;
  function Set5(key, callback) {
    registry.set(key, callback);
  }
  ParseRegistry2.Set = Set5;
  function Get4(key) {
    return registry.get(key);
  }
  ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
function ParseValue(operations, type, references, value) {
  return operations.reduce((value2, operationKey) => {
    const operation = ParseRegistry.Get(operationKey);
    if (IsUndefined2(operation))
      throw new ParseError2(`Unable to find Parse operation '${operationKey}'`);
    return operation(type, references, value2);
  }, value);
}
function Parse(...args) {
  const [operations, schema, references, value] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? IsArray2(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault, args[0], args[1], args[2]] : args.length === 2 ? [ParseDefault, args[0], [], args[1]] : (() => {
    throw new ParseError2("Invalid Arguments");
  })();
  return ParseValue(operations, schema, references, value);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  ValueErrorIterator: () => ValueErrorIterator,
  Patch: () => Patch,
  Parse: () => Parse,
  Mutate: () => Mutate,
  Hash: () => Hash,
  Errors: () => Errors,
  Equal: () => Equal,
  Encode: () => Encode,
  Edit: () => Edit,
  Diff: () => Diff,
  Default: () => Default5,
  Decode: () => Decode,
  Create: () => Create2,
  Convert: () => Convert,
  Clone: () => Clone2,
  Clean: () => Clean,
  Check: () => Check,
  Cast: () => Cast,
  Assert: () => Assert
});
// node_modules/elysia/dist/formats.mjs
var fullFormats = {
  date,
  time: getTime(true),
  "date-time": getDateTime(true),
  "iso-time": getTime(false),
  "iso-date-time": getDateTime(false),
  duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
  uri,
  "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
  "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
  url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
  ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
  regex,
  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
  "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
  "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
  "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
  byte,
  int32: { type: "number", validate: validateInt32 },
  int64: { type: "number", validate: validateInt64 },
  float: { type: "number", validate: validateNumber },
  double: { type: "number", validate: validateNumber },
  password: true,
  binary: true
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
  const matches = DATE.exec(str);
  if (!matches)
    return false;
  const year = +matches[1];
  const month = +matches[2];
  const day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime(strictTimeZone) {
  return function time(str) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hr = +matches[1];
    const min = +matches[2];
    const sec = +matches[3];
    const tz = matches[4];
    const tzSign = matches[5] === "-" ? -1 : 1;
    const tzH = +(matches[6] || 0);
    const tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    const utcMin = min - tzM * tzSign;
    const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function getDateTime(strictTimeZone) {
  const time = getTime(strictTimeZone);
  return function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
  };
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
  BYTE.lastIndex = 0;
  return BYTE.test(str);
}
var MIN_INT32 = -(2 ** 31);
var MAX_INT32 = 2 ** 31 - 1;
function validateInt32(value) {
  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
  return Number.isInteger(value);
}
function validateNumber() {
  return true;
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str);
    return true;
  } catch (e) {
    return false;
  }
}

// node_modules/elysia/dist/utils.mjs
var hasHeaderShorthand = "toJSON" in new Headers;
var replaceUrlPath2 = (url, pathname) => {
  const urlObject = new URL(url);
  urlObject.pathname = pathname;
  return urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString && v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, {
  skipKeys,
  override = true
} = {}) => {
  if (!isObject(target) || !isObject(source))
    return target;
  for (const [key, value] of Object.entries(source)) {
    if (skipKeys?.includes(key))
      continue;
    if (!isObject(value) || !(key in target) || isClass(value)) {
      if (override || !(key in target))
        target[key] = value;
      continue;
    }
    target[key] = mergeDeep(target[key], value, { skipKeys, override });
  }
  return target;
};
var mergeCookie = (a, b) => {
  const v = mergeDeep(Object.assign({}, a), b, {
    skipKeys: ["properties"]
  });
  if ("properties" in v)
    delete v.properties;
  return v;
};
var mergeObjectArray2 = (a = [], b = []) => {
  if (!a)
    return;
  if (!b)
    return a;
  const array = [];
  const checksums = [];
  if (!Array.isArray(a))
    a = [a];
  if (!Array.isArray(b))
    b = [b];
  for (const item of a) {
    array.push(item);
    if (item.checksum)
      checksums.push(item.checksum);
  }
  for (const item of b)
    if (!checksums.includes(item.checksum))
      array.push(item);
  return array;
};
var primitiveHooks = [
  "start",
  "request",
  "parse",
  "transform",
  "resolve",
  "beforeHandle",
  "afterHandle",
  "mapResponse",
  "afterResponse",
  "trace",
  "error",
  "stop",
  "body",
  "headers",
  "params",
  "query",
  "response",
  "type",
  "detail"
];
var primitiveHookMap = primitiveHooks.reduce((acc, x) => (acc[x] = true, acc), {});
var mergeResponse = (a, b) => {
  const isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every(isNumericString);
  if (isRecordNumber(a) && isRecordNumber(b))
    return Object.assign(a, b);
  else if (a && !isRecordNumber(a) && isRecordNumber(b))
    return Object.assign({ 200: a }, b);
  return b ?? a;
};
var mergeSchemaValidator = (a, b) => {
  return {
    body: b?.body ?? a?.body,
    headers: b?.headers ?? a?.headers,
    params: b?.params ?? a?.params,
    query: b?.query ?? a?.query,
    cookie: b?.cookie ?? a?.cookie,
    response: mergeResponse(a?.response, b?.response)
  };
};
var mergeHook2 = (a, b) => {
  const { resolve: resolveA, ...restA } = a ?? {};
  const { resolve: resolveB, ...restB } = b ?? {};
  return {
    ...restA,
    ...restB,
    body: b?.body ?? a?.body,
    headers: b?.headers ?? a?.headers,
    params: b?.params ?? a?.params,
    query: b?.query ?? a?.query,
    cookie: b?.cookie ?? a?.cookie,
    response: mergeResponse(a?.response, b?.response),
    type: a?.type || b?.type,
    detail: mergeDeep(b?.detail ?? {}, a?.detail ?? {}),
    parse: mergeObjectArray2(a?.parse, b?.parse),
    transform: mergeObjectArray2(a?.transform, b?.transform),
    beforeHandle: mergeObjectArray2(mergeObjectArray2(fnToContainer(resolveA, "resolve"), a?.beforeHandle), mergeObjectArray2(fnToContainer(resolveB, "resolve"), b?.beforeHandle)),
    afterHandle: mergeObjectArray2(a?.afterHandle, b?.afterHandle),
    mapResponse: mergeObjectArray2(a?.mapResponse, b?.mapResponse),
    afterResponse: mergeObjectArray2(a?.afterResponse, b?.afterResponse),
    trace: mergeObjectArray2(a?.trace, b?.trace),
    error: mergeObjectArray2(a?.error, b?.error)
  };
};
var replaceSchemaType2 = (schema, options, root = true) => {
  if (!Array.isArray(options)) {
    options.original = schema;
    return _replaceSchemaType(schema, options, root);
  }
  for (const option of options) {
    option.original = schema;
    schema = _replaceSchemaType(schema, option, root);
  }
  return schema;
};
var _replaceSchemaType = (schema, options, root = true) => {
  if (!schema)
    return schema;
  if (options.untilObjectFound && !root && schema.type === "object")
    return schema;
  const fromSymbol = options.from[Kind];
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      schema.oneOf[i] = _replaceSchemaType(schema.oneOf[i], options, root);
    return schema;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      schema.anyOf[i] = _replaceSchemaType(schema.anyOf[i], options, root);
    return schema;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      schema.allOf[i] = _replaceSchemaType(schema.allOf[i], options, root);
    return schema;
  }
  if (schema.not)
    return _replaceSchemaType(schema.not, options, root);
  const isRoot = root && !!options.excludeRoot;
  if (schema[Kind] === fromSymbol) {
    const { anyOf, oneOf, allOf, not, properties: properties2, items, ...rest } = schema;
    const to = options.to(rest);
    if (!to)
      return schema;
    let transform2;
    const composeProperties = (v) => {
      if (properties2 && v.type === "object") {
        const newProperties = {};
        for (const [key, value2] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value2, options, false);
        return {
          ...rest,
          ...v,
          properties: newProperties
        };
      }
      if (items && v.type === "array")
        return {
          ...rest,
          ...v,
          items: _replaceSchemaType(items, options, false)
        };
      const value = {
        ...rest,
        ...v
      };
      delete value["required"];
      if (properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}") {
        transform2 = t2.ObjectString(properties2, rest);
        value.default = JSON.stringify(exports_value2.Create(t2.Object(properties2)));
        value.properties = properties2;
      }
      if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]") {
        transform2 = t2.ArrayString(items, rest);
        value.default = JSON.stringify(exports_value2.Create(t2.Array(items)));
        value.items = items;
      }
      return value;
    };
    if (isRoot) {
      if (properties2) {
        const newProperties = {};
        for (const [key, value] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value, options, false);
        return {
          ...rest,
          properties: newProperties
        };
      } else if (items?.map)
        return {
          ...rest,
          items: items.map((v) => _replaceSchemaType(v, options, false))
        };
      return rest;
    }
    if (to.anyOf)
      for (let i = 0;i < to.anyOf.length; i++)
        to.anyOf[i] = composeProperties(to.anyOf[i]);
    else if (to.oneOf)
      for (let i = 0;i < to.oneOf.length; i++)
        to.oneOf[i] = composeProperties(to.oneOf[i]);
    else if (to.allOf)
      for (let i = 0;i < to.allOf.length; i++)
        to.allOf[i] = composeProperties(to.allOf[i]);
    else if (to.not)
      to.not = composeProperties(to.not);
    if (transform2)
      to[TransformKind] = transform2[TransformKind];
    if (to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      const newProperties = {};
      for (const [key, value] of Object.entries(properties2))
        newProperties[key] = _replaceSchemaType(value, options, false);
      return {
        ...rest,
        ...to,
        properties: newProperties
      };
    } else if (items?.map)
      return {
        ...rest,
        ...to,
        items: items.map((v) => _replaceSchemaType(v, options, false))
      };
    return {
      ...rest,
      ...to
    };
  }
  const properties = schema?.properties;
  if (properties && root && options.rootOnly !== true)
    for (const [key, value] of Object.entries(properties)) {
      switch (value[Kind]) {
        case fromSymbol:
          const { anyOf, oneOf, allOf, not, type, ...rest } = value;
          const to = options.to(rest);
          if (!to)
            return schema;
          if (to.anyOf)
            for (let i = 0;i < to.anyOf.length; i++)
              to.anyOf[i] = { ...rest, ...to.anyOf[i] };
          else if (to.oneOf)
            for (let i = 0;i < to.oneOf.length; i++)
              to.oneOf[i] = { ...rest, ...to.oneOf[i] };
          else if (to.allOf)
            for (let i = 0;i < to.allOf.length; i++)
              to.allOf[i] = { ...rest, ...to.allOf[i] };
          else if (to.not)
            to.not = { ...rest, ...to.not };
          properties[key] = {
            ...rest,
            ..._replaceSchemaType(rest, options, false)
          };
          break;
        case "Object":
        case "Union":
          properties[key] = _replaceSchemaType(value, options, false);
          break;
        default:
          if (Array.isArray(value.items)) {
            for (let i = 0;i < value.items.length; i++) {
              value.items[i] = _replaceSchemaType(value.items[i], options, false);
            }
          } else if (value.anyOf || value.oneOf || value.allOf || value.not)
            properties[key] = _replaceSchemaType(value, options, false);
          else if (value.type === "array") {
            value.items = _replaceSchemaType(value.items, options, false);
          }
          break;
      }
    }
  return schema;
};
var createCleaner = (schema) => (value) => {
  if (typeof value === "object")
    try {
      return exports_value2.Clean(schema, structuredClone(value));
    } catch {
      try {
        return exports_value2.Clean(schema, value);
      } catch {
        return value;
      }
    }
  return value;
};
var getSchemaValidator2 = (s, {
  models = {},
  dynamic = false,
  modules,
  normalize = false,
  additionalProperties = false,
  coerce = false,
  additionalCoerce = []
} = {
  modules: t2.Module({})
}) => {
  if (!s)
    return;
  let schema;
  if (typeof s !== "string")
    schema = s;
  else {
    const isArray = s.endsWith("[]");
    const key = isArray ? s.substring(0, s.length - 2) : s;
    schema = modules.Import(key) ?? models[key];
    if (isArray)
      schema = t2.Array(schema);
  }
  if (!schema)
    return;
  if (coerce || additionalCoerce) {
    if (coerce)
      schema = replaceSchemaType2(schema, [
        {
          from: t2.Ref(""),
          to: (options) => modules.Import(options["$ref"])
        },
        {
          from: t2.Number(),
          to: (options) => t2.Numeric(options),
          untilObjectFound: true
        },
        {
          from: t2.Boolean(),
          to: (options) => t2.BooleanString(options),
          untilObjectFound: true
        },
        ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]
      ]);
    else {
      schema = replaceSchemaType2(schema, [
        {
          from: t2.Ref(""),
          to: (options) => modules.Import(options["$ref"])
        },
        ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]
      ]);
    }
  }
  if (schema.type === "object" && "additionalProperties" in schema === false)
    schema.additionalProperties = additionalProperties;
  if (dynamic) {
    const validator = {
      schema,
      references: "",
      checkFunc: () => {},
      code: "",
      Check: (value) => exports_value2.Check(schema, value),
      Errors: (value) => exports_value2.Errors(schema, value),
      Code: () => "",
      Clean: createCleaner(schema),
      Decode: (value) => exports_value2.Decode(schema, value),
      Encode: (value) => exports_value2.Encode(schema, value)
    };
    if (normalize && schema.additionalProperties === false)
      validator.Clean = createCleaner(schema);
    if (schema.config) {
      validator.config = schema.config;
      if (validator?.schema?.config)
        delete validator.schema.config;
    }
    validator.parse = (v) => {
      try {
        return validator.Decode(v);
      } catch (error2) {
        throw [...validator.Errors(v)].map(mapValueError2);
      }
    };
    validator.safeParse = (v) => {
      try {
        return { success: true, data: validator.Decode(v), error: null };
      } catch (error2) {
        const errors = [...compiled.Errors(v)].map(mapValueError2);
        return {
          success: false,
          data: null,
          error: errors[0]?.summary,
          errors
        };
      }
    };
    return validator;
  }
  const compiled = TypeCompiler2.Compile(schema, Object.values(models));
  compiled.Clean = createCleaner(schema);
  if (schema.config) {
    compiled.config = schema.config;
    if (compiled?.schema?.config)
      delete compiled.schema.config;
  }
  compiled.parse = (v) => {
    try {
      return compiled.Decode(v);
    } catch (error2) {
      throw [...compiled.Errors(v)].map(mapValueError2);
    }
  };
  compiled.safeParse = (v) => {
    try {
      return { success: true, data: compiled.Decode(v), error: null };
    } catch (error2) {
      const errors = [...compiled.Errors(v)].map(mapValueError2);
      return {
        success: false,
        data: null,
        error: errors[0]?.summary,
        errors
      };
    }
  };
  return compiled;
};
var getResponseSchemaValidator2 = (s, {
  models = {},
  modules,
  dynamic = false,
  normalize = false,
  additionalProperties = false
}) => {
  if (!s)
    return;
  let maybeSchemaOrRecord;
  if (typeof s !== "string")
    maybeSchemaOrRecord = s;
  else {
    const isArray = s.endsWith("[]");
    const key = isArray ? s.substring(0, s.length - 2) : s;
    maybeSchemaOrRecord = modules.Import(key) ?? models[key];
    if (isArray)
      maybeSchemaOrRecord = t2.Array(maybeSchemaOrRecord);
  }
  if (!maybeSchemaOrRecord)
    return;
  const compile = (schema, references) => {
    if (dynamic)
      return {
        schema,
        references: "",
        checkFunc: () => {},
        code: "",
        Check: (value) => exports_value2.Check(schema, value),
        Errors: (value) => exports_value2.Errors(schema, value),
        Code: () => "",
        Clean: createCleaner(schema),
        Decode: (value) => exports_value2.Decode(schema, value),
        Encode: (value) => exports_value2.Encode(schema, value)
      };
    const compiledValidator = TypeCompiler2.Compile(schema, references);
    if (normalize && schema.additionalProperties === false)
      compiledValidator.Clean = createCleaner(schema);
    return compiledValidator;
  };
  const modelValues = Object.values(models);
  if (Kind in maybeSchemaOrRecord) {
    if ("additionalProperties" in maybeSchemaOrRecord === false)
      maybeSchemaOrRecord.additionalProperties = additionalProperties;
    return {
      200: compile(maybeSchemaOrRecord, modelValues)
    };
  }
  const record = {};
  Object.keys(maybeSchemaOrRecord).forEach((status) => {
    const maybeNameOrSchema = maybeSchemaOrRecord[+status];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        const schema = models[maybeNameOrSchema];
        schema.type === "object" && "additionalProperties" in schema;
        record[+status] = Kind in schema ? compile(schema, modelValues) : schema;
      }
      return;
    }
    if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
      maybeNameOrSchema.additionalProperties = additionalProperties;
    record[+status] = Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, modelValues) : maybeNameOrSchema;
  });
  return record;
};
var isBun = typeof Bun !== "undefined";
var hasHash = isBun && typeof Bun.hash === "function";
var checksum2 = (s) => {
  if (hasHash)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
  return h = h ^ h >>> 9;
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => {
  if (!_stringToStructureCoercions) {
    _stringToStructureCoercions = [
      {
        from: t2.Object({}),
        to: () => t2.ObjectString({}),
        excludeRoot: true
      },
      {
        from: t2.Array(t2.Any()),
        to: () => t2.ArrayString(t2.Any())
      }
    ];
  }
  return _stringToStructureCoercions;
};
var _coercePrimitiveRoot;
var coercePrimitiveRoot = () => {
  if (!_coercePrimitiveRoot)
    _coercePrimitiveRoot = [
      {
        from: t2.Number(),
        to: (options) => t2.Numeric(options),
        rootOnly: true
      },
      {
        from: t2.Boolean(),
        to: (options) => t2.BooleanString(options),
        rootOnly: true
      }
    ];
  return _coercePrimitiveRoot;
};
var getCookieValidator = ({
  validator,
  modules,
  defaultConfig = {},
  config,
  dynamic,
  models
}) => {
  let cookieValidator = getSchemaValidator2(validator, {
    modules,
    dynamic,
    models,
    additionalProperties: true,
    coerce: true,
    additionalCoerce: stringToStructureCoercions()
  });
  if (isNotEmpty(defaultConfig)) {
    if (cookieValidator) {
      cookieValidator.config = mergeCookie(cookieValidator.config, config);
    } else {
      cookieValidator = getSchemaValidator2(t2.Cookie({}), {
        modules,
        dynamic,
        models,
        additionalProperties: true
      });
      cookieValidator.config = defaultConfig;
    }
  }
  return cookieValidator;
};
var injectChecksum = (checksum22, x) => {
  if (!x)
    return;
  if (!Array.isArray(x)) {
    const fn = x;
    if (checksum22 && !fn.checksum)
      fn.checksum = checksum22;
    if (fn.scope === "scoped")
      fn.scope = "local";
    return fn;
  }
  const fns = [...x];
  for (const fn of fns) {
    if (checksum22 && !fn.checksum)
      fn.checksum = checksum22;
    if (fn.scope === "scoped")
      fn.scope = "local";
  }
  return fns;
};
var mergeLifeCycle = (a, b, checksum22) => {
  return {
    start: mergeObjectArray2(a.start, injectChecksum(checksum22, b?.start)),
    request: mergeObjectArray2(a.request, injectChecksum(checksum22, b?.request)),
    parse: mergeObjectArray2(a.parse, injectChecksum(checksum22, b?.parse)),
    transform: mergeObjectArray2(a.transform, injectChecksum(checksum22, b?.transform)),
    beforeHandle: mergeObjectArray2(mergeObjectArray2(fnToContainer(a.resolve, "resolve"), a.beforeHandle), injectChecksum(checksum22, mergeObjectArray2(fnToContainer(b?.resolve, "resolve"), b?.beforeHandle))),
    afterHandle: mergeObjectArray2(a.afterHandle, injectChecksum(checksum22, b?.afterHandle)),
    mapResponse: mergeObjectArray2(a.mapResponse, injectChecksum(checksum22, b?.mapResponse)),
    afterResponse: mergeObjectArray2(a.afterResponse, injectChecksum(checksum22, b?.afterResponse)),
    trace: mergeObjectArray2(a.trace, injectChecksum(checksum22, b?.trace)),
    error: mergeObjectArray2(a.error, injectChecksum(checksum22, b?.error)),
    stop: mergeObjectArray2(a.stop, injectChecksum(checksum22, b?.stop))
  };
};
var asHookType = (fn, inject, { skipIfHasType = false } = {}) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (const x of fn)
    if (skipIfHasType)
      x.scope ??= inject;
    else
      x.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  const array = [];
  for (const x of fn)
    switch (x.scope) {
      case "global":
      case "scoped":
        array.push({
          ...x
        });
        break;
    }
  return array;
};
var filterGlobalHook = (hook) => {
  return {
    ...hook,
    type: hook?.type,
    detail: hook?.detail,
    parse: filterGlobal(hook?.parse),
    transform: filterGlobal(hook?.transform),
    beforeHandle: filterGlobal(hook?.beforeHandle),
    afterHandle: filterGlobal(hook?.afterHandle),
    mapResponse: filterGlobal(hook?.mapResponse),
    afterResponse: filterGlobal(hook?.afterResponse),
    error: filterGlobal(hook?.error),
    trace: filterGlobal(hook?.trace)
  };
};
var StatusMap2 = {
  Continue: 100,
  "Switching Protocols": 101,
  Processing: 102,
  "Early Hints": 103,
  OK: 200,
  Created: 201,
  Accepted: 202,
  "Non-Authoritative Information": 203,
  "No Content": 204,
  "Reset Content": 205,
  "Partial Content": 206,
  "Multi-Status": 207,
  "Already Reported": 208,
  "Multiple Choices": 300,
  "Moved Permanently": 301,
  Found: 302,
  "See Other": 303,
  "Not Modified": 304,
  "Temporary Redirect": 307,
  "Permanent Redirect": 308,
  "Bad Request": 400,
  Unauthorized: 401,
  "Payment Required": 402,
  Forbidden: 403,
  "Not Found": 404,
  "Method Not Allowed": 405,
  "Not Acceptable": 406,
  "Proxy Authentication Required": 407,
  "Request Timeout": 408,
  Conflict: 409,
  Gone: 410,
  "Length Required": 411,
  "Precondition Failed": 412,
  "Payload Too Large": 413,
  "URI Too Long": 414,
  "Unsupported Media Type": 415,
  "Range Not Satisfiable": 416,
  "Expectation Failed": 417,
  "I'm a teapot": 418,
  "Misdirected Request": 421,
  "Unprocessable Content": 422,
  Locked: 423,
  "Failed Dependency": 424,
  "Too Early": 425,
  "Upgrade Required": 426,
  "Precondition Required": 428,
  "Too Many Requests": 429,
  "Request Header Fields Too Large": 431,
  "Unavailable For Legal Reasons": 451,
  "Internal Server Error": 500,
  "Not Implemented": 501,
  "Bad Gateway": 502,
  "Service Unavailable": 503,
  "Gateway Timeout": 504,
  "HTTP Version Not Supported": 505,
  "Variant Also Negotiates": 506,
  "Insufficient Storage": 507,
  "Loop Detected": 508,
  "Not Extended": 510,
  "Network Authentication Required": 511
};
var InvertedStatusMap2 = Object.fromEntries(Object.entries(StatusMap2).map(([k, v]) => [v, k]));
function removeTrailingEquals(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("=")) {
    trimmedDigest = trimmedDigest.slice(0, -1);
  }
  return trimmedDigest;
}
var encoder = new TextEncoder;
var signCookie = async (val, secret) => {
  if (typeof val !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
  const hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const tentativeValue = input.slice(0, input.lastIndexOf("."));
  const expectedInput = await signCookie(tentativeValue, secret);
  return expectedInput === input ? tentativeValue : false;
};
var traceBackMacro = (extension, property, manage) => {
  if (!extension || typeof extension !== "object" || !property)
    return;
  for (const [key, value] of Object.entries(property)) {
    if (key in primitiveHookMap || !(key in extension))
      continue;
    const v = extension[key];
    if (typeof v === "function") {
      const hook = v(value);
      if (typeof hook === "object") {
        for (const [k, v2] of Object.entries(hook)) {
          manage(k)({
            fn: v2
          });
        }
      }
    }
    delete property[key];
  }
};
var createMacroManager = ({
  globalHook,
  localHook
}) => (stackName) => (type, fn) => {
  if (typeof type === "function")
    type = {
      fn: type
    };
  if (stackName === "resolve") {
    type = {
      ...type,
      subType: "resolve"
    };
  }
  if ("fn" in type || Array.isArray(type)) {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (Array.isArray(type))
      localHook[stackName] = localHook[stackName].concat(type);
    else
      localHook[stackName].push(type);
    return;
  }
  const { insert = "after", stack = "local" } = type;
  if (typeof fn === "function")
    fn = { fn };
  if (stack === "global") {
    if (!Array.isArray(fn)) {
      if (insert === "before") {
        globalHook[stackName].unshift(fn);
      } else {
        globalHook[stackName].push(fn);
      }
    } else {
      if (insert === "before") {
        globalHook[stackName] = fn.concat(globalHook[stackName]);
      } else {
        globalHook[stackName] = globalHook[stackName].concat(fn);
      }
    }
  } else {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (!Array.isArray(fn)) {
      if (insert === "before") {
        localHook[stackName].unshift(fn);
      } else {
        localHook[stackName].push(fn);
      }
    } else {
      if (insert === "before") {
        localHook[stackName] = fn.concat(localHook[stackName]);
      } else {
        localHook[stackName] = localHook[stackName].concat(fn);
      }
    }
  }
};
var parseNumericString = (message) => {
  if (typeof message === "number")
    return message;
  if (message.length < 16) {
    if (message.trim().length === 0)
      return null;
    const length = Number(message);
    if (Number.isNaN(length))
      return null;
    return length;
  }
  if (message.length === 16) {
    if (message.trim().length === 0)
      return null;
    const number = Number(message);
    if (Number.isNaN(number) || number.toString() !== message)
      return null;
    return number;
  }
  return null;
};
var isNumericString = (message) => parseNumericString(message) !== null;

class PromiseGroup {
  constructor(onError = console.error) {
    this.onError = onError;
    this.root = null;
    this.promises = [];
  }
  get size() {
    return this.promises.length;
  }
  add(promise) {
    this.promises.push(promise);
    this.root ||= this.drain();
    return promise;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error2) {
        this.onError(error2);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
}
var fnToContainer = (fn, subType) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function" || typeof fn === "string")
      return subType ? { fn, subType } : { fn };
    else if ("fn" in fn)
      return fn;
  }
  const fns = [];
  for (const x of fn) {
    if (typeof x === "function" || typeof x === "string")
      fns.push(subType ? { fn: x, subType } : { fn: x });
    else if ("fn" in x)
      fns.push(x);
  }
  return fns;
};
var localHookToLifeCycleStore = (a) => {
  return {
    ...a,
    start: fnToContainer(a?.start),
    request: fnToContainer(a?.request),
    parse: fnToContainer(a?.parse),
    transform: fnToContainer(a?.transform),
    beforeHandle: fnToContainer(a?.beforeHandle),
    afterHandle: fnToContainer(a?.afterHandle),
    mapResponse: fnToContainer(a?.mapResponse),
    afterResponse: fnToContainer(a?.afterResponse),
    trace: fnToContainer(a?.trace),
    error: fnToContainer(a?.error),
    stop: fnToContainer(a?.stop)
  };
};
var lifeCycleToFn = (a) => {
  const hook = {};
  if (a.start?.map)
    hook.start = a.start.map((x) => x.fn);
  if (a.request?.map)
    hook.request = a.request.map((x) => x.fn);
  if (a.parse?.map)
    hook.parse = a.parse.map((x) => x.fn);
  if (a.transform?.map)
    hook.transform = a.transform.map((x) => x.fn);
  if (a.beforeHandle?.map)
    hook.beforeHandle = a.beforeHandle.map((x) => x.fn);
  if (a.afterHandle?.map)
    hook.afterHandle = a.afterHandle.map((x) => x.fn);
  if (a.mapResponse?.map)
    hook.mapResponse = a.mapResponse.map((x) => x.fn);
  if (a.afterResponse?.map)
    hook.afterResponse = a.afterResponse.map((x) => x.fn);
  if (a.trace?.map)
    hook.trace = a.trace.map((x) => x.fn);
  if (a.error?.map)
    hook.error = a.error.map((x) => x.fn);
  if (a.stop?.map)
    hook.stop = a.stop.map((x) => x.fn);
  return hook;
};
var cloneInference2 = (inference) => ({
  body: inference.body,
  cookie: inference.cookie,
  headers: inference.headers,
  query: inference.query,
  set: inference.set,
  server: inference.server,
  request: inference.request,
  route: inference.route
});
var redirect2 = (url, status = 302) => Response.redirect(url, status);
var ELYSIA_FORM_DATA2 = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID2 = Symbol("ElysiaRequestId");
var randomId = () => {
  const uuid = crypto.randomUUID();
  return uuid.slice(0, 8) + uuid.slice(24, 32);
};
var deduplicateChecksum2 = (array) => {
  const hashes = [];
  for (let i = 0;i < array.length; i++) {
    const item = array[i];
    if (item.checksum) {
      if (hashes.includes(item.checksum)) {
        array.splice(i, 1);
        i--;
      }
      hashes.push(item.checksum);
    }
  }
  return array;
};
var promoteEvent = (events, as = "scoped") => {
  if (!events)
    return;
  if (as === "scoped") {
    for (const event of events)
      if ("scope" in event && event.scope === "local")
        event.scope = "scoped";
    return;
  }
  for (const event of events)
    if ("scope" in event)
      event.scope = "global";
};
var getLoosePath = (path) => {
  if (path.charCodeAt(path.length - 1) === 47)
    return path.slice(0, path.length - 1);
  return path + "/";
};
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (const x in obj)
    return true;
  return false;
};
var isEmptyHookProperty = (prop) => {
  if (Array.isArray(prop))
    return prop.length === 0;
  return !prop;
};
var compressHistoryHook = (hook) => {
  const history = { ...hook };
  if (isEmptyHookProperty(hook.afterHandle))
    delete history.afterHandle;
  if (isEmptyHookProperty(hook.afterResponse))
    delete history.afterResponse;
  if (isEmptyHookProperty(hook.beforeHandle))
    delete history.beforeHandle;
  if (isEmptyHookProperty(hook.error))
    delete history.error;
  if (isEmptyHookProperty(hook.mapResponse))
    delete history.mapResponse;
  if (isEmptyHookProperty(hook.parse))
    delete history.parse;
  if (isEmptyHookProperty(hook.request))
    delete history.request;
  if (isEmptyHookProperty(hook.start))
    delete history.start;
  if (isEmptyHookProperty(hook.stop))
    delete history.stop;
  if (isEmptyHookProperty(hook.trace))
    delete history.trace;
  if (isEmptyHookProperty(hook.transform))
    delete history.transform;
  if (!history.type)
    delete history.type;
  if (history.detail && !Object.keys(history.detail).length)
    delete history.detail;
  if (!history.body)
    delete history.body;
  if (!history.cookie)
    delete history.cookie;
  if (!history.headers)
    delete history.headers;
  if (!history.query)
    delete history.query;
  if (!history.params)
    delete history.params;
  if (!history.response)
    delete history.response;
  return history;
};
var encodePath = (path, { dynamic = false } = {}) => {
  let encoded = encodeURIComponent(path).replace(/%2F/g, "/");
  if (dynamic)
    encoded = encoded.replace(/%3A/g, ":").replace(/%3F/g, "?");
  return encoded;
};

// node_modules/elysia/dist/error.mjs
var env2 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var ERROR_CODE2 = Symbol("ElysiaErrorCode");
var isProduction = (env2?.NODE_ENV ?? env2?.ENV) === "production";

class ElysiaCustomStatusResponse {
  constructor(code, response) {
    const res = response ?? (code in InvertedStatusMap2 ? InvertedStatusMap2[code] : code);
    this.code = StatusMap2[code] ?? code;
    this.response = res;
  }
}
var error2 = (code, response) => new ElysiaCustomStatusResponse(code, response);

class InternalServerError2 extends Error {
  constructor(message) {
    super(message ?? "INTERNAL_SERVER_ERROR");
    this.code = "INTERNAL_SERVER_ERROR";
    this.status = 500;
  }
}

class NotFoundError2 extends Error {
  constructor(message) {
    super(message ?? "NOT_FOUND");
    this.code = "NOT_FOUND";
    this.status = 404;
  }
}

class ParseError3 extends Error {
  constructor() {
    super("Bad Request");
    this.code = "PARSE";
    this.status = 400;
  }
}

class InvalidCookieSignature2 extends Error {
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
    this.code = "INVALID_COOKIE_SIGNATURE";
    this.status = 400;
  }
}
var mapValueError2 = (error22) => {
  if (!error22)
    return {
      summary: undefined
    };
  const { message, path, value, type } = error22;
  const property = path.slice(1).replaceAll("/", ".");
  const isRoot = path === "";
  switch (type) {
    case 42:
      return {
        ...error22,
        summary: isRoot ? `Value should not be provided` : `Property '${property}' should not be provided`
      };
    case 45:
      return {
        ...error22,
        summary: isRoot ? `Value is missing` : `Property '${property}' is missing`
      };
    case 50:
      const quoteIndex = message.indexOf("'");
      const format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
      return {
        ...error22,
        summary: isRoot ? `Value should be an email` : `Property '${property}' should be ${format}`
      };
    case 54:
      return {
        ...error22,
        summary: `${message.slice(0, 9)} property '${property}' to be ${message.slice(8)} but found: ${value}`
      };
    case 62:
      const union = error22.schema.anyOf.map((x) => `'${x?.format ?? x.type}'`).join(", ");
      return {
        ...error22,
        summary: isRoot ? `Value should be one of ${union}` : `Property '${property}' should be one of: ${union}`
      };
    default:
      return { summary: message, ...error22 };
  }
};

class ValidationError2 extends Error {
  constructor(type, validator, value) {
    if (value && typeof value === "object" && value instanceof ElysiaCustomStatusResponse)
      value = value.response;
    const error22 = isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value).First() : exports_value2.Errors(validator, value).First();
    const customError = error22?.schema?.message || error22?.schema?.error !== undefined ? typeof error22.schema.error === "function" ? error22.schema.error({
      type,
      validator,
      value,
      get errors() {
        return [...validator.Errors(value)].map(mapValueError2);
      }
    }) : error22.schema.error : undefined;
    const accessor = error22?.path || "root";
    let message = "";
    if (customError !== undefined) {
      message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    } else if (isProduction) {
      message = JSON.stringify({
        type: "validation",
        on: type,
        summary: mapValueError2(error22).summary,
        message: error22?.message,
        found: value
      });
    } else {
      const schema = validator?.schema ?? validator;
      const errors = "Errors" in validator ? [...validator.Errors(value)].map(mapValueError2) : [...exports_value2.Errors(validator, value)].map(mapValueError2);
      let expected;
      try {
        expected = exports_value2.Create(schema);
      } catch (error3) {
        expected = {
          type: "Could not create expected value",
          message: error3?.message,
          error: error3
        };
      }
      message = JSON.stringify({
        type: "validation",
        on: type,
        summary: mapValueError2(error22).summary,
        property: accessor,
        message: error22?.message,
        expected,
        found: value,
        errors
      }, null, 2);
    }
    super(message);
    this.type = type;
    this.validator = validator;
    this.value = value;
    this.code = "VALIDATION";
    this.status = 422;
    Object.setPrototypeOf(this, ValidationError2.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError2) : [...exports_value2.Errors(this.validator, this.value)].map(mapValueError2);
  }
  static simplifyModel(validator) {
    const model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return ValidationError2.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, {
      status: 400,
      headers: {
        ...headers,
        "content-type": "application/json"
      }
    });
  }
}

// node_modules/elysia/dist/type-system.mjs
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
  exports_format.Set("date", (value) => {
    const temp = value.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
      const date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  exports_format.Set("date-time", (value) => {
    const temp = value.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
      const date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats).forEach((formatEntry) => {
  const [formatName, formatValue] = formatEntry;
  if (!exports_format.Has(formatName)) {
    if (formatValue instanceof RegExp)
      exports_format.Set(formatName, (value) => formatValue.test(value));
    else if (typeof formatValue === "function")
      exports_format.Set(formatName, formatValue);
  }
});
var t2 = Object.assign({}, Type);
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var checkFileExtension = (type, extension) => {
  if (type.startsWith(extension))
    return true;
  return extension.charCodeAt(extension.length - 1) === 42 && extension.charCodeAt(extension.length - 2) === 47 && type.startsWith(extension.slice(0, -1));
};
var validateFile = (options, value) => {
  if (!(value instanceof Blob))
    return false;
  if (options.minSize && value.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension) {
    if (typeof options.extension === "string")
      return checkFileExtension(value.type, options.extension);
    for (let i = 0;i < options.extension.length; i++)
      if (checkFileExtension(value.type, options.extension[i]))
        return true;
    return false;
  }
  return true;
};
var File2 = getOrSetType("File", validateFile);
var Files = getOrSetType("Files", (options, value) => {
  if (!Array.isArray(value))
    return validateFile(options, value);
  if (options.minItems && value.length < options.minItems)
    return false;
  if (options.maxItems && value.length > options.maxItems)
    return false;
  for (let i = 0;i < value.length; i++)
    if (!validateFile(options, value[i]))
      return false;
  return true;
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", (value) => !!value && !isNaN(+value));
if (!exports_format.Has("integer"))
  exports_format.Set("integer", (value) => !!value && Number.isInteger(+value));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", (value) => value === "true" || value === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      JSON.parse(value);
      return true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      JSON.parse(value);
      return true;
    } catch {
      return false;
    }
  });
if (!exports_type2.Has("UnionEnum"))
  exports_type2.Set("UnionEnum", (schema, value) => {
    return (typeof value === "number" || typeof value === "string" || value === null) && schema.enum.includes(value);
  });
var ElysiaType = {
  Numeric: (property) => {
    const schema = Type.Number(property);
    return t2.Transform(t2.Union([
      t2.String({
        format: "numeric",
        default: 0
      }),
      t2.Number(property)
    ], property)).Decode((value) => {
      const number = +value;
      if (isNaN(number))
        return value;
      if (property && !exports_value2.Check(schema, number))
        throw new ValidationError2("property", schema, number);
      return number;
    }).Encode((value) => value);
  },
  Integer: (property) => {
    const schema = Type.Integer(property);
    return t2.Transform(t2.Union([
      t2.String({
        format: "integer",
        default: 0
      }),
      Type.Integer(property)
    ], property)).Decode((value) => {
      const number = +value;
      if (!exports_value2.Check(schema, number))
        throw new ValidationError2("property", schema, number);
      return number;
    }).Encode((value) => value);
  },
  Date: (property) => {
    const schema = Type.Date(property);
    const _default = property?.default ? new Date(property.default) : undefined;
    return t2.Transform(t2.Union([
      Type.Date(property),
      t2.String({
        format: "date",
        default: _default?.toISOString()
      }),
      t2.String({
        format: "date-time",
        default: _default?.toISOString()
      }),
      t2.Number({ default: _default?.getTime() })
    ], property)).Decode((value) => {
      if (typeof value === "number") {
        const date22 = new Date(value);
        if (!exports_value2.Check(schema, date22))
          throw new ValidationError2("property", schema, date22);
        return date22;
      }
      if (value instanceof Date)
        return value;
      const date2 = new Date(value);
      if (!date2 || isNaN(date2.getTime()))
        throw new ValidationError2("property", schema, date2);
      if (!exports_value2.Check(schema, date2))
        throw new ValidationError2("property", schema, date2);
      return date2;
    }).Encode((value) => value.toISOString());
  },
  BooleanString: (property) => {
    const schema = Type.Boolean(property);
    return t2.Transform(t2.Union([
      t2.Boolean(property),
      t2.String({
        format: "boolean",
        default: false
      })
    ], property)).Decode((value) => {
      if (typeof value === "string")
        return value === "true";
      if (value !== undefined && !exports_value2.Check(schema, value))
        throw new ValidationError2("property", schema, value);
      return value;
    }).Encode((value) => value);
  },
  ObjectString: (properties, options) => {
    const schema = t2.Object(properties, options);
    const defaultValue = JSON.stringify(exports_value2.Create(schema));
    let compiler;
    try {
      compiler = TypeCompiler2.Compile(schema);
    } catch {}
    return t2.Transform(t2.Union([
      t2.String({
        format: "ObjectString",
        default: defaultValue
      }),
      schema
    ])).Decode((value) => {
      if (typeof value === "string") {
        if (value.charCodeAt(0) !== 123)
          throw new ValidationError2("property", schema, value);
        try {
          value = JSON.parse(value);
        } catch {
          throw new ValidationError2("property", schema, value);
        }
        if (compiler) {
          if (!compiler.Check(value))
            throw new ValidationError2("property", schema, value);
          return compiler.Decode(value);
        }
        if (!exports_value2.Check(schema, value))
          throw new ValidationError2("property", schema, value);
        return exports_value2.Decode(schema, value);
      }
      return value;
    }).Encode((value) => {
      if (typeof value === "string")
        try {
          value = JSON.parse(value);
        } catch {
          throw new ValidationError2("property", schema, value);
        }
      if (!exports_value2.Check(schema, value))
        throw new ValidationError2("property", schema, value);
      return JSON.stringify(value);
    });
  },
  ArrayString: (children = t2.String(), options) => {
    const schema = t2.Array(children, options);
    let compiler;
    try {
      compiler = TypeCompiler2.Compile(schema);
    } catch {}
    const decode2 = (value, isProperty = false) => {
      if (value.charCodeAt(0) === 91) {
        try {
          value = JSON.parse(value);
        } catch {
          throw new ValidationError2("property", schema, value);
        }
        if (compiler) {
          if (!compiler.Check(value))
            throw new ValidationError2("property", schema, value);
          return compiler.Decode(value);
        }
        if (!exports_value2.Check(schema, value))
          throw new ValidationError2("property", schema, value);
        return exports_value2.Decode(schema, value);
      }
      if (value.indexOf(",") !== -1) {
        const newValue = value.split(",").map((v) => v.trim());
        if (compiler) {
          if (!compiler.Check(newValue))
            throw new ValidationError2("property", schema, value);
          return compiler.Decode(newValue);
        }
        if (!exports_value2.Check(schema, newValue))
          throw new ValidationError2("property", schema, newValue);
        return exports_value2.Decode(schema, newValue);
      }
      if (isProperty)
        return value;
      throw new ValidationError2("property", schema, value);
    };
    return t2.Transform(t2.Union([
      t2.String({
        format: "ArrayString",
        default: options?.default
      }),
      schema
    ])).Decode((value) => {
      if (Array.isArray(value)) {
        let values = [];
        for (let i = 0;i < value.length; i++) {
          const v = value[i];
          if (typeof v === "string") {
            const t22 = decode2(v, true);
            if (Array.isArray(t22))
              values = values.concat(t22);
            else
              values.push(t22);
            continue;
          }
          values.push(v);
        }
        return values;
      }
      if (typeof value === "string")
        return decode2(value);
      return value;
    }).Encode((value) => {
      if (typeof value === "string")
        try {
          value = JSON.parse(value);
        } catch {
          throw new ValidationError2("property", schema, value);
        }
      if (!exports_value2.Check(schema, value))
        throw new ValidationError2("property", schema, value);
      return JSON.stringify(value);
    });
  },
  File: File2,
  Files: (options = {}) => t2.Transform(Files(options)).Decode((value) => {
    if (Array.isArray(value))
      return value;
    return [value];
  }).Encode((value) => value),
  Nullable: (schema, options) => t2.Union([schema, t2.Null()], options),
  MaybeEmpty: (schema, options) => t2.Union([schema, t2.Null(), t2.Undefined()], options),
  Cookie: (properties, {
    domain,
    expires,
    httpOnly,
    maxAge,
    path,
    priority,
    sameSite,
    secure,
    secrets,
    sign,
    ...options
  } = {}) => {
    const v = t2.Object(properties, options);
    v.config = {
      domain,
      expires,
      httpOnly,
      maxAge,
      path,
      priority,
      sameSite,
      secure,
      secrets,
      sign
    };
    return v;
  },
  UnionEnum: (values, options = {}) => {
    const type = values.every((value) => typeof value === "string") ? { type: "string" } : values.every((value) => typeof value === "number") ? { type: "number" } : values.every((value) => value === null) ? { type: "null" } : {};
    if (values.some((x) => typeof x === "object" && x !== null))
      throw new Error("This type does not support objects or arrays");
    return {
      default: values[0],
      ...options,
      [Kind]: "UnionEnum",
      ...type,
      enum: values
    };
  }
};
t2.BooleanString = ElysiaType.BooleanString;
t2.ObjectString = ElysiaType.ObjectString;
t2.ArrayString = ElysiaType.ArrayString;
t2.Numeric = ElysiaType.Numeric;
t2.Integer = ElysiaType.Integer;
t2.File = (arg = {}) => ElysiaType.File({
  default: "File",
  ...arg,
  extension: arg?.type,
  type: "string",
  format: "binary"
});
t2.Files = (arg = {}) => ElysiaType.Files({
  ...arg,
  elysiaMeta: "Files",
  default: "Files",
  extension: arg?.type,
  type: "array",
  items: {
    ...arg,
    default: "Files",
    type: "string",
    format: "binary"
  }
});
t2.Nullable = (schema) => ElysiaType.Nullable(schema);
t2.MaybeEmpty = ElysiaType.MaybeEmpty;
t2.Cookie = ElysiaType.Cookie;
t2.Date = ElysiaType.Date;
t2.UnionEnum = ElysiaType.UnionEnum;
function getOrSetType(kind, func) {
  if (!exports_type2.Has(kind)) {
    exports_type2.Set(kind, func);
  }
  return (options = {}) => Unsafe({ ...options, [Kind]: kind });
}

// node_modules/elysia/dist/sucrose.mjs
var hasReturn = (fn) => {
  const fnLiteral = typeof fn === "object" ? fn.fn.toString() : typeof fn === "string" ? fn.toString() : fn;
  const parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    return true;
  }
  return fnLiteral.includes("return");
};
var separateFunction = (code) => {
  if (code.startsWith("async"))
    code = code.slice(5);
  code = code.trimStart();
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    index = code.indexOf("=>", code.indexOf(")"));
    if (index !== -1) {
      let bracketEndIndex = index;
      while (bracketEndIndex > 0)
        if (code.charCodeAt(--bracketEndIndex) === 41)
          break;
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [
        code.slice(1, bracketEndIndex),
        body,
        {
          isArrowReturn: body.charCodeAt(0) !== 123
        }
      ];
    }
  }
  if (/^(\w+)=>/g.test(code)) {
    index = code.indexOf("=>");
    if (index !== -1) {
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [
        code.slice(0, index),
        body,
        {
          isArrowReturn: body.charCodeAt(0) !== 123
        }
      ];
    }
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    const end = code.indexOf(")");
    return [
      code.slice(index + 1, end),
      code.slice(end + 2),
      {
        isArrowReturn: false
      }
    ];
  }
  const start = code.indexOf("(");
  if (start !== -1) {
    const sep = code.indexOf(`
`, 2);
    const parameter = code.slice(0, sep);
    const end = parameter.lastIndexOf(")") + 1;
    const body = code.slice(sep + 1);
    return [
      parameter.slice(start, end),
      "{" + body,
      {
        isArrowReturn: false
      }
    ];
  }
  const x = code.split(`
`, 2);
  return [x[0], x[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  const start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1;
  let deep = 1;
  for (;end < parameter.length; end++) {
    const char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  const end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1;
  let deep = 1;
  for (;start >= 0; start--) {
    const char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var removeColonAlias = (parameter) => {
  while (true) {
    const start = parameter.indexOf(":");
    if (start === -1)
      break;
    let end = parameter.indexOf(",", start);
    if (end === -1)
      end = parameter.indexOf("}", start) - 1;
    if (end === -2)
      end = parameter.length;
    parameter = parameter.slice(0, start) + parameter.slice(end);
  }
  return parameter;
};
var retrieveRootParamters = (parameter) => {
  let hasParenthesis = false;
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123) {
    hasParenthesis = true;
    parameter = parameter.slice(1, -1);
  }
  parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters = [];
  while (true) {
    let [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    parameters.push(parameter.slice(0, start - 1));
    if (parameter.charCodeAt(end) === 44)
      end++;
    parameter = parameter.slice(end);
  }
  parameter = removeColonAlias(parameter);
  if (parameter)
    parameters = parameters.concat(parameter.split(","));
  const newParameters = [];
  for (const p of parameters) {
    if (p.indexOf(",") === -1) {
      newParameters.push(p);
      continue;
    }
    for (const q of p.split(","))
      newParameters.push(q.trim());
  }
  parameters = newParameters;
  return {
    hasParenthesis,
    parameters
  };
};
var findParameterReference = (parameter, inference) => {
  const { parameters, hasParenthesis } = retrieveRootParamters(parameter);
  if (!inference.query && parameters.includes("query"))
    inference.query = true;
  if (!inference.headers && parameters.includes("headers"))
    inference.headers = true;
  if (!inference.body && parameters.includes("body"))
    inference.body = true;
  if (!inference.cookie && parameters.includes("cookie"))
    inference.cookie = true;
  if (!inference.set && parameters.includes("set"))
    inference.set = true;
  if (!inference.server && parameters.includes("server"))
    inference.server = true;
  if (!inference.request && parameters.includes("request"))
    inference.request = true;
  if (!inference.route && parameters.includes("route"))
    inference.route = true;
  if (hasParenthesis)
    return `{ ${parameters.join(", ")} }`;
  return parameters.join(", ");
};
var findEndIndex = (type, content, index) => {
  const newLineIndex = content.indexOf(type + `
`, index);
  const newTabIndex = content.indexOf(type + "\t", index);
  const commaIndex = content.indexOf(type + ",", index);
  const semicolonIndex = content.indexOf(type + ";", index);
  const emptyIndex = content.indexOf(type + " ", index);
  return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i) => i > 0).sort((a, b) => a - b)[0] || -1;
};
var findAlias = (type, body, depth = 0) => {
  if (depth > 5)
    return [];
  const aliases = [];
  let content = body;
  while (true) {
    let index = findEndIndex(" = " + type, content);
    if (index === -1)
      index = findEndIndex("=" + type, content);
    if (index === -1) {
      let lastIndex = content.indexOf(" = " + type);
      if (lastIndex === -1)
        lastIndex = content.indexOf("=" + type);
      if (lastIndex + 3 + type.length !== content.length)
        break;
      index = lastIndex;
    }
    const part = content.slice(0, index);
    const lastPart = part.lastIndexOf(" ");
    let variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
    if (variable === "}") {
      const [start, end] = bracketPairRangeReverse(part);
      aliases.push(removeColonAlias(content.slice(start, end)));
      content = content.slice(index + 3 + type.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    if (!variable.includes("("))
      aliases.push(variable);
    content = content.slice(index + 3 + type.length);
  }
  for (const alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    const deepAlias = findAlias(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  parameter = parameter.slice(2, -2);
  const hasComma = parameter.includes(",");
  if (!hasComma) {
    if (parameter.includes("..."))
      return parameter.slice(parameter.indexOf("...") + 3);
    return;
  }
  const spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  const access = (type, alias) => code.includes(alias + "." + type) || code.includes(alias + '["' + type + '"]') || code.includes(alias + "['" + type + "']");
  for (const alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      const parameters = retrieveRootParamters(alias).parameters;
      if (!inference.query && parameters.includes("query"))
        inference.query = true;
      if (!inference.headers && parameters.includes("headers"))
        inference.headers = true;
      if (!inference.body && parameters.includes("body"))
        inference.body = true;
      if (!inference.cookie && parameters.includes("cookie"))
        inference.cookie = true;
      if (!inference.set && parameters.includes("set"))
        inference.set = true;
      if (!inference.query && parameters.includes("server"))
        inference.server = true;
      if (!inference.request && parameters.includes("request"))
        inference.request = true;
      if (!inference.route && parameters.includes("route"))
        inference.route = true;
      continue;
    }
    if (!inference.query && access("query", alias))
      inference.query = true;
    if (code.includes("return " + alias) || code.includes("return " + alias + ".query"))
      inference.query = true;
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (!inference.server && access("server", alias))
      inference.server = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.server && inference.route)
      break;
  }
  return aliases;
};
var isContextPassToFunction = (context, body, inference) => {
  try {
    const captureFunction = new RegExp(`(?:\\w)\\((?:.*)?${context}`, "gs");
    captureFunction.test(body);
    const nextChar = body.charCodeAt(captureFunction.lastIndex);
    if (nextChar === 41 || nextChar === 44) {
      inference.query = true;
      inference.headers = true;
      inference.body = true;
      inference.cookie = true;
      inference.set = true;
      inference.server = true;
      inference.route = true;
      inference.request = true;
      return true;
    }
    return false;
  } catch (error3) {
    console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:");
    console.log("--- body ---");
    console.log(body);
    console.log("--- context ---");
    console.log(context);
    return true;
  }
};
var sucrose = (lifeCycle, inference = {
  query: false,
  headers: false,
  body: false,
  cookie: false,
  set: false,
  server: false,
  request: false,
  route: false
}) => {
  const events = [];
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.afterResponse?.length)
    events.push(...lifeCycle.afterResponse);
  for (const e of events) {
    if (!e)
      continue;
    const event = "fn" in e ? e.fn : e;
    if (typeof event !== "function")
      continue;
    const [parameter, body, { isArrowReturn }] = separateFunction(event.toString());
    const rootParameters = findParameterReference(parameter, inference);
    const mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      const aliases = findAlias(mainParameter, body.slice(1, -1));
      aliases.splice(0, -1, mainParameter);
      let code = body;
      if (code.charCodeAt(0) === 123 && code.charCodeAt(body.length - 1) === 125)
        code = code.slice(1, -1);
      if (!isContextPassToFunction(mainParameter, code, inference))
        inferBodyReference(code, aliases, inference);
      if (!inference.query && code.includes("return " + mainParameter + ".query"))
        inference.query = true;
    }
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.request && inference.route)
      break;
  }
  return inference;
};

// node_modules/elysia/dist/cookies.mjs
var import_cookie = __toESM(require_dist(), 1);

// node_modules/elysia/dist/deuri.mjs
var hex = [];
for (let i = 48;i < 58; i++)
  hex[i] = i - 48;
for (let i = 0;i < 6; i++)
  hex[i + 65] = hex[i + 97] = i + 10;
var calcHex = (a, b) => {
  if (a in hex && b in hex)
    return hex[a] << 4 | hex[b];
  return 255;
};
var type = [
  ...new Array(128).fill(0),
  ...new Array(16).fill(1),
  ...new Array(16).fill(2),
  ...new Array(32).fill(3),
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  7,
  7,
  10,
  9,
  9,
  9,
  11,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4
];
var next = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  0,
  24,
  36,
  48,
  60,
  72,
  84,
  96,
  0,
  12,
  12,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
var mask = type.map((val) => [
  127,
  63,
  63,
  63,
  0,
  31,
  15,
  15,
  15,
  7,
  7,
  7
][val]);
var decode2 = (url) => {
  let percentPosition = url.indexOf("%");
  if (percentPosition === -1)
    return url;
  let end = url.length - 3;
  if (percentPosition > end)
    return null;
  let decoded = "", start = 0, codepoint = 0, startOfOctets = percentPosition, state = 12, byte2;
  for (;; ) {
    byte2 = calcHex(url.charCodeAt(percentPosition + 1), url.charCodeAt(percentPosition + 2));
    state = next[state + type[byte2]];
    if (state === 0)
      return null;
    if (state === 12) {
      decoded += url.substring(start, startOfOctets);
      codepoint = codepoint << 6 | byte2 & mask[byte2];
      if (codepoint > 65535)
        decoded += String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
      else
        decoded += String.fromCharCode(codepoint);
      start = percentPosition + 3;
      percentPosition = url.indexOf("%", start);
      if (percentPosition === -1)
        return decoded + url.substring(start);
      if (percentPosition > end)
        return null;
      startOfOctets = percentPosition;
      codepoint = 0;
    } else {
      percentPosition += 3;
      if (percentPosition > end || url.charCodeAt(percentPosition) !== 37)
        return null;
      codepoint = codepoint << 6 | byte2 & mask[byte2];
    }
  }
};

// node_modules/elysia/dist/cookies.mjs
class Cookie2 {
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie(jar) {
    this.cookie = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value) {
    this.setCookie.value = value;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.setCookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.setCookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.setCookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.setCookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.setCookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.setCookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.setCookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.setCookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.setCookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.setCookie.secrets = secrets;
  }
  update(config) {
    this.setCookie = Object.assign(this.cookie, typeof config === "function" ? config(this.cookie) : config);
    return this;
  }
  set(config) {
    this.setCookie = Object.assign({
      ...this.initial,
      value: this.value
    }, typeof config === "function" ? config(this.cookie) : config);
    return this;
  }
  remove() {
    if (this.value === undefined)
      return;
    this.set({
      expires: /* @__PURE__ */ new Date(0),
      maxAge: 0,
      value: ""
    });
    return this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var createCookieJar = (set2, store, initial) => {
  if (!set2.cookie)
    set2.cookie = {};
  return new Proxy(store, {
    get(_, key) {
      if (key in store)
        return new Cookie2(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
      return new Cookie2(key, set2.cookie, Object.assign({}, initial));
    }
  });
};
var parseCookie = async (set2, cookieString, {
  secrets,
  sign,
  ...initial
} = {}) => {
  if (!cookieString)
    return createCookieJar(set2, {}, initial);
  const isStringKey = typeof secrets === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  const jar = {};
  const cookies = import_cookie.parse(cookieString);
  for (const [name, v] of Object.entries(cookies)) {
    if (v === undefined)
      continue;
    let value = decode2(v);
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        const temp = await unsignCookie(value, secrets);
        if (temp === false)
          throw new InvalidCookieSignature2(name);
        value = temp;
      } else {
        let decoded = true;
        for (let i = 0;i < secrets.length; i++) {
          const temp = await unsignCookie(value, secrets[i]);
          if (temp !== false) {
            decoded = true;
            value = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature2(name);
      }
    }
    jar[name] = {
      value
    };
  }
  return createCookieJar(set2, jar, initial);
};
var serializeCookie2 = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  const set2 = [];
  for (const [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    const value = property.value;
    if (value === undefined || value === null)
      continue;
    set2.push(import_cookie.serialize(key, typeof value === "object" ? JSON.stringify(value) : value + "", property));
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};

// node_modules/elysia/dist/adapter/web-standard/handler.mjs
var handleFile = (response, set2) => {
  const size = response.size;
  if (!set2 && size || size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416) {
    if (set2) {
      if (set2.headers instanceof Headers) {
        let setHeaders = {
          "accept-ranges": "bytes",
          "content-range": `bytes 0-${size - 1}/${size}`,
          "transfer-encoding": "chunked"
        };
        if (hasHeaderShorthand)
          setHeaders = set2.headers.toJSON();
        else {
          setHeaders = {};
          for (const [key, value] of set2.headers.entries())
            if (key in set2.headers)
              setHeaders[key] = value;
        }
        return new Response(response, {
          status: set2.status,
          headers: setHeaders
        });
      }
      if (isNotEmpty(set2.headers))
        return new Response(response, {
          status: set2.status,
          headers: Object.assign({
            "accept-ranges": "bytes",
            "content-range": `bytes 0-${size - 1}/${size}`,
            "transfer-encoding": "chunked"
          }, set2.headers)
        });
    }
    return new Response(response, {
      headers: {
        "accept-ranges": "bytes",
        "content-range": `bytes 0-${size - 1}/${size}`,
        "transfer-encoding": "chunked"
      }
    });
  }
  return new Response(response);
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i = 0;i < setCookie.length; i++) {
    const index = setCookie[i].indexOf("=");
    headers.append("set-cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
  }
  return headers;
};
var responseToSetHeaders = (response, set2) => {
  if (set2?.headers) {
    if (response) {
      if (hasHeaderShorthand)
        Object.assign(set2.headers, response.headers.toJSON());
      else
        for (const [key, value] of response.headers.entries())
          if (key in set2.headers)
            set2.headers[key] = value;
    }
    if (set2.status === 200)
      set2.status = response.status;
    if (set2.headers["content-encoding"])
      delete set2.headers["content-encoding"];
    return set2;
  }
  if (!response)
    return {
      headers: {},
      status: set2?.status ?? 200
    };
  if (hasHeaderShorthand) {
    set2 = {
      headers: response.headers.toJSON(),
      status: set2?.status ?? 200
    };
    if (set2.headers["content-encoding"])
      delete set2.headers["content-encoding"];
    return set2;
  }
  set2 = {
    headers: {},
    status: set2?.status ?? 200
  };
  for (const [key, value] of response.headers.entries()) {
    if (key === "content-encoding")
      continue;
    if (key in set2.headers)
      set2.headers[key] = value;
  }
  return set2;
};
var handleStream = async (generator, set2, request) => {
  let init = generator.next();
  if (init instanceof Promise)
    init = await init;
  if (init.done) {
    if (set2)
      return mapResponse2(init.value, set2, request);
    return mapCompactResponse2(init.value, request);
  }
  if (set2?.headers) {
    if (!set2.headers["transfer-encoding"])
      set2.headers["transfer-encoding"] = "chunked";
    if (!set2.headers["content-type"])
      set2.headers["content-type"] = "text/event-stream; charset=utf-8";
  } else {
    set2 = {
      status: 200,
      headers: {
        "content-type": "text/event-stream; charset=utf-8",
        "transfer-encoding": "chunked"
      }
    };
  }
  return new Response(new ReadableStream({
    async start(controller) {
      let end = false;
      request?.signal?.addEventListener("abort", () => {
        end = true;
        try {
          controller.close();
        } catch {}
      });
      if (init.value !== undefined && init.value !== null) {
        if (typeof init.value === "object")
          try {
            controller.enqueue(Buffer.from(JSON.stringify(init.value)));
          } catch {
            controller.enqueue(Buffer.from(init.value.toString()));
          }
        else
          controller.enqueue(Buffer.from(init.value.toString()));
      }
      for await (const chunk of generator) {
        if (end)
          break;
        if (chunk === undefined || chunk === null)
          continue;
        if (typeof chunk === "object")
          try {
            controller.enqueue(Buffer.from(JSON.stringify(chunk)));
          } catch {
            controller.enqueue(Buffer.from(chunk.toString()));
          }
        else
          controller.enqueue(Buffer.from(chunk.toString()));
        await new Promise((resolve) => setTimeout(() => resolve(), 0));
      }
      try {
        controller.close();
      } catch {}
    }
  }), set2);
};
async function* streamResponse(response) {
  const body = response.body;
  if (!body)
    return;
  const reader = body.getReader();
  const decoder = new TextDecoder;
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
      yield decoder.decode(value);
    }
  } finally {
    reader.releaseLock();
  }
}
var handleSet = (set2) => {
  if (typeof set2.status === "string")
    set2.status = StatusMap2[set2.status];
  if (set2.cookie && isNotEmpty(set2.cookie)) {
    const cookie = serializeCookie2(set2.cookie);
    if (cookie)
      set2.headers["set-cookie"] = cookie;
  }
  if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"])) {
    set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
  }
};
var mergeResponseWithSetHeaders = (response, set2) => {
  if (response.status !== set2.status && set2.status !== 200 && (response.status <= 300 || response.status > 400))
    response = new Response(response.body, {
      headers: response.headers,
      status: set2.status
    });
  let isCookieSet = false;
  if (set2.headers instanceof Headers)
    for (const key of set2.headers.keys()) {
      if (key === "set-cookie") {
        if (isCookieSet)
          continue;
        isCookieSet = true;
        for (const cookie of set2.headers.getSetCookie())
          response.headers.append("set-cookie", cookie);
      } else
        response.headers.append(key, set2.headers?.get(key) ?? "");
    }
  else
    for (const key in set2.headers)
      response.headers.append(key, set2.headers[key]);
  return response;
};
var mapResponse2 = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie) {
    handleSet(set2);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return Response.json(response, set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        set2.status = response.code;
        return mapResponse2(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        request?.signal?.addEventListener("abort", {
          handleEvent() {
            if (request?.signal && !request?.signal?.aborted)
              response.cancel();
          }
        }, {
          once: true
        });
        return new Response(response, set2);
      case undefined:
        if (!response)
          return new Response("", set2);
        return Response.json(response, set2);
      case "Response":
        response = mergeResponseWithSetHeaders(response, set2);
        if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => mapResponse2(x, set2, request));
      case "Function":
        return mapResponse2(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie2)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response) {
          response = mergeResponseWithSetHeaders(response, set2);
          if (response.headers.get("transfer-encoding") === "chunked")
            return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse) {
          set2.status = response.code;
          return mapResponse2(response.response, set2, request);
        }
        if (typeof response?.next === "function")
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse2(x, set2));
        if (typeof response?.toResponse === "function")
          return mapResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  }
  if (response instanceof Response && !response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
    return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
  if (typeof response?.next === "function" || response instanceof ReadableStream)
    return handleStream(response, set2, request);
  return mapCompactResponse2(response, request);
};
var mapEarlyResponse2 = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie) {
    handleSet(set2);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return Response.json(response, set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        set2.status = response.code;
        return mapEarlyResponse2(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        request?.signal?.addEventListener("abort", {
          handleEvent() {
            if (request?.signal && !request?.signal?.aborted)
              response.cancel();
          }
        }, {
          once: true
        });
        return new Response(response, set2);
      case undefined:
        if (!response)
          return;
        return Response.json(response, set2);
      case "Response":
        response = mergeResponseWithSetHeaders(response, set2);
        if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
        return response;
      case "Promise":
        return response.then((x) => mapEarlyResponse2(x, set2));
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapEarlyResponse2(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie2)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          response = mergeResponseWithSetHeaders(response, set2);
          if (response.headers.get("transfer-encoding") === "chunked")
            return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse) {
          set2.status = response.code;
          return mapEarlyResponse2(response.response, set2, request);
        }
        if (typeof response?.next === "function")
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Array":
      case "Object":
        return Response.json(response, set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        set2.status = response.code;
        return mapEarlyResponse2(response.response, set2, request);
      case "ReadableStream":
        request?.signal?.addEventListener("abort", {
          handleEvent() {
            if (request?.signal && !request?.signal?.aborted)
              response.cancel();
          }
        }, {
          once: true
        });
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response), responseToSetHeaders(response), request);
        return response;
      case "Promise":
        return response.then((x) => {
          const r = mapEarlyResponse2(x, set2);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapCompactResponse2(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie2)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse) {
          set2.status = response.code;
          return mapEarlyResponse2(response.response, set2, request);
        }
        if (typeof response?.next === "function")
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse2 = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Object":
    case "Array":
      return Response.json(response);
    case "ElysiaFile":
      return handleFile(response.value);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse2(response.response, {
        status: response.code,
        headers: {}
      });
    case "ReadableStream":
      request?.signal?.addEventListener("abort", {
        handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        }
      }, {
        once: true
      });
      return new Response(response, {
        headers: {
          "Content-Type": "text/event-stream; charset=utf-8"
        }
      });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "Response":
      if (response.headers.get("transfer-encoding") === "chunked")
        return handleStream(streamResponse(response), responseToSetHeaders(response), request);
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then((x) => mapCompactResponse2(x, request));
    case "Function":
      return mapCompactResponse2(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse2(x, request));
      if (response instanceof Error)
        return errorToResponse(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse2(response.response, {
          status: response.code,
          headers: {}
        });
      if (typeof response?.next === "function")
        return handleStream(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x) => mapResponse2(x, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse2(response.toResponse());
      if ("charCodeAt" in response) {
        const code = response.charCodeAt(0);
        if (code === 123 || code === 91) {
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        }
      }
      return new Response(response);
  }
};
var errorToResponse = (error3, set2) => new Response(JSON.stringify({
  name: error3?.name,
  message: error3?.message,
  cause: error3?.cause
}), {
  status: set2?.status !== 200 ? set2?.status ?? 500 : 500,
  headers: set2?.headers
});
var createStaticHandler2 = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  const response = mapResponse2(handle, {
    headers: setHeaders
  });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return response.clone.bind(response);
};

// node_modules/elysia/dist/adapter/web-standard/index.mjs
var WebStandardAdapter = {
  name: "web-standard",
  isWebStandard: true,
  handler: {
    mapResponse: mapResponse2,
    mapEarlyResponse: mapEarlyResponse2,
    mapCompactResponse: mapCompactResponse2,
    createStaticHandler: createStaticHandler2
  },
  composeHandler: {
    mapResponseContext: "c.request",
    preferWebstandardHeaders: true,
    headers: `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
`,
    parser: {
      json(isOptional) {
        if (isOptional)
          return `try{c.body=await c.request.json()}catch{}
`;
        return `c.body=await c.request.json()
`;
      },
      text() {
        return `c.body=await c.request.text()
`;
      },
      urlencoded() {
        return `c.body=parseQuery(await c.request.text())
`;
      },
      arrayBuffer() {
        return `c.body=await c.request.arrayBuffer()
`;
      },
      formData(isOptional) {
        let fnLiteral = `
c.body={}
`;
        if (isOptional)
          fnLiteral += `let form;try{form=await c.request.formData()}catch{}`;
        else
          fnLiteral += `const form=await c.request.formData()
`;
        return fnLiteral + `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`;
      }
    }
  },
  composeGeneralHandler: {
    parameters: "r",
    createContext(app) {
      let decoratorsLiteral = "";
      let fnLiteral = "";
      const defaultHeaders = app.setHeaders;
      for (const key of Object.keys(app.singleton.decorator))
        decoratorsLiteral += `,${key}: decorator['${key}']`;
      const standardHostname = app.config.handler?.standardHostname ?? true;
      const hasTrace = !!app.event.trace?.length;
      fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?', s + 1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`;
      if (hasTrace)
        fnLiteral += `const id=randomId()
`;
      fnLiteral += `const c={request:r,store,qi,path:p,url:u,redirect,error,set:{headers:`;
      fnLiteral += Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}";
      fnLiteral += `,status:200}`;
      if (app.inference.server)
        fnLiteral += `,get server(){return app.getServer()}`;
      if (hasTrace)
        fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
      fnLiteral += decoratorsLiteral;
      fnLiteral += `}
`;
      return fnLiteral;
    },
    websocket(app) {
      let fnLiteral = "";
      const wsPaths = app.router.static.ws;
      const router = app.router.http;
      router.build();
      if (Object.keys(wsPaths).length || router.root.ws || router.history.find((x) => x["0"] === "ws")) {
        fnLiteral += `if(r.method==='GET'){switch(p){`;
        for (const [path, index] of Object.entries(wsPaths)) {
          fnLiteral += `case'${path}':` + (app.config.strictPath !== true ? `case'${getLoosePath(path)}':` : "") + `if(r.headers.get('upgrade')==='websocket')return ht[${index}].composed(c)
`;
        }
        fnLiteral += `default:if(r.headers.get('upgrade')==='websocket'){const route=router.find('ws',p)
if(route){c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)}}break}}`;
      }
      return fnLiteral;
    },
    error404(hasEventHook, hasErrorHook) {
      let findDynamicRoute = `if(route===null)return `;
      if (hasErrorHook)
        findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
      else
        findDynamicRoute += hasEventHook ? `new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})` : `error404.clone()`;
      return {
        declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`,
        code: findDynamicRoute
      };
    }
  },
  composeError: {
    mapResponseContext: "",
    validationError: `return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})`,
    unknownError: `return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})`
  },
  listen() {
    return () => {
      throw new Error("WebStandard does not support listen, you might want to export default Elysia.fetch instead");
    };
  }
};

// node_modules/elysia/dist/adapter/bun/handler.mjs
var createNativeStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function" || handle instanceof Blob)
    return;
  if (typeof handle === "object" && handle?.toString() === "[object HTMLBundle]")
    return () => handle;
  const response = mapResponse2(handle, {
    headers: setHeaders
  });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length) {
    if (!response.headers.has("content-type"))
      response.headers.append("content-type", "text/plain;charset=utf-8");
    return response.clone.bind(response);
  }
};

// node_modules/elysia/dist/ws/index.mjs
var websocket = {
  open(ws) {
    ws.data.open?.(ws);
  },
  message(ws, message) {
    ws.data.message?.(ws, message);
  },
  drain(ws) {
    ws.data.drain?.(ws);
  },
  close(ws, code, reason) {
    ws.data.close?.(ws, code, reason);
  }
};

class ElysiaWS {
  constructor(raw, data, body = undefined) {
    this.raw = raw;
    this.data = data;
    this.body = body;
    this.validator = raw.data?.validator;
    this.sendText = raw.sendText.bind(raw);
    this.sendBinary = raw.sendBinary.bind(raw);
    this.close = raw.close.bind(raw);
    this.terminate = raw.terminate.bind(raw);
    this.publishText = raw.publishText.bind(raw);
    this.publishBinary = raw.publishBinary.bind(raw);
    this.subscribe = raw.subscribe.bind(raw);
    this.unsubscribe = raw.unsubscribe.bind(raw);
    this.isSubscribed = raw.isSubscribed.bind(raw);
    this.cork = raw.cork.bind(raw);
    this.remoteAddress = raw.remoteAddress;
    this.binaryType = raw.binaryType;
    this.data = raw.data;
    this.send = this.send.bind(this);
    this.ping = this.ping.bind(this);
    this.pong = this.pong.bind(this);
    this.publish = this.publish.bind(this);
  }
  get id() {
    return this.data.id;
  }
  send(data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.send(data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError2("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.send(data, compress);
  }
  ping(data) {
    if (Buffer.isBuffer(data))
      return this.raw.ping(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError2("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.ping(data);
  }
  pong(data) {
    if (Buffer.isBuffer(data))
      return this.raw.pong(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError2("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.pong(data);
  }
  publish(topic, data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.publish(topic, data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError2("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.publish(topic, data, compress);
  }
  get readyState() {
    return this.raw.readyState;
  }
}
var createWSMessageParser = (parse3) => {
  const parsers = typeof parse3 === "function" ? [parse3] : parse3;
  return async function parseMessage(ws, message) {
    if (typeof message === "string") {
      const start = message?.charCodeAt(0);
      if (start === 34 || start === 47 || start === 91 || start === 123)
        try {
          message = JSON.parse(message);
        } catch {}
      else if (isNumericString(message))
        message = +message;
      else if (message === "true")
        message = true;
      else if (message === "false")
        message = false;
      else if (message === "null")
        message = null;
    }
    if (parsers)
      for (let i = 0;i < parsers.length; i++) {
        let temp = parsers[i](ws, message);
        if (temp instanceof Promise)
          temp = await temp;
        if (temp !== undefined)
          return temp;
      }
    return message;
  };
};
var createHandleWSResponse = (validateResponse) => {
  const handleWSResponse = (ws, data) => {
    if (data instanceof Promise)
      return data.then((data2) => handleWSResponse(ws, data2));
    if (Buffer.isBuffer(data))
      return ws.send(data.toString());
    if (data === undefined)
      return;
    const send = (datum) => {
      if (validateResponse?.Check(datum) === false)
        return ws.send(new ValidationError2("message", validateResponse, datum).message);
      if (typeof datum === "object")
        return ws.send(JSON.stringify(datum));
      ws.send(datum);
    };
    if (typeof data?.next !== "function")
      return void send(data);
    const init = data.next();
    if (init instanceof Promise)
      return (async () => {
        const first = await init;
        if (validateResponse?.Check(first) === false)
          return ws.send(new ValidationError2("message", validateResponse, first).message);
        send(first.value);
        if (!first.done)
          for await (const datum of data)
            send(datum);
      })();
    send(init.value);
    if (!init.done)
      for (const datum of data)
        send(datum);
  };
  return handleWSResponse;
};

// node_modules/elysia/dist/adapter/bun/index.mjs
var BunAdapter = {
  ...WebStandardAdapter,
  name: "bun",
  handler: {
    ...WebStandardAdapter.handler,
    createNativeStaticHandler
  },
  composeHandler: {
    ...WebStandardAdapter.composeHandler,
    headers: hasHeaderShorthand ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
`
  },
  listen(app) {
    return (options, callback) => {
      if (typeof Bun === "undefined")
        throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
      app.compile();
      if (typeof options === "string") {
        if (!isNumericString(options))
          throw new Error("Port must be a numeric value");
        options = parseInt(options);
      }
      const fetch2 = app.fetch;
      const serve = typeof options === "object" ? {
        development: !isProduction,
        reusePort: true,
        ...app.config.serve || {},
        ...options || {},
        static: {
          ...app.router.static.http.static,
          ...app.config.serve?.static
        },
        websocket: {
          ...app.config.websocket || {},
          ...websocket || {}
        },
        fetch: fetch2,
        error: app.outerErrorHandler
      } : {
        development: !isProduction,
        reusePort: true,
        ...app.config.serve || {},
        static: app.router.static.http.static,
        websocket: {
          ...app.config.websocket || {},
          ...websocket || {}
        },
        port: options,
        fetch: fetch2,
        error: app.outerErrorHandler
      };
      app.server = Bun?.serve(serve);
      if (app.event.start)
        for (let i = 0;i < app.event.start.length; i++)
          app.event.start[i].fn(app);
      if (callback)
        callback(app.server);
      process.on("beforeExit", () => {
        if (app.server) {
          app.server.stop?.();
          app.server = null;
          if (app.event.stop)
            for (let i = 0;i < app.event.stop.length; i++)
              app.event.stop[i].fn(app);
        }
      });
      app.promisedModules.then(() => {
        Bun?.gc(false);
      });
    };
  },
  ws(app, path, options) {
    const { parse: parse3, body, response, ...rest } = options;
    const validateMessage = getSchemaValidator2(body, {
      modules: app.definitions.typebox,
      models: app.definitions.type,
      normalize: app.config.normalize
    });
    const validateResponse = getSchemaValidator2(response, {
      modules: app.definitions.typebox,
      models: app.definitions.type,
      normalize: app.config.normalize
    });
    app.route("$INTERNALWS", path, async (context) => {
      const server = app.getServer();
      const { set: set2, path: path2, qi, headers, query, params } = context;
      context.validator = validateResponse;
      if (options.upgrade) {
        if (typeof options.upgrade === "function") {
          const temp = options.upgrade(context);
          if (temp instanceof Promise)
            await temp;
        } else if (options.upgrade)
          Object.assign(set2.headers, options.upgrade);
      }
      if (set2.cookie && isNotEmpty(set2.cookie)) {
        const cookie = serializeCookie2(set2.cookie);
        if (cookie)
          set2.headers["set-cookie"] = cookie;
      }
      if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
        set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
      const handleResponse = createHandleWSResponse(validateResponse);
      const parseMessage = createWSMessageParser(parse3);
      let _id;
      const errorHandlers = [
        ...Array.isArray(options.error) ? options.error : [options.error],
        ...(app.event.error ?? []).map((x) => typeof x === "function" ? x : x.fn)
      ];
      const handleErrors = !errorHandlers.length ? () => {} : async (ws, error3) => {
        for (const handleError of errorHandlers) {
          let response2 = handleError(Object.assign(context, { error: error3 }));
          if (response2 instanceof Promise)
            response2 = await response2;
          await handleResponse(ws, response2);
          if (response2)
            break;
        }
      };
      if (server?.upgrade(context.request, {
        headers: isNotEmpty(set2.headers) ? set2.headers : undefined,
        data: {
          ...context,
          get id() {
            if (_id)
              return _id;
            return _id = randomId();
          },
          validator: validateResponse,
          ping(data) {
            options.ping?.(data);
          },
          pong(data) {
            options.pong?.(data);
          },
          open(ws) {
            try {
              handleResponse(ws, options.open?.(new ElysiaWS(ws, context)));
            } catch (error3) {
              handleErrors(ws, error3);
            }
          },
          message: async (ws, _message) => {
            const message = await parseMessage(ws, _message);
            if (validateMessage?.Check(message) === false)
              return void ws.send(new ValidationError2("message", validateMessage, message).message);
            try {
              handleResponse(ws, options.message?.(new ElysiaWS(ws, context, message), message));
            } catch (error3) {
              handleErrors(ws, error3);
            }
          },
          drain(ws) {
            try {
              handleResponse(ws, options.drain?.(new ElysiaWS(ws, context)));
            } catch (error3) {
              handleErrors(ws, error3);
            }
          },
          close(ws, code, reason) {
            try {
              handleResponse(ws, options.close?.(new ElysiaWS(ws, context), code, reason));
            } catch (error3) {
              handleErrors(ws, error3);
            }
          }
        }
      }))
        return;
      set2.status = 400;
      return "Expected a websocket connection";
    }, {
      ...rest,
      websocket: options
    });
  }
};

// node_modules/elysia/dist/universal/utils.mjs
var isBun2 = typeof Bun !== "undefined";

// node_modules/elysia/dist/universal/env.mjs
var env3 = isBun2 ? Bun.env : typeof process !== "undefined" && process?.env ? process.env : {};

// node_modules/elysia/dist/fast-querystring.mjs
var plusRegex = /\+/g;
function parseQueryFromURL(input) {
  const result = {};
  if (typeof input !== "string")
    return result;
  let key = "";
  let value = "";
  let startingIndex = -1;
  let equalityIndex = -1;
  let flags = 0;
  const l = input.length;
  for (let i = 0;i < l; i++) {
    switch (input.charCodeAt(i)) {
      case 38:
        const hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair)
          equalityIndex = i;
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (flags & 1)
            key = key.replace(plusRegex, " ");
          if (flags & 2)
            key = decode2(key) || key;
          if (!result[key]) {
            if (hasBothKeyValuePair) {
              value = input.slice(equalityIndex + 1, i);
              if (flags & 4)
                value = value.replace(plusRegex, " ");
              if (flags & 8)
                value = decode2(value) || value;
            }
            result[key] = value;
          }
        }
        key = "";
        value = "";
        startingIndex = i;
        equalityIndex = i;
        flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          flags |= 8;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= 4;
        else
          flags |= 1;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= 8;
        else
          flags |= 2;
        break;
    }
  }
  if (startingIndex < l) {
    const hasBothKeyValuePair = equalityIndex > startingIndex;
    key = input.slice(startingIndex + 1, hasBothKeyValuePair ? equalityIndex : l);
    if (hasBothKeyValuePair || key.length > 0) {
      if (flags & 1)
        key = key.replace(plusRegex, " ");
      if (flags & 2)
        key = decode2(key) || key;
      if (!result[key]) {
        if (hasBothKeyValuePair) {
          value = input.slice(equalityIndex + 1, l);
          if (flags & 4)
            value = value.replace(plusRegex, " ");
          if (flags & 8)
            value = decode2(value) || value;
        }
        result[key] = value;
      }
    }
  }
  return result;
}
var parseQuery = (input) => {
  const result = {};
  if (typeof input !== "string")
    return result;
  const inputLength = input.length;
  let key = "";
  let value = "";
  let startingIndex = -1;
  let equalityIndex = -1;
  let shouldDecodeKey = false;
  let shouldDecodeValue = false;
  let keyHasPlus = false;
  let valueHasPlus = false;
  let hasBothKeyValuePair = false;
  let c = 0;
  for (let i = 0;i < inputLength + 1; i++) {
    if (i !== inputLength)
      c = input.charCodeAt(i);
    else
      c = 38;
    switch (c) {
      case 38: {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair)
          equalityIndex = i;
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus)
            key = key.replace(plusRegex, " ");
          if (shouldDecodeKey)
            key = decode2(key) || key;
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus)
              value = value.replace(plusRegex, " ");
            if (shouldDecodeValue)
              value = decode2(value) || value;
          }
          const currentValue = result[key];
          if (currentValue === undefined)
            result[key] = value;
          else {
            if (currentValue.pop)
              currentValue.push(value);
            else
              result[key] = [currentValue, value];
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
        break;
      }
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          shouldDecodeValue = true;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          valueHasPlus = true;
        else
          keyHasPlus = true;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          shouldDecodeValue = true;
        else
          shouldDecodeKey = true;
        break;
    }
  }
  return result;
};

// node_modules/elysia/dist/trace.mjs
var ELYSIA_TRACE2 = Symbol("ElysiaTrace");
var createProcess = () => {
  const { promise, resolve } = Promise.withResolvers();
  const { promise: end, resolve: resolveEnd } = Promise.withResolvers();
  const { promise: error3, resolve: resolveError } = Promise.withResolvers();
  const callbacks = [];
  const callbacksEnd = [];
  return [
    (callback) => {
      if (callback)
        callbacks.push(callback);
      return promise;
    },
    (process2) => {
      const processes = [];
      const resolvers = [];
      let groupError = null;
      for (let i = 0;i < (process2.total ?? 0); i++) {
        const { promise: promise2, resolve: resolve2 } = Promise.withResolvers();
        const { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers();
        const { promise: error22, resolve: resolveError2 } = Promise.withResolvers();
        const callbacks2 = [];
        const callbacksEnd2 = [];
        processes.push((callback) => {
          if (callback)
            callbacks2.push(callback);
          return promise2;
        });
        resolvers.push((process22) => {
          const result2 = {
            ...process22,
            end: end2,
            error: error22,
            index: i,
            onStop(callback) {
              if (callback)
                callbacksEnd2.push(callback);
              return end2;
            }
          };
          resolve2(result2);
          for (let i2 = 0;i2 < callbacks2.length; i2++)
            callbacks2[i2](result2);
          return (error32 = null) => {
            const end3 = performance.now();
            if (error32)
              groupError = error32;
            const detail = {
              end: end3,
              error: error32,
              get elapsed() {
                return end3 - process22.begin;
              }
            };
            for (let i2 = 0;i2 < callbacksEnd2.length; i2++)
              callbacksEnd2[i2](detail);
            resolveEnd2(end3);
            resolveError2(error32);
          };
        });
      }
      const result = {
        ...process2,
        end,
        error: error3,
        onEvent(callback) {
          for (let i = 0;i < processes.length; i++)
            processes[i](callback);
        },
        onStop(callback) {
          if (callback)
            callbacksEnd.push(callback);
          return end;
        }
      };
      resolve(result);
      for (let i = 0;i < callbacks.length; i++)
        callbacks[i](result);
      return {
        resolveChild: resolvers,
        resolve(error22 = null) {
          const end2 = performance.now();
          if (!error22 && groupError)
            error22 = groupError;
          const detail = {
            end: end2,
            error: error22,
            get elapsed() {
              return end2 - process2.begin;
            }
          };
          for (let i = 0;i < callbacksEnd.length; i++)
            callbacksEnd[i](detail);
          resolveEnd(end2);
          resolveError(error22);
        }
      };
    }
  ];
};
var createTracer = (traceListener) => {
  return (context) => {
    const [onRequest, resolveRequest] = createProcess();
    const [onParse, resolveParse] = createProcess();
    const [onTransform, resolveTransform] = createProcess();
    const [onBeforeHandle, resolveBeforeHandle] = createProcess();
    const [onHandle, resolveHandle] = createProcess();
    const [onAfterHandle, resolveAfterHandle] = createProcess();
    const [onError, resolveError] = createProcess();
    const [onMapResponse, resolveMapResponse] = createProcess();
    const [onAfterResponse, resolveAfterResponse] = createProcess();
    traceListener({
      id: context[ELYSIA_REQUEST_ID2],
      context,
      set: context.set,
      onRequest,
      onParse,
      onTransform,
      onBeforeHandle,
      onHandle,
      onAfterHandle,
      onMapResponse,
      onAfterResponse,
      onError
    });
    return {
      request: resolveRequest,
      parse: resolveParse,
      transform: resolveTransform,
      beforeHandle: resolveBeforeHandle,
      handle: resolveHandle,
      afterHandle: resolveAfterHandle,
      error: resolveError,
      mapResponse: resolveMapResponse,
      afterResponse: resolveAfterResponse
    };
  };
};

// node_modules/elysia/dist/compose.mjs
var TypeBoxSymbol = {
  optional: Symbol.for("TypeBox.Optional"),
  kind: Symbol.for("TypeBox.Kind")
};
var isOptional = (validator) => {
  if (!validator)
    return false;
  const schema = validator?.schema;
  if (schema?.[TypeBoxSymbol.kind] === "Import")
    return validator.References().some(isOptional);
  return !!schema && TypeBoxSymbol.optional in schema;
};
var allocateIf = (value, condition) => condition ? value : "";
var defaultParsers = [
  "json",
  "text",
  "urlencoded",
  "arrayBuffer",
  "formdata",
  "application/json",
  "text/plain",
  "application/x-www-form-urlencoded",
  "application/octet-stream",
  "multipart/form-data"
];
var hasAdditionalProperties = (_schema) => {
  if (!_schema)
    return false;
  const schema = _schema?.schema ?? _schema;
  if (schema[TypeBoxSymbol.kind] === "Import" && _schema.References()) {
    return _schema.References().some(hasAdditionalProperties);
  }
  if (schema.anyOf)
    return schema.anyOf.some(hasAdditionalProperties);
  if (schema.someOf)
    return schema.someOf.some(hasAdditionalProperties);
  if (schema.allOf)
    return schema.allOf.some(hasAdditionalProperties);
  if (schema.not)
    return schema.not.some(hasAdditionalProperties);
  if (schema.type === "object") {
    const properties = schema.properties;
    if ("additionalProperties" in schema)
      return schema.additionalProperties;
    if ("patternProperties" in schema)
      return false;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (property.type === "object") {
        if (hasAdditionalProperties(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasAdditionalProperties(property.anyOf[i]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  return false;
};
var createReport = ({
  context = "c",
  trace = [],
  addFn
}) => {
  if (!trace.length)
    return () => {
      return {
        resolveChild() {
          return () => {};
        },
        resolve() {}
      };
    };
  for (let i = 0;i < trace.length; i++)
    addFn(`let report${i}, reportChild${i}, reportErr${i}, reportErrChild${i};let trace${i} = ${context}[ELYSIA_TRACE]?.[${i}] ?? trace[${i}](${context});
`);
  return (event, {
    name,
    total = 0
  } = {}) => {
    if (!name)
      name = "anonymous";
    const reporter = event === "error" ? "reportErr" : "report";
    for (let i = 0;i < trace.length; i++)
      addFn(`${reporter}${i} = trace${i}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`);
    return {
      resolve() {
        for (let i = 0;i < trace.length; i++)
          addFn(`${reporter}${i}.resolve()
`);
      },
      resolveChild(name2) {
        for (let i = 0;i < trace.length; i++)
          addFn(`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
        return (binding) => {
          for (let i = 0;i < trace.length; i++) {
            if (binding)
              addFn(`if(${binding} instanceof Error){${reporter}Child${i}?.(${binding}) }else{${reporter}Child${i}?.()}`);
            else
              addFn(`${reporter}Child${i}?.()
`);
          }
        };
      }
    };
  };
};
var composeValidationFactory = ({
  injectResponse = "",
  normalize = false,
  validator,
  encodeSchema = false
}) => ({
  composeValidation: (type2, value = `c.${type2}`) => `c.set.status=422;throw new ValidationError('${type2}',validator.${type2},${value})`,
  composeResponseValidation: (name = "r") => {
    let code = injectResponse + `
`;
    code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}const isResponse=${name} instanceof Response
switch(c.set.status){`;
    for (const [status, value] of Object.entries(validator.response)) {
      code += `
case ${status}:if(!isResponse){`;
      if (normalize && "Clean" in value && !hasAdditionalProperties(value))
        code += `${name}=validator.response['${status}'].Clean(${name})
`;
      if (encodeSchema && (value.hasTransform || typeof value.Decode === "function"))
        code += `${name}=validator.response['${status}'].Encode(${name})
`;
      code += `if(validator.response['${status}'].Check(${name})===false){c.set.status=422
throw new ValidationError('response',validator.response['${status}'],${name})}c.set.status = ${status}}
`;
      code += `break
`;
    }
    return code + "}";
  }
});
var KindSymbol = Symbol.for("TypeBox.Kind");
var hasProperty = (expectedProperty, _schema) => {
  if (!_schema)
    return;
  const schema = _schema.schema ?? _schema;
  if (schema[TypeBoxSymbol.kind] === "Import")
    return _schema.References().some((schema2) => hasProperty(expectedProperty, schema2));
  if (schema.type === "object") {
    const properties = schema.properties;
    if (!properties)
      return false;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++) {
          if (hasProperty(expectedProperty, property.anyOf[i]))
            return true;
        }
      }
    }
    return false;
  }
  return expectedProperty in schema;
};
var TransformSymbol = Symbol.for("TypeBox.Transform");
var hasTransform = (schema) => {
  if (!schema)
    return false;
  if (schema.$ref && schema.$defs && schema.$ref in schema.$defs && hasTransform(schema.$defs[schema.$ref]))
    return true;
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasTransform(schema.oneOf[i]))
        return true;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      if (hasTransform(schema.anyOf[i]))
        return true;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      if (hasTransform(schema.allOf[i]))
        return true;
  }
  if (schema.not && hasTransform(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    const properties = schema.properties;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (hasTransform(property))
        return true;
      if (property.type === "array" && property.items && hasTransform(property.items))
        return true;
    }
  }
  if (schema.type === "array" && schema.items && hasTransform(schema.items))
    return true;
  return TransformSymbol in schema;
};
var matchFnReturn = /(?:return|=>) \S+\(/g;
var isAsyncName = (v) => {
  const fn = v?.fn ?? v;
  return fn.constructor.name === "AsyncFunction";
};
var isAsync = (v) => {
  const fn = v?.fn ?? v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  const literal = fn.toString();
  if (literal.includes("=> response.clone("))
    return false;
  if (literal.includes("await"))
    return true;
  if (literal.includes("async"))
    return true;
  if (literal.includes("=>response.clone("))
    return false;
  return !!literal.match(matchFnReturn);
};
var isGenerator = (v) => {
  const fn = v?.fn ?? v;
  return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
};
var composeHandler = ({
  app,
  path,
  method,
  hooks,
  validator,
  handler,
  allowMeta = false,
  inference,
  asManifest = false
}) => {
  const adapter = app["~adapter"].composeHandler;
  const adapterHandler = app["~adapter"].handler;
  const isHandleFn = typeof handler === "function";
  if (!isHandleFn) {
    handler = adapterHandler.mapResponse(handler, {
      headers: app.setHeaders ?? {}
    });
    if (hooks.parse?.length && hooks.transform?.length && hooks.beforeHandle?.length && hooks.afterHandle?.length) {
      if (handler instanceof Response)
        return Function("a", `return function(){return a.clone()}`)(handler);
      return Function("a", "return function(){return a}")(handler);
    }
  }
  const handle = isHandleFn ? `handler(c)` : `handler`;
  const hasAfterResponse = !!hooks.afterResponse?.length;
  const hasTrace = !!hooks.trace?.length;
  let fnLiteral = "";
  inference = sucrose(Object.assign({}, hooks, {
    handler
  }), inference);
  if (adapter.declare) {
    const literal = adapter.declare(inference);
    if (literal)
      fnLiteral += literal;
  }
  if (inference.server)
    fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
  validator.createBody?.();
  validator.createQuery?.();
  validator.createHeaders?.();
  validator.createParams?.();
  validator.createCookie?.();
  validator.createResponse?.();
  const hasValidation = validator.body || validator.headers || validator.params || validator.query || validator.cookie || validator.response;
  const hasQuery = inference.query || !!validator.query;
  const requestNoBody = hooks.parse?.length === 1 && hooks.parse[0].fn === "none";
  const hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || !!hooks.parse?.length) && !requestNoBody;
  if (hasBody)
    fnLiteral += `let isParsing=false
`;
  const defaultHeaders = app.setHeaders;
  const hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length;
  const hasHeaders = inference.headers || validator.headers || adapter.preferWebstandardHeaders !== true && inference.body;
  const hasCookie = inference.cookie || !!validator.cookie;
  const cookieValidator = hasCookie ? getCookieValidator({
    modules: app.definitions.typebox,
    validator: validator.cookie,
    defaultConfig: app.config.cookie,
    dynamic: !!app.config.aot,
    config: validator.cookie?.config ?? {},
    models: app.definitions.type
  }) : undefined;
  const cookieMeta = cookieValidator?.config;
  let encodeCookie = "";
  if (cookieMeta?.sign) {
    if (!cookieMeta.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
    const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
    encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`;
    if (cookieMeta.sign === true) {
      encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
    } else
      for (const name of cookieMeta.sign)
        encodeCookie += `if(_setCookie['${name}']?.value){c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')}`;
    encodeCookie += `}
`;
  }
  const normalize = app.config.normalize;
  const encodeSchema = app.config.experimental?.encodeSchema;
  const { composeValidation, composeResponseValidation } = composeValidationFactory({
    normalize,
    validator,
    encodeSchema
  });
  if (hasHeaders)
    fnLiteral += adapter.headers;
  if (hasTrace)
    fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
  const report = createReport({
    trace: hooks.trace,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  fnLiteral += "try{";
  if (hasCookie) {
    const get = (name, defaultValue) => {
      const value = cookieMeta?.[name] ?? defaultValue;
      if (!value)
        return typeof defaultValue === "string" ? `${name}:"${defaultValue}",` : `${name}:${defaultValue},`;
      if (typeof value === "string")
        return `${name}:'${value}',`;
      if (value instanceof Date)
        return `${name}: new Date(${value.getTime()}),`;
      return `${name}:${value},`;
    };
    const options = cookieMeta ? `{secrets:${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` + get("domain") + get("expires") + get("httpOnly") + get("maxAge") + get("path", "/") + get("priority") + get("sameSite") + get("secure") + "}" : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
    else
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
  }
  if (hasQuery) {
    const destructured = [];
    if (validator.query && validator.query.schema.type === "object") {
      const properties = validator.query.schema.properties;
      if (!hasAdditionalProperties(validator.query))
        for (let [key, _value] of Object.entries(properties)) {
          let value = _value;
          const isArray = value.type === "array" || !!value.anyOf?.some((v) => v.type === "string" && v.format === "ArrayString");
          if (value && TypeBoxSymbol.optional in value && value.type === "array" && value.items)
            value = value.items;
          const { type: type2, anyOf } = value;
          destructured.push({
            key,
            isArray,
            isNestedObjectArray: isArray && value.items?.type === "object" || !!value.items?.anyOf?.some((x) => x.type === "object" || x.type === "array"),
            isObject: type2 === "object" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString"),
            anyOf: !!anyOf
          });
        }
    }
    if (!destructured.length) {
      fnLiteral += "if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url.slice(c.qi + 1))}";
    } else {
      fnLiteral += `if(c.qi!==-1){let url='&'+c.url.slice(c.qi + 1)
`;
      let index = 0;
      for (const {
        key,
        isArray,
        isObject: isObject2,
        isNestedObjectArray,
        anyOf
      } of destructured) {
        const init2 = (index === 0 ? "let " : "") + `memory=url.indexOf('&${key}=')
let a${index}
`;
        if (isArray) {
          fnLiteral += init2;
          if (isNestedObjectArray)
            fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)
a${index}=''
else
a${index}+=','
let temp
if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else temp=decodeURIComponent(url.slice(start, memory).replace(/\\+/g,' '))
const charCode=temp.charCodeAt(0)
if(charCode!==91&&charCode !== 123)
temp='"'+temp+'"'
a${index}+=temp
if(memory===-1)break
memory=url.indexOf('&${key}=',memory)
if(memory===-1)break}try{if(a${index}.charCodeAt(0)===91)a${index} = JSON.parse(a${index})
else
a${index}=JSON.parse('['+a${index}+']')}catch{}
`;
          else
            fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)a${index}=[]
if(memory===-1){const temp=decodeURIComponent(url.slice(start)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(decodeURIComponent(url.slice(start)).replace(/\\+/g,' '))}
break}else{const temp=decodeURIComponent(url.slice(start, memory)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(temp)}
}memory=url.indexOf('&${key}=',memory)
if(memory===-1) break
}`;
        } else if (isObject2)
          fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))else a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))if(a${index}!==undefined)try{a${index}=JSON.parse(a${index})}catch{}}`;
        else {
          fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else{a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))`;
          if (anyOf)
            fnLiteral += `
let deepMemory=url.indexOf('&${key}=',memory)
if(deepMemory!==-1){a${index}=[a${index}]
let first=true
while(true){const start=deepMemory+${key.length + 2}
if(first)first=false
else deepMemory = url.indexOf('&', start)
let value
if(deepMemory===-1)value=url.slice(start).replace(/\\+/g,' ')
else value=url.slice(start, deepMemory).replace(/\\+/g,' ')
value=decodeURIComponent(value)
if(value===null){if(deepMemory===-1){break}else{continue}}
const vStart=value.charCodeAt(0)
const vEnd=value.charCodeAt(value.length - 1)
if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))
try{a${index}.push(JSON.parse(value))}catch{a${index}.push(value)}if(deepMemory===-1)break}}`;
          fnLiteral += "}}";
        }
        index++;
        fnLiteral += `
`;
      }
      fnLiteral += `c.query={` + destructured.map(({ key }, index2) => `'${key}':a${index2}`).join(",") + `}`;
      fnLiteral += `} else c.query = {}
`;
    }
  }
  const isAsyncHandler = typeof handler === "function" && isAsync(handler);
  const saveResponse = hasTrace || hooks.afterResponse?.length ? "c.response= " : "";
  const maybeAsync = hasCookie || hasBody || isAsyncHandler || !!hooks.parse?.length || !!hooks.afterHandle?.some(isAsync) || !!hooks.beforeHandle?.some(isAsync) || !!hooks.transform?.some(isAsync) || !!hooks.mapResponse?.some(isAsync);
  const maybeStream = (typeof handler === "function" ? isGenerator(handler) : false) || !!hooks.beforeHandle?.some(isGenerator) || !!hooks.afterHandle?.some(isGenerator) || !!hooks.transform?.some(isGenerator);
  const hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || validator.response || isHandleFn && hasDefaultHeaders || maybeStream;
  const mapResponseContext = adapter.mapResponseContext ? `,${adapter.mapResponseContext}` : "";
  if (hasTrace || inference.route)
    fnLiteral += `c.route=\`${path}\`
`;
  const parseReporter = report("parse", {
    total: hooks.parse?.length
  });
  if (hasBody) {
    const isOptionalBody = isOptional(validator.body);
    const hasBodyInference = !!hooks.parse?.length || inference.body || validator.body;
    if (adapter.parser.declare)
      fnLiteral += adapter.parser.declare;
    fnLiteral += `
isParsing=true
`;
    const parser = typeof hooks.parse === "string" ? hooks.parse : Array.isArray(hooks.parse) && hooks.parse.length === 1 ? typeof hooks.parse[0] === "string" ? hooks.parse[0] : typeof hooks.parse[0].fn === "string" ? hooks.parse[0].fn : undefined : undefined;
    if (parser && defaultParsers.includes(parser)) {
      const reporter = report("parse", {
        total: hooks.parse?.length
      });
      switch (parser) {
        case "json":
        case "application/json":
          fnLiteral += adapter.parser.json(isOptionalBody);
          break;
        case "text":
        case "text/plain":
          fnLiteral += adapter.parser.text(isOptionalBody);
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += adapter.parser.urlencoded(isOptionalBody);
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += adapter.parser.formData(isOptionalBody);
          break;
        default:
          if (parser[0] in app["~parser"]) {
            fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
            fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`;
            fnLiteral += `let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`;
          }
          break;
      }
      reporter.resolve();
    } else if (hasBodyInference) {
      fnLiteral += `
`;
      fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
      fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`;
      if (hooks.parse?.length)
        fnLiteral += `let used=false
`;
      const reporter = report("parse", {
        total: hooks.parse?.length
      });
      let hasDefaultParser = false;
      if (hooks.parse)
        for (let i = 0;i < hooks.parse.length; i++) {
          const name = `bo${i}`;
          if (i !== 0)
            fnLiteral += `
if(!used){`;
          if (typeof hooks.parse[i].fn === "string") {
            const endUnit = reporter.resolveChild(hooks.parse[i].fn);
            switch (hooks.parse[i].fn) {
              case "json":
              case "application/json":
                hasDefaultParser = true;
                fnLiteral += adapter.parser.json(isOptionalBody);
                break;
              case "text":
              case "text/plain":
                hasDefaultParser = true;
                fnLiteral += adapter.parser.text(isOptionalBody);
                break;
              case "urlencoded":
              case "application/x-www-form-urlencoded":
                hasDefaultParser = true;
                fnLiteral += adapter.parser.urlencoded(isOptionalBody);
                break;
              case "arrayBuffer":
              case "application/octet-stream":
                hasDefaultParser = true;
                fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
                break;
              case "formdata":
              case "multipart/form-data":
                hasDefaultParser = true;
                fnLiteral += adapter.parser.formData(isOptionalBody);
                break;
              default:
                fnLiteral += `${name}=parser['${hooks.parse[i].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}
`;
            }
            endUnit();
          } else {
            const endUnit = reporter.resolveChild(hooks.parse[i].fn.name);
            fnLiteral += `let ${name}=e.parse[${i}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`;
            endUnit();
          }
          if (i !== 0)
            fnLiteral += `}`;
          if (hasDefaultParser)
            break;
        }
      reporter.resolve();
      if (!hasDefaultParser) {
        if (hooks.parse?.length)
          fnLiteral += `
if(!used){
if(!contentType) throw new ParseError()
`;
        fnLiteral += `switch(contentType){`;
        fnLiteral += `case 'application/json':
` + adapter.parser.json(isOptionalBody) + `break
case 'text/plain':` + adapter.parser.text(isOptionalBody) + `break
case 'application/x-www-form-urlencoded':` + adapter.parser.urlencoded(isOptionalBody) + `break
case 'application/octet-stream':` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 'multipart/form-data':` + adapter.parser.formData(isOptionalBody) + `break
`;
        for (const key of Object.keys(app["~parser"]))
          fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse)throw result
if(bo${key}!==undefined)c.body=bo${key}
break
`;
        if (hooks.parse?.length)
          fnLiteral += "}";
        fnLiteral += "}";
      }
    }
    fnLiteral += `
delete c.contentType`;
    fnLiteral += `
isParsing=false
`;
  }
  parseReporter.resolve();
  if (hooks?.transform) {
    const reporter = report("transform", {
      total: hooks.transform.length
    });
    if (hooks.transform.length)
      fnLiteral += `let transformed
`;
    for (let i = 0;i < hooks.transform.length; i++) {
      const transform2 = hooks.transform[i];
      const endUnit = reporter.resolveChild(transform2.fn.name);
      fnLiteral += isAsync(transform2) ? `transformed=await e.transform[${i}](c)
` : `transformed=e.transform[${i}](c)
`;
      if (transform2.subType === "mapDerive")
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
      else
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else Object.assign(c,transformed)
`;
      endUnit();
    }
    reporter.resolve();
  }
  if (validator) {
    if (validator.headers) {
      if (normalize && "Clean" in validator.headers && !hasAdditionalProperties(validator.headers))
        fnLiteral += `c.headers=validator.headers.Clean(c.headers);
`;
      if (hasProperty("default", validator.headers))
        for (const [key, value] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.headers['${key}']??=${parsed}
`;
        }
      if (isOptional(validator.headers))
        fnLiteral += `if(isNotEmpty(c.headers)){`;
      fnLiteral += `if(validator.headers.Check(c.headers) === false){` + composeValidation("headers") + "}";
      if (hasTransform(validator.headers.schema))
        fnLiteral += `c.headers=validator.headers.Decode(c.headers)
`;
      if (isOptional(validator.headers))
        fnLiteral += "}";
    }
    if (validator.params) {
      if (hasProperty("default", validator.params))
        for (const [key, value] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.params['${key}']??=${parsed}
`;
        }
      fnLiteral += `if(validator.params.Check(c.params)===false){` + composeValidation("params") + "}";
      if (hasTransform(validator.params.schema))
        fnLiteral += `c.params=validator.params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (normalize && "Clean" in validator.query && !hasAdditionalProperties(validator.query))
        fnLiteral += `c.query=validator.query.Clean(c.query)
`;
      if (hasProperty("default", validator.query))
        for (const [key, value] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
        }
      if (isOptional(validator.query))
        fnLiteral += `if(isNotEmpty(c.query)){`;
      fnLiteral += `if(validator.query.Check(c.query)===false){` + composeValidation("query") + `}`;
      if (hasTransform(validator.query.schema))
        fnLiteral += `c.query=validator.query.Decode(Object.assign({},c.query))
`;
      if (isOptional(validator.query))
        fnLiteral += `}`;
    }
    if (validator.body) {
      if (normalize && "Clean" in validator.body && !hasAdditionalProperties(validator.body))
        fnLiteral += `c.body=validator.body.Clean(c.body)
`;
      const doesHaveTransform = hasTransform(validator.body.schema);
      if (doesHaveTransform || isOptional(validator.body))
        fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&isNotEmpty(c.body))
`;
      if (hasProperty("default", validator.body)) {
        const schema = validator.body.schema;
        const value = exports_value2.Default(schema, schema.type === "object" || schema[TypeBoxSymbol.kind] === "Import" && schema.$defs[schema.$ref][TypeBoxSymbol.kind] === "Object" ? {} : undefined);
        const parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
        fnLiteral += `if(validator.body.Check(c.body)===false){`;
        if (value !== undefined && value !== null)
          fnLiteral += `if(typeof c.body==='object')c.body=Object.assign(${parsed},c.body)
else c.body=${parsed}
`;
        if (isOptional(validator.body))
          fnLiteral += `if(isNotEmptyObject&&validator.body.Check(c.body)===false){` + composeValidation("body") + "}";
        else
          fnLiteral += `if(validator.body.Check(c.body)===false){` + composeValidation("body") + `}`;
        fnLiteral += "}";
      } else {
        if (isOptional(validator.body))
          fnLiteral += `if(isNotEmptyObject&&validator.body.Check(c.body)===false){` + composeValidation("body") + "}";
        else
          fnLiteral += `if(validator.body.Check(c.body)===false){` + composeValidation("body") + "}";
      }
      if (doesHaveTransform)
        fnLiteral += `if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`;
    }
    if (cookieValidator && isNotEmpty(cookieValidator?.schema?.properties ?? cookieValidator?.schema?.schema ?? {})) {
      fnLiteral += `const cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`;
      if (hasProperty("default", cookieValidator))
        for (const [key, value] of Object.entries(exports_value2.Default(cookieValidator.schema, {}))) {
          fnLiteral += `cookieValue['${key}'] = ${typeof value === "object" ? JSON.stringify(value) : value}
`;
        }
      if (isOptional(validator.cookie))
        fnLiteral += `if(isNotEmpty(c.cookie)){`;
      fnLiteral += `if(validator.cookie.Check(cookieValue)===false){` + composeValidation("cookie", "cookieValue") + "}";
      if (hasTransform(validator.cookie.schema))
        fnLiteral += `for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))c.cookie[key].value=value
`;
      if (isOptional(validator.cookie))
        fnLiteral += `}`;
    }
  }
  if (hooks?.beforeHandle) {
    const reporter = report("beforeHandle", {
      total: hooks.beforeHandle.length
    });
    let hasResolve = false;
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      const beforeHandle = hooks.beforeHandle[i];
      const endUnit = reporter.resolveChild(beforeHandle.fn.name);
      const returning = hasReturn(beforeHandle);
      const isResolver = beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve";
      if (isResolver) {
        if (!hasResolve) {
          hasResolve = true;
          fnLiteral += `
let resolved
`;
        }
        fnLiteral += isAsync(beforeHandle) ? `resolved=await e.beforeHandle[${i}](c);
` : `resolved=e.beforeHandle[${i}](c);
`;
        if (beforeHandle.subType === "mapResolve")
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else{resolved.request = c.request
resolved.store = c.store
resolved.qi = c.qi
resolved.path = c.path
resolved.url = c.url
resolved.redirect = c.redirect
resolved.set = c.set
resolved.error = c.error
c = resolved}`;
        else
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else Object.assign(c, resolved)
`;
      } else if (!returning) {
        fnLiteral += isAsync(beforeHandle) ? `await e.beforeHandle[${i}](c)
` : `e.beforeHandle[${i}](c)
`;
        endUnit();
      } else {
        fnLiteral += isAsync(beforeHandle) ? `be=await e.beforeHandle[${i}](c)
` : `be=e.beforeHandle[${i}](c)
`;
        endUnit("be");
        fnLiteral += `if(be!==undefined){`;
        reporter.resolve();
        if (hooks.afterHandle?.length) {
          report("handle", {
            name: isHandleFn ? handler.name : undefined
          }).resolve();
          const reporter2 = report("afterHandle", {
            total: hooks.afterHandle.length
          });
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            const hook = hooks.afterHandle[i2];
            const returning2 = hasReturn(hook);
            const endUnit2 = reporter2.resolveChild(hook.fn.name);
            fnLiteral += `c.response = be
`;
            if (!returning2) {
              fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i2}](c, be)
` : `e.afterHandle[${i2}](c, be)
`;
            } else {
              fnLiteral += isAsync(hook.fn) ? `af = await e.afterHandle[${i2}](c)
` : `af = e.afterHandle[${i2}](c)
`;
              fnLiteral += `if(af!==undefined) c.response=be=af
`;
            }
            endUnit2("af");
          }
          reporter2.resolve();
        }
        if (validator.response)
          fnLiteral += composeResponseValidation("be");
        const mapResponseReporter = report("mapResponse", {
          total: hooks.mapResponse?.length
        });
        if (hooks.mapResponse?.length) {
          fnLiteral += `c.response=be
`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            const mapResponse3 = hooks.mapResponse[i2];
            const endUnit2 = mapResponseReporter.resolveChild(mapResponse3.fn.name);
            fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)be=c.response=mr}`;
            endUnit2();
          }
        }
        mapResponseReporter.resolve();
        fnLiteral += encodeCookie;
        fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`;
      }
    }
    reporter.resolve();
  }
  if (hooks.afterHandle?.length) {
    const handleReporter = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r=c.response=await ${handle}
` : `let r=c.response=${handle}
`;
    else
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
    handleReporter.resolve();
    const reporter = report("afterHandle", {
      total: hooks.afterHandle.length
    });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      const hook = hooks.afterHandle[i];
      const returning = hasReturn(hook);
      const endUnit = reporter.resolveChild(hook.fn.name);
      if (!returning) {
        fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i}](c)
` : `e.afterHandle[${i}](c)
`;
        endUnit();
      } else {
        fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i}](c)
` : `af=e.afterHandle[${i}](c)
`;
        endUnit("af");
        if (validator.response) {
          fnLiteral += `if(af!==undefined){`;
          reporter.resolve();
          fnLiteral += composeResponseValidation("af");
          fnLiteral += `c.response=af}`;
        } else {
          fnLiteral += `if(af!==undefined){`;
          reporter.resolve();
          fnLiteral += `c.response=af}`;
        }
      }
    }
    reporter.resolve();
    fnLiteral += `r=c.response
`;
    if (validator.response)
      fnLiteral += composeResponseValidation();
    fnLiteral += encodeCookie;
    const mapResponseReporter = report("mapResponse", {
      total: hooks.mapResponse?.length
    });
    if (hooks.mapResponse?.length) {
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        const mapResponse3 = hooks.mapResponse[i];
        const endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
        fnLiteral += `mr=${isAsyncName(mapResponse3) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr
`;
        endUnit();
      }
    }
    mapResponseReporter.resolve();
    if (hasSet)
      fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
    else
      fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
  } else {
    const handleReporter = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (validator.response || hooks.mapResponse?.length) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
      handleReporter.resolve();
      if (validator.response)
        fnLiteral += composeResponseValidation();
      report("afterHandle").resolve();
      const mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse?.length
      });
      if (hooks.mapResponse?.length) {
        fnLiteral += `
c.response=r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          const mapResponse3 = hooks.mapResponse[i];
          const endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
          fnLiteral += `
if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}
`;
          endUnit();
        }
      }
      mapResponseReporter.resolve();
      fnLiteral += encodeCookie;
      if (handler instanceof Response) {
        fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})else return ${handle}.clone()` : `return ${handle}.clone()`;
        fnLiteral += `
`;
      } else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
      handleReporter.resolve();
      report("afterHandle").resolve();
      const mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse?.length
      });
      if (hooks.mapResponse?.length) {
        fnLiteral += `c.response= r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          const mapResponse3 = hooks.mapResponse[i];
          const endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
          fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}`;
          endUnit();
        }
      }
      mapResponseReporter.resolve();
      fnLiteral += encodeCookie;
      if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
    } else {
      handleReporter.resolve();
      const handled = isAsyncHandler ? `await ${handle}` : handle;
      report("afterHandle").resolve();
      if (handler instanceof Response) {
        fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
` : `return ${handle}.clone()
`;
      } else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse}${handled},c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}${handled}${mapResponseContext})
`;
    }
  }
  fnLiteral += `
}catch(error){`;
  if (hasBody)
    fnLiteral += `if(isParsing)error=new ParseError()
`;
  if (!maybeAsync)
    fnLiteral += `return(async()=>{`;
  fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`;
  if (hasTrace && hooks.trace)
    for (let i = 0;i < hooks.trace.length; i++)
      fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)
`;
  const errorReporter = report("error", {
    total: hooks.error?.length
  });
  if (hooks.error?.length) {
    fnLiteral += `c.error=error
`;
    if (hasValidation)
      fnLiteral += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}`;
    else
      fnLiteral += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`;
    fnLiteral += `let er
`;
    for (let i = 0;i < hooks.error.length; i++) {
      const endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
      if (isAsync(hooks.error[i]))
        fnLiteral += `er=await e.error[${i}](c)
`;
      else
        fnLiteral += `er=e.error[${i}](c)
if(er instanceof Promise)er=await er
`;
      endUnit();
      const mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse?.length
      });
      if (hooks.mapResponse?.length) {
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          const mapResponse3 = hooks.mapResponse[i2];
          const endUnit2 = mapResponseReporter.resolveChild(mapResponse3.fn.name);
          fnLiteral += `c.response=er
er=e.mapResponse[${i2}](c)
if(er instanceof Promise)er=await er
`;
          endUnit2();
        }
      }
      mapResponseReporter.resolve();
      fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`;
      fnLiteral += `if(er){`;
      if (hasTrace && hooks.trace) {
        for (let i2 = 0;i2 < hooks.trace.length; i2++)
          fnLiteral += `report${i2}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += `return er}`;
    }
  }
  errorReporter.resolve();
  fnLiteral += `return handleError(c,error,true)`;
  if (!maybeAsync)
    fnLiteral += "})()";
  fnLiteral += "}";
  if (hasAfterResponse || hasTrace) {
    fnLiteral += `finally{ `;
    if (!maybeAsync)
      fnLiteral += ";(async()=>{";
    const reporter = report("afterResponse", {
      total: hooks.afterResponse?.length
    });
    if (hasAfterResponse && hooks.afterResponse) {
      for (let i = 0;i < hooks.afterResponse.length; i++) {
        const endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name);
        fnLiteral += `
await e.afterResponse[${i}](c)
`;
        endUnit();
      }
    }
    reporter.resolve();
    if (!maybeAsync)
      fnLiteral += "})()";
    fnLiteral += `}`;
  }
  const adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  let init = `const {handler,handleError,hooks:e, ` + allocateIf(`validator,`, hasValidation) + `mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{` + allocateIf(`parseQuery,`, hasBody) + allocateIf(`parseQueryFromURL,`, hasQuery) + `},error:{` + allocateIf(`ValidationError,`, hasValidation) + `InternalServerError,` + allocateIf(`ParseError`, hasBody) + `},schema,definitions,ERROR_CODE,` + allocateIf(`parseCookie,`, hasCookie) + allocateIf(`signCookie,`, hasCookie) + allocateIf(`decodeURIComponent,`, hasQuery) + `ElysiaCustomStatusResponse,` + allocateIf(`ELYSIA_TRACE,`, hasTrace) + allocateIf(`ELYSIA_REQUEST_ID,`, hasTrace) + allocateIf("parser,", hooks.parse?.length) + allocateIf(`getServer,`, inference.server) + adapterVariables + allocateIf("TypeBoxError", hasValidation) + `}=hooks
const trace=e.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
return ${maybeAsync ? "async " : ""}function handle(c){`;
  if (hooks.beforeHandle?.length)
    init += `let be
`;
  if (hooks.afterHandle?.length)
    init += `let af
`;
  if (hooks.mapResponse?.length)
    init += `let mr
`;
  if (allowMeta)
    init += `c.schema = schema
c.defs = definitions
`;
  init += fnLiteral + "}";
  try {
    if (asManifest)
      return Function("hooks", init);
    return Function("hooks", init)({
      handler,
      hooks: lifeCycleToFn(hooks),
      validator: hasValidation ? validator : undefined,
      handleError: app.handleError,
      mapResponse: adapterHandler.mapResponse,
      mapCompactResponse: adapterHandler.mapCompactResponse,
      mapEarlyResponse: adapterHandler.mapEarlyResponse,
      isNotEmpty,
      utils: {
        parseQuery: hasBody ? parseQuery : undefined,
        parseQueryFromURL: hasQuery ? parseQueryFromURL : undefined
      },
      error: {
        ValidationError: hasValidation ? ValidationError2 : undefined,
        InternalServerError: InternalServerError2,
        ParseError: hasBody ? ParseError3 : undefined
      },
      schema: app.router.history,
      definitions: app.definitions.type,
      ERROR_CODE: ERROR_CODE2,
      parseCookie: hasCookie ? parseCookie : undefined,
      signCookie: hasCookie ? signCookie : undefined,
      decodeURIComponent: hasQuery ? decode2 : undefined,
      ElysiaCustomStatusResponse,
      ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE2 : undefined,
      ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID2 : undefined,
      getServer: () => app.getServer(),
      TypeBoxError: hasValidation ? TypeBoxError : undefined,
      parser: app["~parser"],
      ...adapter.inject
    });
  } catch (error22) {
    const debugHooks = lifeCycleToFn(hooks);
    console.log("[Composer] failed to generate optimized handler");
    console.log("---");
    console.log({
      handler: typeof handler === "function" ? handler.toString() : handler,
      instruction: init,
      hooks: {
        ...debugHooks,
        transform: debugHooks?.transform?.map?.((x) => x.toString()),
        resolve: debugHooks?.resolve?.map?.((x) => x.toString()),
        beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()),
        afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()),
        mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()),
        parse: debugHooks?.parse?.map?.((x) => x.toString()),
        error: debugHooks?.error?.map?.((x) => x.toString()),
        afterResponse: debugHooks?.afterResponse?.map?.((x) => x.toString()),
        stop: debugHooks?.stop?.map?.((x) => x.toString())
      },
      validator,
      definitions: app.definitions.type,
      error: error22,
      fnLiteral
    });
    console.log("---");
    process.exit(1);
  }
};
var composeGeneralHandler = (app, { asManifest = false } = {}) => {
  const adapter = app["~adapter"].composeGeneralHandler;
  app.router.http.build();
  const error404 = adapter.error404(!!app.event.request?.length, !!app.event.error?.length);
  const hasTrace = app.event.trace?.length;
  let fnLiteral = "";
  const router = app.router;
  let findDynamicRoute = `const route=router.find(r.method,p)`;
  findDynamicRoute += router.http.root.ALL ? `??router.find("ALL",p)
` : `
`;
  findDynamicRoute += error404.code;
  findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)
`;
  let switchMap = ``;
  for (const [path, v] of Object.entries(router.static.http.map)) {
    switchMap += `case'${path}':`;
    if (app.config.strictPath !== true)
      switchMap += `case'${getLoosePath(path)}':`;
    const encoded = encodePath(path);
    if (path !== encoded)
      switchMap += `case'${encoded}':`;
    switchMap += `switch(r.method){${v.code}
` + (v.all ?? `default: break map`) + "}";
  }
  const maybeAsync = !!app.event.request?.some(isAsync);
  const adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  fnLiteral += `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,error,redirect,` + allocateIf(`ELYSIA_TRACE,`, hasTrace) + allocateIf(`ELYSIA_REQUEST_ID,`, hasTrace) + adapterVariables + `}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`;
  if (app.event.request?.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  fnLiteral += error404.declare;
  if (app.event.trace?.length)
    fnLiteral += `const ` + app.event.trace.map((_, i) => `tr${i}=app.event.trace[${i}].fn`).join(",") + `
`;
  fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`;
  if (app.event.request?.length)
    fnLiteral += `let re
`;
  fnLiteral += adapter.createContext(app);
  if (app.event.trace?.length)
    fnLiteral += `c[ELYSIA_TRACE]=[` + app.event.trace.map((_, i) => `tr${i}(c)`).join(",") + `]
`;
  const report = createReport({
    trace: app.event.trace,
    addFn(word) {
      fnLiteral += word;
    }
  });
  const reporter = report("request", {
    total: app.event.request?.length
  });
  if (app.event.request?.length) {
    fnLiteral += `try{`;
    for (let i = 0;i < app.event.request.length; i++) {
      const hook = app.event.request[i];
      const withReturn = hasReturn(hook);
      const maybeAsync2 = isAsync(hook);
      const endUnit = reporter.resolveChild(app.event.request[i].fn.name);
      if (withReturn) {
        fnLiteral += `re=mapEarlyResponse(${maybeAsync2 ? "await " : ""}onRequest[${i}](c),c.set)
`;
        endUnit("re");
        fnLiteral += `if(re!==undefined)return re
`;
      } else {
        fnLiteral += `${maybeAsync2 ? "await " : ""}onRequest[${i}](c)
`;
        endUnit();
      }
    }
    fnLiteral += `}catch(error){return app.handleError(c,error,false)}`;
  }
  reporter.resolve();
  fnLiteral += adapter.websocket(app);
  fnLiteral += `
map:switch(p){
` + switchMap + `default:break}` + findDynamicRoute + `}
`;
  if (app.extender.higherOrderFunctions.length) {
    let handler = "map";
    for (let i = 0;i < app.extender.higherOrderFunctions.length; i++)
      handler = `hoc[${i}](${handler},${adapter.parameters})`;
    fnLiteral += `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
  } else
    fnLiteral += `return map`;
  const handleError = composeErrorHandler(app);
  app.handleError = handleError;
  return Function("data", fnLiteral)({
    app,
    mapEarlyResponse: app["~adapter"]["handler"].mapEarlyResponse,
    NotFoundError: NotFoundError2,
    randomId,
    handleError,
    error: error2,
    redirect: redirect2,
    ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE2 : undefined,
    ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID2 : undefined,
    ...adapter.inject
  });
};
var composeErrorHandler = (app) => {
  const hooks = app.event;
  let fnLiteral = "";
  const adapter = app["~adapter"].composeError;
  const adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  const hasTrace = !!app.event.trace?.length;
  fnLiteral += `const {app:{event:{error:onErrorContainer,afterResponse:resContainer,mapResponse:_onMapResponse,trace:_trace}},mapResponse,ERROR_CODE,ElysiaCustomStatusResponse,` + allocateIf(`ELYSIA_TRACE,`, hasTrace) + allocateIf(`ELYSIA_REQUEST_ID,`, hasTrace) + adapterVariables + `}=inject
`;
  fnLiteral += `const trace=_trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const onMapResponse=[]
if(_onMapResponse)for(let i=0;i<_onMapResponse.length;i++)onMapResponse.push(_onMapResponse[i].fn??_onMapResponse[i])
delete _onMapResponse
const onError=onErrorContainer?.map(x=>x.fn)??[]
const res=resContainer?.map(x=>x.fn)??[]
return ${app.event.error?.find(isAsync) || app.event.mapResponse?.find(isAsync) ? "async " : ""}function(context,error,skipGlobal){`;
  fnLiteral += "";
  if (hasTrace)
    fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
  const report = createReport({
    context: "context",
    trace: hooks.trace,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`;
  if (adapter.declare)
    fnLiteral += adapter.declare;
  const saveResponse = hasTrace || !!hooks.afterResponse?.length || !!hooks.afterResponse?.length ? "context.response = " : "";
  if (app.event.error)
    for (let i = 0;i < app.event.error.length; i++) {
      const handler = app.event.error[i];
      const response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)
`;
      fnLiteral += "if(skipGlobal!==true){";
      if (hasReturn(handler)) {
        fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response)return mapResponse(_r,set${adapter.mapResponseContext})
if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
        const mapResponseReporter2 = report("mapResponse", {
          total: hooks.mapResponse?.length,
          name: "context"
        });
        if (hooks.mapResponse?.length) {
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            const mapResponse3 = hooks.mapResponse[i2];
            const endUnit = mapResponseReporter2.resolveChild(mapResponse3.fn.name);
            fnLiteral += `context.response=_r_r=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i2}](context)
`;
            endUnit();
          }
        }
        mapResponseReporter2.resolve();
        fnLiteral += `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`;
      } else
        fnLiteral += response;
      fnLiteral += "}";
    }
  fnLiteral += `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){if(error.error)error=error.error
set.status=error.status??422
` + adapter.validationError + `}`;
  fnLiteral += `if(error instanceof Error){` + adapter.unknownError + `}`;
  const mapResponseReporter = report("mapResponse", {
    total: hooks.mapResponse?.length,
    name: "context"
  });
  fnLiteral += `
if(!context.response)context.response=error.message??error
`;
  if (hooks.mapResponse?.length) {
    fnLiteral += `let mr
`;
    for (let i = 0;i < hooks.mapResponse.length; i++) {
      const mapResponse3 = hooks.mapResponse[i];
      const endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
      fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i}](context)
if(mr!==undefined)error=context.response=mr}`;
      endUnit();
    }
  }
  mapResponseReporter.resolve();
  fnLiteral += `
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`;
  return Function("inject", fnLiteral)({
    app,
    mapResponse: app["~adapter"].handler.mapResponse,
    ERROR_CODE: ERROR_CODE2,
    ElysiaCustomStatusResponse,
    ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE2 : undefined,
    ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID2 : undefined,
    ...adapter.inject
  });
};

// node_modules/elysia/dist/dynamic-handle.mjs
var injectDefaultValues = (typeChecker, obj) => {
  for (const [key, keySchema] of Object.entries(typeChecker.schema.properties)) {
    obj[key] ??= keySchema.default;
  }
};
var createDynamicHandler = (app) => {
  const { mapResponse: mapResponse3, mapEarlyResponse: mapEarlyResponse3 } = app["~adapter"].handler;
  return async (request) => {
    const url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi);
    const set2 = {
      cookie: {},
      status: 200,
      headers: {}
    };
    const context = Object.assign({}, app.singleton.decorator, {
      set: set2,
      store: app.singleton.store,
      request,
      path,
      qi,
      error: error2,
      redirect: redirect2
    });
    try {
      if (app.event.request)
        for (let i = 0;i < app.event.request.length; i++) {
          const onRequest = app.event.request[i].fn;
          let response2 = onRequest(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          response2 = mapEarlyResponse3(response2, set2);
          if (response2)
            return context.response = response2;
        }
      const handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find("ALL", path);
      if (!handler)
        throw new NotFoundError2;
      const { handle, hooks, validator, content, route } = handler.store;
      let body;
      if (request.method !== "GET" && request.method !== "HEAD") {
        if (content) {
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = parseQuery(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              const form2 = await request.formData();
              for (const key of form2.keys()) {
                if (body[key])
                  continue;
                const value = form2.getAll(key);
                if (value.length === 1)
                  body[key] = value[0];
                else
                  body[key] = value;
              }
              break;
          }
        } else {
          let contentType = request.headers.get("content-type");
          if (contentType) {
            const index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            context.contentType = contentType;
            if (hooks.parse)
              for (let i = 0;i < hooks.parse.length; i++) {
                const hook = hooks.parse[i].fn;
                let temp = hook(context, contentType);
                if (temp instanceof Promise)
                  temp = await temp;
                if (temp) {
                  body = temp;
                  break;
                }
              }
            delete context.contentType;
            if (body === undefined) {
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = parseQuery(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  const form2 = await request.formData();
                  for (const key of form2.keys()) {
                    if (body[key])
                      continue;
                    const value = form2.getAll(key);
                    if (value.length === 1)
                      body[key] = value[0];
                    else
                      body[key] = value;
                  }
                  break;
              }
            }
          }
        }
      }
      context.route = route;
      context.body = body;
      context.params = handler?.params || undefined;
      context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1));
      context.headers = {};
      for (const [key, value] of request.headers.entries())
        context.headers[key] = value;
      const cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config);
      const cookieHeaderValue = request.headers.get("cookie");
      context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta ? {
        secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
        sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
      } : undefined);
      const headerValidator = validator?.createHeaders?.();
      if (headerValidator)
        injectDefaultValues(headerValidator, context.headers);
      const paramsValidator = validator?.createParams?.();
      if (paramsValidator)
        injectDefaultValues(paramsValidator, context.params);
      const queryValidator = validator?.createQuery?.();
      if (queryValidator)
        injectDefaultValues(queryValidator, context.query);
      if (hooks.transform)
        for (let i = 0;i < hooks.transform.length; i++) {
          const hook = hooks.transform[i];
          const operation = hook.fn(context);
          if (hook.subType === "derive") {
            if (operation instanceof Promise)
              Object.assign(context, await operation);
            else
              Object.assign(context, operation);
          } else if (operation instanceof Promise)
            await operation;
        }
      if (validator) {
        if (headerValidator) {
          const _header = structuredClone(context.headers);
          for (const [key, value] of request.headers)
            _header[key] = value;
          if (validator.headers.Check(_header) === false)
            throw new ValidationError2("header", validator.headers, _header);
        } else if (validator.headers?.Decode)
          context.headers = validator.headers.Decode(context.headers);
        if (paramsValidator?.Check(context.params) === false) {
          throw new ValidationError2("params", validator.params, context.params);
        } else if (validator.params?.Decode)
          context.params = validator.params.Decode(context.params);
        if (queryValidator?.Check(context.query) === false)
          throw new ValidationError2("query", validator.query, context.query);
        else if (validator.query?.Decode)
          context.query = validator.query.Decode(context.query);
        if (validator.createCookie?.()) {
          let cookieValue = {};
          for (const [key, value] of Object.entries(context.cookie))
            cookieValue[key] = value.value;
          if (validator.cookie.Check(cookieValue) === false)
            throw new ValidationError2("cookie", validator.cookie, cookieValue);
          else if (validator.cookie?.Decode)
            cookieValue = validator.cookie.Decode(cookieValue);
        }
        if (validator.createBody?.()?.Check(body) === false)
          throw new ValidationError2("body", validator.body, body);
        else if (validator.body?.Decode)
          context.body = validator.body.Decode(body);
      }
      if (hooks.beforeHandle)
        for (let i = 0;i < hooks.beforeHandle.length; i++) {
          const hook = hooks.beforeHandle[i];
          let response2 = hook.fn(context);
          if (hook.subType === "resolve") {
            if (response2 instanceof ElysiaCustomStatusResponse) {
              const result = mapEarlyResponse3(response2, context.set);
              if (result)
                return context.response = result;
            }
            if (response2 instanceof Promise)
              Object.assign(context, await response2);
            else
              Object.assign(context, response2);
            continue;
          } else if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 !== undefined) {
            context.response = response2;
            if (hooks.afterHandle)
              for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
                let newResponse = hooks.afterHandle[i2].fn(context);
                if (newResponse instanceof Promise)
                  newResponse = await newResponse;
                if (newResponse)
                  response2 = newResponse;
              }
            const result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
        }
      let response = typeof handle === "function" ? handle(context) : handle;
      if (response instanceof Promise)
        response = await response;
      if (hooks.afterHandle)
        if (!hooks.afterHandle.length) {
          const status = response instanceof ElysiaCustomStatusResponse ? response.code : set2.status ? typeof set2.status === "string" ? StatusMap2[set2.status] : set2.status : 200;
          const responseValidator = validator?.createResponse?.()?.[status];
          if (responseValidator?.Check(response) === false)
            throw new ValidationError2("response", responseValidator, response);
          else if (responseValidator?.Decode)
            response = responseValidator.Decode(response);
        } else {
          context.response = response;
          for (let i = 0;i < hooks.afterHandle.length; i++) {
            let newResponse = hooks.afterHandle[i].fn(context);
            if (newResponse instanceof Promise)
              newResponse = await newResponse;
            const result = mapEarlyResponse3(newResponse, context.set);
            if (result !== undefined) {
              const responseValidator = validator?.response?.[result.status];
              if (responseValidator?.Check(result) === false)
                throw new ValidationError2("response", responseValidator, result);
              else if (responseValidator?.Decode)
                response = responseValidator.Decode(response);
              return context.response = result;
            }
          }
        }
      if (context.set.cookie && cookieMeta?.sign) {
        const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true)
          for (const [key, cookie] of Object.entries(context.set.cookie))
            context.set.cookie[key].value = await signCookie(cookie.value, "${secret}");
        else {
          const properties = validator?.cookie?.schema?.properties;
          for (const name of cookieMeta.sign) {
            if (!(name in properties))
              continue;
            if (context.set.cookie[name]?.value) {
              context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
            }
          }
        }
      }
      return mapResponse3(context.response = response, context.set);
    } catch (error22) {
      const reportedError = error22 instanceof TransformDecodeError && error22.error ? error22.error : error22;
      return app.handleError(context, reportedError);
    } finally {
      if (app.event.afterResponse)
        for (const afterResponse of app.event.afterResponse)
          await afterResponse.fn(context);
    }
  };
};
var createDynamicErrorHandler = (app) => {
  const { mapResponse: mapResponse3 } = app["~adapter"].handler;
  return async (context, error22) => {
    const errorContext = Object.assign(context, { error: error22, code: error22.code });
    errorContext.set = context.set;
    if (app.event.error)
      for (let i = 0;i < app.event.error.length; i++) {
        const hook = app.event.error[i];
        let response = hook.fn(errorContext);
        if (response instanceof Promise)
          response = await response;
        if (response !== undefined && response !== null)
          return context.response = mapResponse3(response, context.set);
      }
    return new Response(typeof error22.cause === "string" ? error22.cause : error22.message, {
      headers: context.set.headers,
      status: error22.status ?? 500
    });
  };
};

// node_modules/elysia/dist/index.mjs
class Elysia {
  constructor(config = {}) {
    this.server = null;
    this.dependencies = {};
    this._routes = {};
    this._types = {
      Prefix: "",
      Singleton: {},
      Definitions: {},
      Metadata: {}
    };
    this._ephemeral = {};
    this._volatile = {};
    this.singleton = {
      decorator: {},
      store: {},
      derive: {},
      resolve: {}
    };
    this.definitions = {
      typebox: t2.Module({}),
      type: {},
      error: {}
    };
    this.extender = {
      macros: [],
      higherOrderFunctions: []
    };
    this.validator = {
      global: null,
      scoped: null,
      local: null,
      getCandidate() {
        return mergeSchemaValidator(mergeSchemaValidator(this.global, this.scoped), this.local);
      }
    };
    this.event = {};
    this.telemetry = {
      stack: undefined
    };
    this.router = {
      "~http": undefined,
      get http() {
        if (!this["~http"])
          this["~http"] = new Memoirist({ lazy: true });
        return this["~http"];
      },
      "~dynamic": undefined,
      get dynamic() {
        if (!this["~dynamic"])
          this["~dynamic"] = new Memoirist;
        return this["~dynamic"];
      },
      static: {
        http: {
          static: {},
          map: {},
          all: ""
        },
        ws: {}
      },
      history: []
    };
    this.routeTree = /* @__PURE__ */ new Map;
    this.inference = {
      body: false,
      cookie: false,
      headers: false,
      query: false,
      set: false,
      server: false,
      request: false,
      route: false
    };
    this["~parser"] = {};
    this.handle = async (request) => this.fetch(request);
    this.fetch = (request) => {
      return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
    };
    this.handleError = async (context, error22) => {
      return (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error22);
    };
    this.outerErrorHandler = (error22) => new Response(error22.message || error22.name || "Error", {
      status: error22?.status ?? 500
    });
    this.listen = (options, callback) => {
      this["~adapter"].listen(this)(options, callback);
      return this;
    };
    this.stop = async (closeActiveConnections) => {
      if (!this.server)
        throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
      if (this.server) {
        this.server.stop(closeActiveConnections);
        this.server = null;
        if (this.event.stop?.length)
          for (let i = 0;i < this.event.stop.length; i++)
            this.event.stop[i].fn(this);
      }
    };
    if (config.tags) {
      if (!config.detail)
        config.detail = {
          tags: config.tags
        };
      else
        config.detail.tags = config.tags;
    }
    if (config.nativeStaticResponse === undefined)
      config.nativeStaticResponse = true;
    this.config = {};
    this.applyConfig(config ?? {});
    this["~adapter"] = config.adapter ?? (typeof Bun !== "undefined" ? BunAdapter : WebStandardAdapter);
    if (config?.analytic && (config?.name || config?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  getServer() {
    return this.server;
  }
  getParent() {
    return null;
  }
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new PromiseGroup;
    return this._promisedModules;
  }
  env(model, _env = env3) {
    const validator = getSchemaValidator2(model, {
      modules: this.definitions.typebox,
      dynamic: true,
      additionalProperties: true,
      coerce: true
    });
    if (validator.Check(_env) === false) {
      const error22 = new ValidationError2("env", model, _env);
      throw new Error(error22.all.map((x) => x.summary).join(`
`));
    }
    return this;
  }
  wrap(fn) {
    this.extender.higherOrderFunctions.push({
      checksum: checksum2(JSON.stringify({
        name: this.config.name,
        seed: this.config.seed,
        content: fn.toString()
      })),
      fn
    });
    return this;
  }
  applyMacro(localHook) {
    if (this.extender.macros.length) {
      const manage = createMacroManager({
        globalHook: this.event,
        localHook
      });
      const manager = {
        events: {
          global: this.event,
          local: localHook
        },
        get onParse() {
          return manage("parse");
        },
        get onTransform() {
          return manage("transform");
        },
        get onBeforeHandle() {
          return manage("beforeHandle");
        },
        get onAfterHandle() {
          return manage("afterHandle");
        },
        get mapResponse() {
          return manage("mapResponse");
        },
        get onAfterResponse() {
          return manage("afterResponse");
        },
        get onError() {
          return manage("error");
        }
      };
      for (const macro of this.extender.macros)
        traceBackMacro(macro.fn(manager), localHook, manage);
    }
  }
  applyConfig(config) {
    this.config = {
      prefix: "",
      aot: env3.ELYSIA_AOT !== "false",
      normalize: true,
      ...config,
      cookie: {
        path: "/",
        ...config?.cookie
      },
      experimental: config?.experimental ?? {},
      seed: config?.seed === undefined ? "" : config?.seed
    };
    return this;
  }
  get models() {
    const models = {};
    for (const name of Object.keys(this.definitions.type))
      models[name] = getSchemaValidator2(this.definitions.typebox.Import(name));
    models.modules = this.definitions.typebox;
    return models;
  }
  add(method, path, handle, localHook, { allowMeta = false, skipPrefix = false } = {
    allowMeta: false,
    skipPrefix: false
  }) {
    localHook = compressHistoryHook(localHookToLifeCycleStore(localHook));
    if (path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    const models = this.definitions.type;
    const dynamic = !this.config.aot;
    const instanceValidator = { ...this.validator.getCandidate() };
    const cloned = {
      body: localHook?.body ?? instanceValidator?.body,
      headers: localHook?.headers ?? instanceValidator?.headers,
      params: localHook?.params ?? instanceValidator?.params,
      query: localHook?.query ?? instanceValidator?.query,
      cookie: localHook?.cookie ?? instanceValidator?.cookie,
      response: localHook?.response ?? instanceValidator?.response
    };
    const cookieValidator = () => cloned.cookie ? getCookieValidator({
      modules,
      validator: cloned.cookie,
      defaultConfig: this.config.cookie,
      config: cloned.cookie?.config ?? {},
      dynamic,
      models
    }) : undefined;
    const normalize = this.config.normalize;
    const modules = this.definitions.typebox;
    const validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? {
      body: getSchemaValidator2(cloned.body, {
        modules,
        dynamic,
        models,
        normalize,
        additionalCoerce: coercePrimitiveRoot()
      }),
      headers: getSchemaValidator2(cloned.headers, {
        modules,
        dynamic,
        models,
        additionalProperties: !this.config.normalize,
        coerce: true,
        additionalCoerce: stringToStructureCoercions()
      }),
      params: getSchemaValidator2(cloned.params, {
        modules,
        dynamic,
        models,
        coerce: true,
        additionalCoerce: stringToStructureCoercions()
      }),
      query: getSchemaValidator2(cloned.query, {
        modules,
        dynamic,
        models,
        normalize,
        coerce: true,
        additionalCoerce: stringToStructureCoercions()
      }),
      cookie: cookieValidator(),
      response: getResponseSchemaValidator2(cloned.response, {
        modules,
        dynamic,
        models,
        normalize
      })
    } : {
      createBody() {
        if (this.body)
          return this.body;
        return this.body = getSchemaValidator2(cloned.body, {
          modules,
          dynamic,
          models,
          normalize,
          additionalCoerce: coercePrimitiveRoot()
        });
      },
      createHeaders() {
        if (this.headers)
          return this.headers;
        return this.headers = getSchemaValidator2(cloned.headers, {
          modules,
          dynamic,
          models,
          additionalProperties: !normalize,
          coerce: true,
          additionalCoerce: stringToStructureCoercions()
        });
      },
      createParams() {
        if (this.params)
          return this.params;
        return this.params = getSchemaValidator2(cloned.params, {
          modules,
          dynamic,
          models,
          coerce: true,
          additionalCoerce: stringToStructureCoercions()
        });
      },
      createQuery() {
        if (this.query)
          return this.query;
        return this.query = getSchemaValidator2(cloned.query, {
          modules,
          dynamic,
          models,
          coerce: true,
          additionalCoerce: stringToStructureCoercions()
        });
      },
      createCookie() {
        if (this.cookie)
          return this.cookie;
        return this.cookie = cookieValidator();
      },
      createResponse() {
        if (this.response)
          return this.response;
        return this.response = getResponseSchemaValidator2(cloned.response, {
          modules,
          dynamic,
          models,
          normalize
        });
      }
    };
    localHook = mergeHook2(localHook, compressHistoryHook(instanceValidator));
    if (localHook.tags) {
      if (!localHook.detail)
        localHook.detail = {
          tags: localHook.tags
        };
      else
        localHook.detail.tags = localHook.tags;
    }
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
    this.applyMacro(localHook);
    const hooks = compressHistoryHook(mergeHook2(this.event, localHook));
    if (this.config.aot === false) {
      this.router.dynamic.add(method, path, {
        validator,
        hooks,
        content: localHook?.type,
        handle,
        route: path
      });
      const encoded = encodePath(path, { dynamic: true });
      if (path !== encoded) {
        this.router.dynamic.add(method, encoded, {
          validator,
          hooks,
          content: localHook?.type,
          handle,
          route: path
        });
      }
      if (this.config.strictPath === false) {
        const loosePath = getLoosePath(path);
        this.router.dynamic.add(method, loosePath, {
          validator,
          hooks,
          content: localHook?.type,
          handle,
          route: path
        });
        const encoded2 = encodePath(loosePath);
        if (loosePath !== encoded2)
          this.router.dynamic.add(method, loosePath, {
            validator,
            hooks,
            content: localHook?.type,
            handle,
            route: path
          });
      }
      this.router.history.push({
        method,
        path,
        composed: null,
        handler: handle,
        hooks
      });
      return;
    }
    const shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true;
    const inference = cloneInference2(this.inference);
    const adapter = this["~adapter"].handler;
    const staticHandler = typeof handle !== "function" && typeof adapter.createStaticHandler === "function" ? adapter.createStaticHandler(handle, hooks, this.setHeaders) : undefined;
    const nativeStaticHandler = typeof handle !== "function" ? adapter.createNativeStaticHandler?.(handle, hooks, this.setHeaders) : undefined;
    if (this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
      this.router.static.http.static[path] = nativeStaticHandler();
    let compile = (asManifest = false) => composeHandler({
      app: this,
      path,
      method,
      hooks,
      validator,
      handler: typeof handle !== "function" && typeof adapter.createStaticHandler !== "function" ? () => handle : handle,
      allowMeta,
      inference,
      asManifest
    });
    let oldIndex;
    if (this.routeTree.has(method + path))
      for (let i = 0;i < this.router.history.length; i++) {
        const route = this.router.history[i];
        if (route.path === path && route.method === method) {
          oldIndex = i;
          break;
        }
      }
    else
      this.routeTree.set(method + path, this.router.history.length);
    const history = this.router.history;
    const index = oldIndex ?? this.router.history.length;
    const mainHandler = shouldPrecompile ? compile() : (ctx) => {
      const temp = (history[index].composed = compile())(ctx);
      compile = undefined;
      return temp;
    };
    if (shouldPrecompile)
      compile = undefined;
    const isWebSocket = method === "$INTERNALWS";
    if (oldIndex !== undefined)
      this.router.history[oldIndex] = Object.assign({
        method,
        path,
        composed: mainHandler,
        handler: handle,
        hooks
      }, localHook.webSocket ? { websocket: localHook.websocket } : {});
    else
      this.router.history.push(Object.assign({
        method,
        path,
        composed: mainHandler,
        handler: handle,
        hooks
      }, localHook.webSocket ? { websocket: localHook.websocket } : {}));
    const staticRouter = this.router.static.http;
    const handler = {
      handler: shouldPrecompile ? mainHandler : undefined,
      compile() {
        return this.handler = compile();
      }
    };
    if (isWebSocket) {
      this.router.http.add("ws", path, handler);
      if (!this.config.strictPath)
        this.router.http.add("ws", getLoosePath(path), handler);
      const encoded = encodePath(path, { dynamic: true });
      if (encoded !== path)
        this.router.http.add("ws", encoded, handler);
      return;
    }
    if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
      if (!staticRouter.map[path])
        staticRouter.map[path] = {
          code: ""
        };
      const ctx = staticHandler ? "" : "c";
      if (method === "ALL")
        staticRouter.map[path].all = `default:return ht[${index}].composed(${ctx})
`;
      else
        staticRouter.map[path].code = `case '${method}':return ht[${index}].composed(${ctx})
${staticRouter.map[path].code}`;
      if (!this.config.strictPath && this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
        this.router.static.http.static[getLoosePath(path)] = nativeStaticHandler();
    } else {
      this.router.http.add(method, path, handler);
      if (!this.config.strictPath) {
        const loosePath = getLoosePath(path);
        if (this.config.nativeStaticResponse === true && staticHandler && (method === "GET" || method === "ALL"))
          this.router.static.http.static[loosePath] = staticHandler();
        this.router.http.add(method, loosePath, handler);
      }
      const encoded = encodePath(path, { dynamic: true });
      if (path !== encoded) {
        this.router.http.add(method, encoded, handler);
        if (this.config.nativeStaticResponse === true && staticHandler && (method === "GET" || method === "ALL"))
          this.router.static.http.static[encoded] = staticHandler();
        this.router.http.add(method, encoded, handler);
      }
    }
  }
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    this.setHeaders = mergeDeep(this.setHeaders, header);
    return this;
  }
  onStart(handler) {
    this.on("start", handler);
    return this;
  }
  onRequest(handler) {
    this.on("request", handler);
    return this;
  }
  onParse(options, handler) {
    if (!handler) {
      if (typeof options === "string")
        return this.on("parse", this["~parser"][options]);
      return this.on("parse", options);
    }
    return this.on(options, "parse", handler);
  }
  parser(name, parser) {
    this["~parser"][name] = parser;
    return this;
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve) {
      resolve = optionsOrResolve;
      optionsOrResolve = { as: "local" };
    }
    const hook = {
      subType: "resolve",
      fn: resolve
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper) {
      mapper = optionsOrResolve;
      optionsOrResolve = { as: "local" };
    }
    const hook = {
      subType: "mapResolve",
      fn: mapper
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onAfterResponse(options, handler) {
    if (!handler)
      return this.on("afterResponse", options);
    return this.on(options, "afterResponse", handler);
  }
  trace(options, handler) {
    if (!handler) {
      handler = options;
      options = { as: "local" };
    }
    if (!Array.isArray(handler))
      handler = [handler];
    for (const fn of handler)
      this.on(options, "trace", createTracer(fn));
    return this;
  }
  error(name, error22) {
    switch (typeof name) {
      case "string":
        error22.prototype[ERROR_CODE2] = name;
        this.definitions.error[name] = error22;
        return this;
      case "function":
        this.definitions.error = name(this.definitions.error);
        return this;
    }
    for (const [code, error3] of Object.entries(name)) {
      error3.prototype[ERROR_CODE2] = code;
      this.definitions.error[code] = error3;
    }
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    this.on("stop", handler);
    return this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type2;
    switch (typeof optionsOrType) {
      case "string":
        type2 = optionsOrType;
        handlers = typeOrHandlers;
        break;
      case "object":
        type2 = typeOrHandlers;
        if (!Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
          handlers = typeOrHandlers;
        break;
    }
    if (Array.isArray(handlers))
      handlers = fnToContainer(handlers);
    else {
      if (typeof handlers === "function")
        handlers = [
          {
            fn: handlers
          }
        ];
      else
        handlers = [handlers];
    }
    const handles = handlers;
    for (const handle of handles) {
      handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local";
      if (type2 === "resolve" || type2 === "derive")
        handle.subType = type2;
    }
    if (type2 !== "trace")
      sucrose({
        [type2]: handles.map((x) => x.fn)
      }, this.inference);
    for (const handle of handles) {
      const fn = asHookType(handle, "global", { skipIfHasType: true });
      switch (type2) {
        case "start":
          this.event.start ??= [];
          this.event.start.push(fn);
          break;
        case "request":
          this.event.request ??= [];
          this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse ??= [];
          this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform ??= [];
          this.event.transform.push(fn);
          break;
        case "derive":
          this.event.transform ??= [];
          this.event.transform.push(fnToContainer(fn, "derive"));
          break;
        case "beforeHandle":
          this.event.beforeHandle ??= [];
          this.event.beforeHandle.push(fn);
          break;
        case "resolve":
          this.event.beforeHandle ??= [];
          this.event.beforeHandle.push(fnToContainer(fn, "resolve"));
          break;
        case "afterHandle":
          this.event.afterHandle ??= [];
          this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse ??= [];
          this.event.mapResponse.push(fn);
          break;
        case "afterResponse":
          this.event.afterResponse ??= [];
          this.event.afterResponse.push(fn);
          break;
        case "trace":
          this.event.trace ??= [];
          this.event.trace.push(fn);
          break;
        case "error":
          this.event.error ??= [];
          this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop ??= [];
          this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  propagate() {
    promoteEvent(this.event.parse);
    promoteEvent(this.event.transform);
    promoteEvent(this.event.beforeHandle);
    promoteEvent(this.event.afterHandle);
    promoteEvent(this.event.mapResponse);
    promoteEvent(this.event.afterResponse);
    promoteEvent(this.event.trace);
    promoteEvent(this.event.error);
    return this;
  }
  as(type2) {
    const castType = { plugin: "scoped", scoped: "scoped", global: "global" }[type2];
    promoteEvent(this.event.parse, castType);
    promoteEvent(this.event.transform, castType);
    promoteEvent(this.event.beforeHandle, castType);
    promoteEvent(this.event.afterHandle, castType);
    promoteEvent(this.event.mapResponse, castType);
    promoteEvent(this.event.afterResponse, castType);
    promoteEvent(this.event.trace, castType);
    promoteEvent(this.event.error, castType);
    if (type2 === "plugin") {
      this.validator.scoped = mergeSchemaValidator(this.validator.scoped, this.validator.local);
      this.validator.local = null;
    } else if (type2 === "global") {
      this.validator.global = mergeSchemaValidator(this.validator.global, mergeSchemaValidator(this.validator.scoped, this.validator.local));
      this.validator.scoped = null;
      this.validator.local = null;
    }
    return this;
  }
  group(prefix, schemaOrRun, run) {
    const instance = new Elysia({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton };
    instance.definitions = { ...this.definitions };
    instance.getServer = () => this.getServer();
    instance.inference = cloneInference2(this.inference);
    instance.extender = { ...this.extender };
    const isSchema = typeof schemaOrRun === "object";
    const sandbox = (isSchema ? run : schemaOrRun)(instance);
    this.singleton = mergeDeep(this.singleton, instance.singleton);
    this.definitions = mergeDeep(this.definitions, instance.definitions);
    if (sandbox.event.request?.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.mapResponse?.length)
      this.event.mapResponse = [
        ...this.event.mapResponse || [],
        ...sandbox.event.mapResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
      path = (isSchema ? "" : this.config.prefix) + prefix + path;
      if (isSchema) {
        const hook = schemaOrRun;
        const localHook = hooks;
        this.add(method, path, handler, mergeHook2(hook, {
          ...localHook || {},
          error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
            ...localHook.error || {},
            ...sandbox.event.error || {}
          ] : [
            localHook.error,
            ...sandbox.event.error || {}
          ]
        }));
      } else {
        this.add(method, path, handler, mergeHook2(hooks, {
          error: sandbox.event.error
        }), {
          skipPrefix: true
        });
      }
    });
    return this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        this.applyMacro(hook);
        const type2 = hook.as ?? "local";
        this.validator[type2] = {
          body: hook.body ?? this.validator[type2]?.body,
          headers: hook.headers ?? this.validator[type2]?.headers,
          params: hook.params ?? this.validator[type2]?.params,
          query: hook.query ?? this.validator[type2]?.query,
          response: hook.response ?? this.validator[type2]?.response,
          cookie: hook.cookie ?? this.validator[type2]?.cookie
        };
        if (hook.parse)
          this.on({ as: type2 }, "parse", hook.parse);
        if (hook.transform)
          this.on({ as: type2 }, "transform", hook.transform);
        if (hook.derive)
          this.on({ as: type2 }, "derive", hook.derive);
        if (hook.beforeHandle)
          this.on({ as: type2 }, "beforeHandle", hook.beforeHandle);
        if (hook.resolve)
          this.on({ as: type2 }, "resolve", hook.resolve);
        if (hook.afterHandle)
          this.on({ as: type2 }, "afterHandle", hook.afterHandle);
        if (hook.mapResponse)
          this.on({ as: type2 }, "mapResponse", hook.mapResponse);
        if (hook.afterResponse)
          this.on({ as: type2 }, "afterResponse", hook.afterResponse);
        if (hook.error)
          this.on({ as: type2 }, "error", hook.error);
        if (hook.detail) {
          if (this.config.detail)
            this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        }
        if (hook?.tags) {
          if (!this.config.detail)
            this.config.detail = {
              tags: hook.tags
            };
          else
            this.config.detail.tags = hook.tags;
        }
        return this;
      }
      return this.guard({}, hook);
    }
    const instance = new Elysia({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton };
    instance.definitions = { ...this.definitions };
    instance.inference = cloneInference2(this.inference);
    instance.extender = { ...this.extender };
    const sandbox = run(instance);
    this.singleton = mergeDeep(this.singleton, instance.singleton);
    this.definitions = mergeDeep(this.definitions, instance.definitions);
    sandbox.getServer = () => this.server;
    if (sandbox.event.request?.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.mapResponse?.length)
      this.event.mapResponse = [
        ...this.event.mapResponse || [],
        ...sandbox.event.mapResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook2(hook, {
        ...localHook || {},
        error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
          ...localHook.error || {},
          ...sandbox.event.error || []
        ] : [
          localHook.error,
          ...sandbox.event.error || []
        ]
      }));
    });
    return this;
  }
  use(plugin, options) {
    if (Array.isArray(plugin)) {
      let app = this;
      for (const p of plugin)
        app = app.use(p);
      return app;
    }
    if (options?.scoped)
      return this.guard({}, (app) => app.use(plugin));
    if (Array.isArray(plugin)) {
      let current = this;
      for (const p of plugin)
        current = this.use(p);
      return current;
    }
    if (plugin instanceof Promise) {
      this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof Elysia)
          return this._use(plugin2).compile();
        if (plugin2.constructor.name === "Elysia")
          return this._use(plugin2).compile();
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof Elysia)
          return this._use(plugin2.default);
        if (plugin2.constructor.name === "Elysia")
          return this._use(plugin2.default);
        if (plugin2.constructor.name === "_Elysia")
          return this._use(plugin2.default);
        try {
          return this._use(plugin2.default);
        } catch (error22) {
          console.error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
          throw error22;
        }
      }).then((v) => {
        if (v && typeof v.compile === "function")
          v.compile();
        return v;
      }));
      return this;
    }
    return this._use(plugin);
  }
  propagatePromiseModules(plugin) {
    if (plugin.promisedModules.size <= 0)
      return this;
    for (const promise of plugin.promisedModules.promises)
      this.promisedModules.add(promise.then((v) => {
        if (!v)
          return;
        const t3 = this._use(v);
        if (t3 instanceof Promise)
          return t3.then((v2) => {
            if (v2)
              v2.compile();
            else
              v.compile();
          });
        return v.compile();
      }));
    return this;
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      const instance = plugin(this);
      if (instance instanceof Promise) {
        this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof Elysia) {
            plugin2.getServer = () => this.getServer();
            plugin2.getGlobalRoutes = () => this.getGlobalRoutes();
            plugin2.model(this.definitions.type);
            plugin2.error(this.definitions.error);
            for (const {
              method,
              path,
              handler,
              hooks
            } of Object.values(plugin2.router.history))
              this.add(method, path, handler, mergeHook2(hooks, {
                error: plugin2.event.error
              }));
            plugin2.compile();
            if (plugin2 === this)
              return;
            this.propagatePromiseModules(plugin2);
            return plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((v) => {
          if (v && typeof v.compile === "function")
            v.compile();
          return v;
        }));
        return this;
      }
      return instance;
    }
    this.propagatePromiseModules(plugin);
    const { name, seed } = plugin.config;
    plugin.getParent = () => this;
    plugin.getServer = () => this.getServer();
    plugin.getGlobalRoutes = () => this.getGlobalRoutes();
    plugin.model(this.definitions.type);
    plugin.error(this.definitions.error);
    this["~parser"] = {
      ...plugin["~parser"],
      ...this["~parser"]
    };
    this.headers(plugin.setHeaders);
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      const current = seed !== undefined ? checksum2(name + JSON.stringify(seed)) : 0;
      if (!this.dependencies[name].some(({ checksum: checksum3 }) => current === checksum3)) {
        this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
        this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
      }
    } else {
      this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    }
    deduplicateChecksum2(this.extender.macros);
    deduplicateChecksum2(this.extender.higherOrderFunctions);
    const hofHashes = [];
    for (let i = 0;i < this.extender.higherOrderFunctions.length; i++) {
      const hof = this.extender.higherOrderFunctions[i];
      if (hof.checksum) {
        if (hofHashes.includes(hof.checksum)) {
          this.extender.higherOrderFunctions.splice(i, 1);
          i--;
        }
        hofHashes.push(hof.checksum);
      }
    }
    this.inference = {
      body: this.inference.body || plugin.inference.body,
      cookie: this.inference.cookie || plugin.inference.cookie,
      headers: this.inference.headers || plugin.inference.headers,
      query: this.inference.query || plugin.inference.query,
      set: this.inference.set || plugin.inference.set,
      server: this.inference.server || plugin.inference.server,
      request: this.inference.request || plugin.inference.request,
      route: this.inference.route || plugin.inference.route
    };
    this.decorate(plugin.singleton.decorator);
    this.state(plugin.singleton.store);
    this.model(plugin.definitions.type);
    this.error(plugin.definitions.error);
    plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
    for (const { method, path, handler, hooks } of Object.values(plugin.router.history)) {
      this.add(method, path, handler, mergeHook2(hooks, {
        error: plugin.event.error
      }));
    }
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      const current = seed !== undefined ? checksum2(name + JSON.stringify(seed)) : 0;
      if (this.dependencies[name].some(({ checksum: checksum3 }) => current === checksum3))
        return this;
      this.dependencies[name].push(this.config?.analytic ? {
        name: plugin.config.name,
        seed: plugin.config.seed,
        checksum: current,
        dependencies: plugin.dependencies,
        stack: plugin.telemetry.stack,
        routes: plugin.router.history,
        decorators: plugin.singleton,
        store: plugin.singleton.store,
        error: plugin.definitions.error,
        derive: plugin.event.transform?.filter((x) => x?.subType === "derive").map((x) => ({
          fn: x.toString(),
          stack: new Error().stack ?? ""
        })),
        resolve: plugin.event.transform?.filter((x) => x?.subType === "resolve").map((x) => ({
          fn: x.toString(),
          stack: new Error().stack ?? ""
        }))
      } : {
        name: plugin.config.name,
        seed: plugin.config.seed,
        checksum: current,
        dependencies: plugin.dependencies
      });
      this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
    } else {
      this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
    }
    this.validator.global = mergeHook2(this.validator.global, {
      ...plugin.validator.global
    });
    this.validator.local = mergeHook2(this.validator.local, {
      ...plugin.validator.scoped
    });
    return this;
  }
  macro(macro) {
    if (typeof macro === "function") {
      const hook = {
        checksum: checksum2(JSON.stringify({
          name: this.config.name,
          seed: this.config.seed,
          content: macro.toString()
        })),
        fn: macro
      };
      this.extender.macros.push(hook);
    } else if (typeof macro === "object") {
      for (const name of Object.keys(macro))
        if (typeof macro[name] === "object") {
          const actualValue = { ...macro[name] };
          macro[name] = (v) => {
            if (v === true)
              return actualValue;
          };
        }
      const hook = {
        checksum: checksum2(JSON.stringify({
          name: this.config.name,
          seed: this.config.seed,
          content: Object.entries(macro).map(([k, v]) => `${k}+${v}`).join(",")
        })),
        fn: () => macro
      };
      this.extender.macros.push(hook);
    }
    return this;
  }
  mount(path, handle) {
    if (path instanceof Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      const run = typeof path === "function" ? path : path instanceof Elysia ? path.compile().fetch : handle instanceof Elysia ? handle.compile().fetch : handle;
      const handler2 = ({ request, path: path2 }) => run(new Request(replaceUrlPath2(request.url, path2), {
        method: request.method,
        headers: request.headers,
        signal: request.signal,
        credentials: request.credentials,
        referrerPolicy: request.referrerPolicy,
        duplex: request.duplex,
        redirect: request.redirect,
        mode: request.mode,
        keepalive: request.keepalive,
        integrity: request.integrity,
        body: request.body
      }));
      this.all("/*", handler2, {
        parse: "none"
      });
      return this;
    }
    if (!handle)
      return this;
    const length = path.length - (path.endsWith("*") ? 1 : 0);
    if (handle instanceof Elysia)
      handle = handle.compile().fetch;
    const handler = ({ request, path: path2 }) => handle(new Request(replaceUrlPath2(request.url, path2.slice(length) || "/"), {
      method: request.method,
      headers: request.headers,
      signal: request.signal,
      credentials: request.credentials,
      referrerPolicy: request.referrerPolicy,
      duplex: request.duplex,
      redirect: request.redirect,
      mode: request.mode,
      keepalive: request.keepalive,
      integrity: request.integrity,
      body: request.body
    }));
    this.all(path, handler, {
      parse: "none"
    });
    this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
      parse: "none"
    });
    return this;
  }
  get(path, handler, hook) {
    this.add("GET", path, handler, hook);
    return this;
  }
  post(path, handler, hook) {
    this.add("POST", path, handler, hook);
    return this;
  }
  put(path, handler, hook) {
    this.add("PUT", path, handler, hook);
    return this;
  }
  patch(path, handler, hook) {
    this.add("PATCH", path, handler, hook);
    return this;
  }
  delete(path, handler, hook) {
    this.add("DELETE", path, handler, hook);
    return this;
  }
  options(path, handler, hook) {
    this.add("OPTIONS", path, handler, hook);
    return this;
  }
  all(path, handler, hook) {
    this.add("ALL", path, handler, hook);
    return this;
  }
  head(path, handler, hook) {
    this.add("HEAD", path, handler, hook);
    return this;
  }
  connect(path, handler, hook) {
    this.add("CONNECT", path, handler, hook);
    return this;
  }
  route(method, path, handler, hook) {
    this.add(method.toUpperCase(), path, handler, hook, hook?.config);
    return this;
  }
  ws(path, options) {
    if (this["~adapter"].ws)
      this["~adapter"].ws(this, path, options);
    else
      console.warn(`Current adapter doesn't support WebSocket`);
    return this;
  }
  state(options, name, value) {
    if (name === undefined) {
      value = options;
      options = { as: "append" };
      name = "";
    } else if (value === undefined) {
      if (typeof options === "string") {
        value = name;
        name = options;
        options = { as: "append" };
      } else if (typeof options === "object") {
        value = name;
        name = "";
      }
    }
    const { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.store)
            this.singleton.store[name] = mergeDeep(this.singleton.store[name], value, {
              override: as === "override"
            });
          else
            this.singleton.store[name] = value;
          return this;
        }
        if (value === null)
          return this;
        this.singleton.store = mergeDeep(this.singleton.store, value, {
          override: as === "override"
        });
        return this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value;
        } else
          this.singleton.store = value(this.singleton.store);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.store))
          this.singleton.store[name] = value;
        return this;
    }
  }
  decorate(options, name, value) {
    if (name === undefined) {
      value = options;
      options = { as: "append" };
      name = "";
    } else if (value === undefined) {
      if (typeof options === "string") {
        value = name;
        name = options;
        options = { as: "append" };
      } else if (typeof options === "object") {
        value = name;
        name = "";
      }
    }
    const { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.decorator)
            this.singleton.decorator[name] = mergeDeep(this.singleton.decorator[name], value, {
              override: as === "override"
            });
          else
            this.singleton.decorator[name] = value;
          return this;
        }
        if (value === null)
          return this;
        this.singleton.decorator = mergeDeep(this.singleton.decorator, value, {
          override: as === "override"
        });
        return this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value;
        } else
          this.singleton.decorator = value(this.singleton.decorator);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.decorator))
          this.singleton.decorator[name] = value;
        return this;
    }
  }
  derive(optionsOrTransform, transform2) {
    if (!transform2) {
      transform2 = optionsOrTransform;
      optionsOrTransform = { as: "local" };
    }
    const hook = {
      subType: "derive",
      fn: transform2
    };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    const coerce = (schema) => replaceSchemaType2(schema, [
      {
        from: t2.Number(),
        to: (options) => t2.Numeric(options),
        untilObjectFound: true
      },
      {
        from: t2.Boolean(),
        to: (options) => t2.BooleanString(options),
        untilObjectFound: true
      }
    ]);
    switch (typeof name) {
      case "object":
        const parsedSchemas = {};
        const kvs = Object.entries(name);
        for (const [key, value] of kvs) {
          if (key in this.definitions.type)
            continue;
          parsedSchemas[key] = this.definitions.type[key] = coerce(value);
          parsedSchemas[key].$id ??= `#/components/schemas/${key}`;
        }
        this.definitions.typebox = t2.Module({
          ...this.definitions.typebox["$defs"],
          ...parsedSchemas
        });
        return this;
      case "function":
        const result = coerce(name(this.definitions.type));
        this.definitions.type = result;
        this.definitions.typebox = t2.Module(result);
        return this;
      case "string":
        if (!model)
          break;
        const newModel = {
          ...model,
          id: model.$id ?? `#/components/schemas/${name}`
        };
        this.definitions.type[name] = model;
        this.definitions.typebox = t2.Module({
          ...this.definitions.typebox["$defs"],
          ...newModel
        });
        return this;
    }
    this.definitions.type[name] = model;
    this.definitions.typebox = t2.Module({
      ...this.definitions.typebox["$defs"],
      [name]: model
    });
    return this;
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper) {
      mapper = optionsOrDerive;
      optionsOrDerive = { as: "local" };
    }
    const hook = {
      subType: "mapDerive",
      fn: mapper
    };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type2, word) {
    if (word === "")
      return this;
    const delimieter = ["_", "-", " "];
    const capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1);
    const joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix);
    const remap = (type22) => {
      const store = {};
      switch (type22) {
        case "decorator":
          for (const key in this.singleton.decorator) {
            store[joinKey(word, key)] = this.singleton.decorator[key];
          }
          this.singleton.decorator = store;
          break;
        case "state":
          for (const key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (const key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (const key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    };
    const types = Array.isArray(type2) ? type2 : [type2];
    for (const type22 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type22);
    return this;
  }
  prefix(type2, word) {
    return this.affix("prefix", type2, word);
  }
  suffix(type2, word) {
    return this.affix("suffix", type2, word);
  }
  compile() {
    if (this["~adapter"].isWebStandard) {
      this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this);
      if (typeof this.server?.reload === "function")
        this.server.reload({
          ...this.server || {},
          fetch: this.fetch
        });
      return this;
    }
    if (typeof this.server?.reload === "function")
      this.server.reload(this.server || {});
    this._handle = composeGeneralHandler(this);
    return this;
  }
  get modules() {
    return this.promisedModules;
  }
}

// node_modules/@elysiajs/static/dist/index.mjs
var import_node_cache = __toESM(require_node_cache2(), 1);
import { readdir, stat as stat2 } from "fs/promises";
import { resolve, resolve as resolveFn, join, sep } from "path";
import { stat } from "fs/promises";
async function isCached(headers, etag, filePath) {
  if (headers["cache-control"] && headers["cache-control"].indexOf("no-cache") !== -1)
    return false;
  if ("if-none-match" in headers) {
    const ifNoneMatch = headers["if-none-match"];
    if (ifNoneMatch === "*")
      return true;
    if (ifNoneMatch === null)
      return false;
    if (typeof etag !== "string")
      return false;
    const isMatching = ifNoneMatch === etag;
    if (isMatching)
      return true;
    return false;
  }
  if (headers["if-modified-since"]) {
    const ifModifiedSince = headers["if-modified-since"];
    let lastModified;
    try {
      lastModified = (await stat(filePath)).mtime;
    } catch {}
    if (lastModified !== undefined && lastModified.getTime() <= Date.parse(ifModifiedSince))
      return true;
  }
  return false;
}
async function generateETag(file3) {
  const hash2 = new Bun.CryptoHasher("md5");
  hash2.update(await file3.arrayBuffer());
  return hash2.digest("base64");
}
var URL_PATH_SEP = "/";
var fileExists = (path) => stat2(path).then(() => true, () => false);
var statCache = new import_node_cache.default({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var fileCache = new import_node_cache.default({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var htmlCache = new import_node_cache.default({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var listFiles = async (dir) => {
  const files = await readdir(dir);
  const all = await Promise.all(files.map(async (name) => {
    const file3 = dir + sep + name;
    const stats = await stat2(file3);
    return stats && stats.isDirectory() ? await listFiles(file3) : [resolve(dir, file3)];
  }));
  return all.flat();
};
var staticPlugin = async ({
  assets = "public",
  prefix = "/public",
  staticLimit = 1024,
  alwaysStatic = false,
  ignorePatterns = [".DS_Store", ".git", ".env"],
  noExtension = false,
  enableDecodeURI = false,
  resolve: resolve2 = resolveFn,
  headers = {},
  noCache = false,
  maxAge = 86400,
  directive = "public",
  indexHTML = true
} = {
  assets: "public",
  prefix: "/public",
  staticLimit: 1024,
  alwaysStatic: false,
  ignorePatterns: [],
  noExtension: false,
  enableDecodeURI: false,
  resolve: resolveFn,
  headers: {},
  noCache: false,
  indexHTML: true
}) => {
  const files = await listFiles(resolveFn(assets));
  const isFSSepUnsafe = sep !== URL_PATH_SEP;
  if (prefix === URL_PATH_SEP)
    prefix = "";
  const shouldIgnore = (file3) => {
    if (!ignorePatterns.length)
      return false;
    return ignorePatterns.find((pattern) => {
      if (typeof pattern === "string")
        return pattern.includes(file3);
      else
        return pattern.test(file3);
    });
  };
  const app = new Elysia({
    name: "static",
    seed: {
      assets,
      prefix,
      staticLimit,
      alwaysStatic,
      ignorePatterns,
      noExtension,
      enableDecodeURI,
      resolve: resolve2.toString(),
      headers,
      noCache,
      maxAge,
      directive,
      indexHTML
    }
  });
  const assetsDir = assets[0] === sep ? assets : resolve2() + sep + assets;
  if (alwaysStatic || process.env.ENV === "production" && files.length <= staticLimit)
    for (const absolutePath of files) {
      if (!absolutePath || shouldIgnore(absolutePath))
        continue;
      let relativePath = absolutePath.replace(assetsDir, "");
      if (noExtension) {
        const temp = relativePath.split(".");
        temp.splice(-1);
        relativePath = temp.join(".");
      }
      const file3 = Bun.file(absolutePath);
      const etag = await generateETag(file3);
      const pathName = isFSSepUnsafe ? prefix + relativePath.split(sep).join(URL_PATH_SEP) : join(prefix, relativePath);
      app.get(pathName, noCache ? new Response(file3, {
        headers
      }) : async ({ headers: reqHeaders }) => {
        if (await isCached(reqHeaders, etag, absolutePath)) {
          return new Response(null, {
            status: 304,
            headers
          });
        }
        headers["Etag"] = etag;
        headers["Cache-Control"] = directive;
        if (maxAge !== null)
          headers["Cache-Control"] += `, max-age=${maxAge}`;
        return new Response(file3, {
          headers
        });
      });
      if (indexHTML && pathName.endsWith("/index.html"))
        app.get(pathName.replace("/index.html", ""), noCache ? new Response(file3, {
          headers
        }) : async ({ headers: reqHeaders }) => {
          if (await isCached(reqHeaders, etag, pathName)) {
            return new Response(null, {
              status: 304,
              headers
            });
          }
          headers["Etag"] = etag;
          headers["Cache-Control"] = directive;
          if (maxAge !== null)
            headers["Cache-Control"] += `, max-age=${maxAge}`;
          return new Response(file3, {
            headers
          });
        });
    }
  else {
    if (!app.router.history.find(({ method, path }) => path === `${prefix}/*` && method === "GET"))
      app.onError(() => {}).get(`${prefix}/*`, async ({ params, headers: reqHeaders }) => {
        let path = enableDecodeURI ? decodeURI(`${assets}/${decodeURI(params["*"])}`) : `${assets}/${params["*"]}`;
        if (isFSSepUnsafe) {
          path = path.replace(URL_PATH_SEP, sep);
        }
        if (shouldIgnore(path))
          throw new NotFoundError2;
        try {
          let status = statCache.get(path);
          if (!status) {
            status = await stat2(path);
            statCache.set(path, status);
          }
          if (!indexHTML && status.isDirectory())
            throw new NotFoundError2;
          let file3 = fileCache.get(path);
          if (!file3) {
            if (status.isDirectory()) {
              let hasCache = false;
              if (indexHTML && (hasCache = htmlCache.get(`${path}${sep}index.html`) ?? await fileExists(`${path}${sep}index.html`))) {
                if (hasCache === undefined)
                  htmlCache.set(`${path}${sep}index.html`, true);
                file3 = Bun.file(`${path}${sep}index.html`);
              } else {
                if (indexHTML && hasCache === undefined)
                  htmlCache.set(`${path}${sep}index.html`, false);
                throw new NotFoundError2;
              }
            }
            file3 ??= Bun.file(path);
            fileCache.set(path, file3);
          }
          if (noCache)
            return new Response(file3, {
              headers
            });
          const etag = await generateETag(file3);
          if (await isCached(reqHeaders, etag, path))
            return new Response(null, {
              status: 304,
              headers
            });
          headers["Etag"] = etag;
          headers["Cache-Control"] = directive;
          if (maxAge !== null)
            headers["Cache-Control"] += `, max-age=${maxAge}`;
          return new Response(file3, {
            headers
          });
        } catch (error3) {
          throw new NotFoundError2;
        }
      });
  }
  return app;
};

// server.ts
var import_dotenv4 = __toESM(require_main(), 1);
import { join as join5 } from "path";

// src/config/conn.ts
var import_pg = __toESM(require_lib2(), 1);
var import_config = __toESM(require_config(), 1);
var pool = new import_pg.Pool({
  user: process.env.DB_USER || "",
  password: process.env.DB_PASSWORD || "",
  host: process.env.DB_HOST || "",
  port: parseInt(process.env.DB_PORT || ""),
  database: process.env.DB_NAME || ""
});

// src/routes/routes.controllers.ts
var import_cookie2 = __toESM(require_cjs4(), 1);

// node_modules/jose/dist/node/esm/runtime/base64url.js
import { Buffer as Buffer2 } from "buffer";

// node_modules/jose/dist/node/esm/lib/buffer_utils.js
var encoder2 = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT322 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}

// node_modules/jose/dist/node/esm/runtime/base64url.js
var encode2;
function normalize(input) {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  return encoded;
}
if (Buffer2.isEncoding("base64url")) {
  encode2 = (input) => Buffer2.from(input).toString("base64url");
} else {
  encode2 = (input) => Buffer2.from(input).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
var decode3 = (input) => Buffer2.from(normalize(input), "base64");

// node_modules/jose/dist/node/esm/util/errors.js
class JOSEError extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message) {
    var _a;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === undefined || _a.call(Error, this, this.constructor);
  }
}

class JWTClaimValidationFailed extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JWTExpired extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JOSEAlgNotAllowed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}

class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
}
class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
}

class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
}
class JWSSignatureVerificationFailed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}

// node_modules/jose/dist/node/esm/runtime/is_key_object.js
import { KeyObject } from "crypto";
import * as util from "util";
var is_key_object_default = util.types.isKeyObject ? (obj) => util.types.isKeyObject(obj) : (obj) => obj != null && obj instanceof KeyObject;

// node_modules/jose/dist/node/esm/runtime/webcrypto.js
import * as crypto2 from "crypto";
import * as util2 from "util";
var webcrypto2 = crypto2.webcrypto;
var webcrypto_default = webcrypto2;
var isCryptoKey = util2.types.isCryptoKey ? (key) => util2.types.isCryptoKey(key) : (key) => false;

// node_modules/jose/dist/node/esm/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/jose/dist/node/esm/lib/invalid_key_input.js
function message(msg, actual, ...types3) {
  if (types3.length > 2) {
    const last = types3.pop();
    msg += `one of type ${types3.join(", ")}, or ${last}.`;
  } else if (types3.length === 2) {
    msg += `one of type ${types3[0]} or ${types3[1]}.`;
  } else {
    msg += `of type ${types3[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types3) => {
  return message("Key must be ", actual, ...types3);
};
function withAlg(alg, actual, ...types3) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types3);
}

// node_modules/jose/dist/node/esm/runtime/is_key_like.js
var is_key_like_default = (key) => is_key_object_default(key) || isCryptoKey(key);
var types3 = ["KeyObject"];
if (globalThis.CryptoKey || (webcrypto_default === null || webcrypto_default === undefined ? undefined : webcrypto_default.CryptoKey)) {
  types3.push("CryptoKey");
}

// node_modules/jose/dist/node/esm/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/jose/dist/node/esm/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject2(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/node/esm/runtime/get_named_curve.js
import { Buffer as Buffer3 } from "buffer";
import { createPublicKey, KeyObject as KeyObject2 } from "crypto";
var p256 = Buffer3.from([42, 134, 72, 206, 61, 3, 1, 7]);
var p384 = Buffer3.from([43, 129, 4, 0, 34]);
var p521 = Buffer3.from([43, 129, 4, 0, 35]);
var secp256k1 = Buffer3.from([43, 129, 4, 0, 10]);
var weakMap = new WeakMap;
var namedCurveToJOSE = (namedCurve) => {
  switch (namedCurve) {
    case "prime256v1":
      return "P-256";
    case "secp384r1":
      return "P-384";
    case "secp521r1":
      return "P-521";
    case "secp256k1":
      return "secp256k1";
    default:
      throw new JOSENotSupported("Unsupported key curve for this operation");
  }
};
var getNamedCurve2 = (kee, raw) => {
  var _a;
  let key;
  if (isCryptoKey(kee)) {
    key = KeyObject2.from(kee);
  } else if (is_key_object_default(kee)) {
    key = kee;
  } else {
    throw new TypeError(invalid_key_input_default(kee, ...types3));
  }
  if (key.type === "secret") {
    throw new TypeError('only "private" or "public" type keys can be used for this operation');
  }
  switch (key.asymmetricKeyType) {
    case "ed25519":
    case "ed448":
      return `Ed${key.asymmetricKeyType.slice(2)}`;
    case "x25519":
    case "x448":
      return `X${key.asymmetricKeyType.slice(1)}`;
    case "ec": {
      if (weakMap.has(key)) {
        return weakMap.get(key);
      }
      let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === undefined ? undefined : _a.namedCurve;
      if (!namedCurve && key.type === "private") {
        namedCurve = getNamedCurve2(createPublicKey(key), true);
      } else if (!namedCurve) {
        const buf = key.export({ format: "der", type: "spki" });
        const i = buf[1] < 128 ? 14 : 15;
        const len = buf[i];
        const curveOid = buf.slice(i + 1, i + 1 + len);
        if (curveOid.equals(p256)) {
          namedCurve = "prime256v1";
        } else if (curveOid.equals(p384)) {
          namedCurve = "secp384r1";
        } else if (curveOid.equals(p521)) {
          namedCurve = "secp521r1";
        } else if (curveOid.equals(secp256k1)) {
          namedCurve = "secp256k1";
        } else {
          throw new JOSENotSupported("Unsupported key curve for this operation");
        }
      }
      if (raw)
        return namedCurve;
      const curve = namedCurveToJOSE(namedCurve);
      weakMap.set(key, curve);
      return curve;
    }
    default:
      throw new TypeError("Invalid asymmetric key type for this operation");
  }
};
var get_named_curve_default = getNamedCurve2;

// node_modules/jose/dist/node/esm/runtime/check_modulus_length.js
var weakMap2 = new WeakMap;
var getLength = (buf, index) => {
  let len = buf.readUInt8(1);
  if ((len & 128) === 0) {
    if (index === 0) {
      return len;
    }
    return getLength(buf.subarray(2 + len), index - 1);
  }
  const num = len & 127;
  len = 0;
  for (let i = 0;i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(2 + i);
    len |= j;
  }
  if (index === 0) {
    return len;
  }
  return getLength(buf.subarray(2 + len), index - 1);
};
var getLengthOfSeqIndex = (sequence, index) => {
  const len = sequence.readUInt8(1);
  if ((len & 128) === 0) {
    return getLength(sequence.subarray(2), index);
  }
  const num = len & 127;
  return getLength(sequence.subarray(2 + num), index);
};
var getModulusLength = (key) => {
  var _a, _b;
  if (weakMap2.has(key)) {
    return weakMap2.get(key);
  }
  const modulusLength = (_b = (_a = key.asymmetricKeyDetails) === null || _a === undefined ? undefined : _a.modulusLength) !== null && _b !== undefined ? _b : getLengthOfSeqIndex(key.export({ format: "der", type: "pkcs1" }), key.type === "private" ? 1 : 0) - 1 << 3;
  weakMap2.set(key, modulusLength);
  return modulusLength;
};
var check_modulus_length_default = (key, alg) => {
  if (getModulusLength(key) < 2048) {
    throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
  }
};

// node_modules/jose/dist/node/esm/runtime/flags.js
var [major, minor] = process.versions.node.split(".").map((str) => parseInt(str, 10));
var oneShotCallback = major >= 16 || major === 15 && minor >= 13;
var rsaPssParams = !("electron" in process.versions) && (major >= 17 || major === 16 && minor >= 9);
var jwkExport = major >= 16 || major === 15 && minor >= 9;
var jwkImport = major >= 16 || major === 15 && minor >= 12;

// node_modules/jose/dist/node/esm/lib/check_key_type.js
var symmetricTypeCheck = (alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types3, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types3.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types3));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/jose/dist/node/esm/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// node_modules/jose/dist/node/esm/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/jose/dist/node/esm/runtime/verify.js
import * as crypto4 from "crypto";
import { promisify as promisify2 } from "util";

// node_modules/jose/dist/node/esm/runtime/dsa_digest.js
function dsaDigest(alg) {
  switch (alg) {
    case "PS256":
    case "RS256":
    case "ES256":
    case "ES256K":
      return "sha256";
    case "PS384":
    case "RS384":
    case "ES384":
      return "sha384";
    case "PS512":
    case "RS512":
    case "ES512":
      return "sha512";
    case "EdDSA":
      return;
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/node/esm/runtime/node_key.js
import { constants } from "crypto";
var PSS = {
  padding: constants.RSA_PKCS1_PSS_PADDING,
  saltLength: constants.RSA_PSS_SALTLEN_DIGEST
};
var ecCurveAlgMap = new Map([
  ["ES256", "P-256"],
  ["ES256K", "secp256k1"],
  ["ES384", "P-384"],
  ["ES512", "P-521"]
]);
function keyForCrypto(alg, key) {
  switch (alg) {
    case "EdDSA":
      if (!["ed25519", "ed448"].includes(key.asymmetricKeyType)) {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448");
      }
      return key;
    case "RS256":
    case "RS384":
    case "RS512":
      if (key.asymmetricKeyType !== "rsa") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
      }
      check_modulus_length_default(key, alg);
      return key;
    case (rsaPssParams && "PS256"):
    case (rsaPssParams && "PS384"):
    case (rsaPssParams && "PS512"):
      if (key.asymmetricKeyType === "rsa-pss") {
        const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
        const length = parseInt(alg.slice(-3), 10);
        if (hashAlgorithm !== undefined && (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
          throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
        }
        if (saltLength !== undefined && saltLength > length >> 3) {
          throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
        }
      } else if (key.asymmetricKeyType !== "rsa") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss");
      }
      check_modulus_length_default(key, alg);
      return { key, ...PSS };
    case (!rsaPssParams && "PS256"):
    case (!rsaPssParams && "PS384"):
    case (!rsaPssParams && "PS512"):
      if (key.asymmetricKeyType !== "rsa") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
      }
      check_modulus_length_default(key, alg);
      return { key, ...PSS };
    case "ES256":
    case "ES256K":
    case "ES384":
    case "ES512": {
      if (key.asymmetricKeyType !== "ec") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ec");
      }
      const actual = get_named_curve_default(key);
      const expected = ecCurveAlgMap.get(alg);
      if (actual !== expected) {
        throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
      }
      return { dsaEncoding: "ieee-p1363", key };
    }
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/node/esm/runtime/sign.js
import * as crypto3 from "crypto";
import { promisify } from "util";

// node_modules/jose/dist/node/esm/runtime/hmac_digest.js
function hmacDigest(alg) {
  switch (alg) {
    case "HS256":
      return "sha256";
    case "HS384":
      return "sha384";
    case "HS512":
      return "sha512";
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/node/esm/runtime/get_sign_verify_key.js
import { KeyObject as KeyObject3, createSecretKey } from "crypto";
function getSignVerifyKey(alg, key, usage) {
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types3));
    }
    return createSecretKey(key);
  }
  if (key instanceof KeyObject3) {
    return key;
  }
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return KeyObject3.from(key);
  }
  throw new TypeError(invalid_key_input_default(key, ...types3, "Uint8Array"));
}

// node_modules/jose/dist/node/esm/runtime/sign.js
var oneShotSign;
if (crypto3.sign.length > 3) {
  oneShotSign = promisify(crypto3.sign);
} else {
  oneShotSign = crypto3.sign;
}
var sign2 = async (alg, key, data) => {
  const keyObject = getSignVerifyKey(alg, key, "sign");
  if (alg.startsWith("HS")) {
    const hmac = crypto3.createHmac(hmacDigest(alg), keyObject);
    hmac.update(data);
    return hmac.digest();
  }
  return oneShotSign(dsaDigest(alg), data, keyForCrypto(alg, keyObject));
};
var sign_default = sign2;

// node_modules/jose/dist/node/esm/runtime/verify.js
var oneShotVerify;
if (crypto4.verify.length > 4 && oneShotCallback) {
  oneShotVerify = promisify2(crypto4.verify);
} else {
  oneShotVerify = crypto4.verify;
}
var verify2 = async (alg, key, signature, data) => {
  const keyObject = getSignVerifyKey(alg, key, "verify");
  if (alg.startsWith("HS")) {
    const expected = await sign_default(alg, keyObject, data);
    const actual = signature;
    try {
      return crypto4.timingSafeEqual(actual, expected);
    } catch {
      return false;
    }
  }
  const algorithm = dsaDigest(alg);
  const keyInput = keyForCrypto(alg, keyObject);
  try {
    return await oneShotVerify(algorithm, data, keyInput, signature);
  } catch {
    return false;
  }
};
var verify_default = verify2;

// node_modules/jose/dist/node/esm/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject2(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !isObject2(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode3(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder2.encode((_a = jws.protected) !== null && _a !== undefined ? _a : ""), encoder2.encode("."), typeof jws.payload === "string" ? encoder2.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode3(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode3(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder2.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== undefined) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}

// node_modules/jose/dist/node/esm/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/jose/dist/node/esm/lib/epoch.js
var epoch_default = (date2) => Math.floor(date2.getTime() / 1000);

// node_modules/jose/dist/node/esm/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
};

// node_modules/jose/dist/node/esm/lib/jwt_claims_set.js
var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {}
  if (!isObject2(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  if (maxTokenAge !== undefined)
    requiredClaims.push("iat");
  if (audience !== undefined)
    requiredClaims.push("aud");
  if (subject !== undefined)
    requiredClaims.push("sub");
  if (issuer !== undefined)
    requiredClaims.push("iss");
  for (const claim of new Set(requiredClaims.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  return payload;
};

// node_modules/jose/dist/node/esm/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === undefined ? undefined : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
// node_modules/jose/dist/node/esm/jws/flattened/sign.js
class FlattenedSign {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder2.encode(encode2(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder2.encode(encode2(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder2.encode("");
    }
    const data = concat(protectedHeader, encoder2.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode2(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
}

// node_modules/jose/dist/node/esm/jws/compact/sign.js
class CompactSign {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === undefined) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}

// node_modules/jose/dist/node/esm/jwt/produce.js
class ProduceJWT {
  constructor(payload) {
    if (!isObject2(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(new Date) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
}

// node_modules/jose/dist/node/esm/jwt/sign.js
class SignJWT extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a;
    const sig = new CompactSign(encoder2.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a = this._protectedHeader) === null || _a === undefined ? undefined : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
// node_modules/@elysiajs/jwt/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var value_exports = {};
__export2(value_exports, {
  HasPropertyKey: () => HasPropertyKey3,
  IsArray: () => IsArray5,
  IsAsyncIterator: () => IsAsyncIterator5,
  IsBigInt: () => IsBigInt5,
  IsBoolean: () => IsBoolean5,
  IsDate: () => IsDate5,
  IsFunction: () => IsFunction5,
  IsIterator: () => IsIterator5,
  IsNull: () => IsNull5,
  IsNumber: () => IsNumber5,
  IsObject: () => IsObject5,
  IsRegExp: () => IsRegExp4,
  IsString: () => IsString5,
  IsSymbol: () => IsSymbol5,
  IsUint8Array: () => IsUint8Array5,
  IsUndefined: () => IsUndefined5
});
function HasPropertyKey3(value, key) {
  return key in value;
}
function IsAsyncIterator5(value) {
  return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.asyncIterator in value;
}
function IsArray5(value) {
  return Array.isArray(value);
}
function IsBigInt5(value) {
  return typeof value === "bigint";
}
function IsBoolean5(value) {
  return typeof value === "boolean";
}
function IsDate5(value) {
  return value instanceof globalThis.Date;
}
function IsFunction5(value) {
  return typeof value === "function";
}
function IsIterator5(value) {
  return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.iterator in value;
}
function IsNull5(value) {
  return value === null;
}
function IsNumber5(value) {
  return typeof value === "number";
}
function IsObject5(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp4(value) {
  return value instanceof globalThis.RegExp;
}
function IsString5(value) {
  return typeof value === "string";
}
function IsSymbol5(value) {
  return typeof value === "symbol";
}
function IsUint8Array5(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined5(value) {
  return value === undefined;
}
function ArrayType6(value) {
  return value.map((value2) => Visit17(value2));
}
function DateType4(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType3(value) {
  return new Uint8Array(value);
}
function RegExpType2(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType6(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit17(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit17(value[key]);
  }
  return result;
}
function Visit17(value) {
  return IsArray5(value) ? ArrayType6(value) : IsDate5(value) ? DateType4(value) : IsUint8Array5(value) ? Uint8ArrayType3(value) : IsRegExp4(value) ? RegExpType2(value) : IsObject5(value) ? ObjectType6(value) : value;
}
function Clone3(value) {
  return Visit17(value);
}
function CloneType2(schema, options) {
  return options === undefined ? Clone3(schema) : Clone3({ ...options, ...schema });
}
function IsObject22(value) {
  return value !== null && typeof value === "object";
}
function IsArray22(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined22(value) {
  return value === undefined;
}
function IsNumber22(value) {
  return typeof value === "number";
}
var TypeSystemPolicy3;
(function(TypeSystemPolicy22) {
  TypeSystemPolicy22.InstanceMode = "default";
  TypeSystemPolicy22.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy22.AllowArrayObject = false;
  TypeSystemPolicy22.AllowNaN = false;
  TypeSystemPolicy22.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy22.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy22.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject3 = IsObject22(value);
    return TypeSystemPolicy22.AllowArrayObject ? isObject3 : isObject3 && !IsArray22(value);
  }
  TypeSystemPolicy22.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy22.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy22.AllowNaN ? IsNumber22(value) : Number.isFinite(value);
  }
  TypeSystemPolicy22.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined22(value);
    return TypeSystemPolicy22.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy22.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy3 || (TypeSystemPolicy3 = {}));
function ImmutableArray2(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable2(value2));
}
function ImmutableDate2(value) {
  return value;
}
function ImmutableUint8Array2(value) {
  return value;
}
function ImmutableRegExp2(value) {
  return value;
}
function ImmutableObject2(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable2(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable2(value) {
  return IsArray5(value) ? ImmutableArray2(value) : IsDate5(value) ? ImmutableDate2(value) : IsUint8Array5(value) ? ImmutableUint8Array2(value) : IsRegExp4(value) ? ImmutableRegExp2(value) : IsObject5(value) ? ImmutableObject2(value) : value;
}
function CreateType2(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy3.InstanceMode) {
    case "freeze":
      return Immutable2(result);
    case "clone":
      return Clone3(result);
    default:
      return result;
  }
}
var TypeBoxError2 = class extends Error {
  constructor(message2) {
    super(message2);
  }
};
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint2 = Symbol.for("TypeBox.Hint");
var Kind2 = Symbol.for("TypeBox.Kind");
function IsReadonly3(value) {
  return IsObject5(value) && value[ReadonlyKind2] === "Readonly";
}
function IsOptional3(value) {
  return IsObject5(value) && value[OptionalKind2] === "Optional";
}
function IsAny3(value) {
  return IsKindOf3(value, "Any");
}
function IsArray32(value) {
  return IsKindOf3(value, "Array");
}
function IsAsyncIterator22(value) {
  return IsKindOf3(value, "AsyncIterator");
}
function IsBigInt22(value) {
  return IsKindOf3(value, "BigInt");
}
function IsBoolean22(value) {
  return IsKindOf3(value, "Boolean");
}
function IsComputed3(value) {
  return IsKindOf3(value, "Computed");
}
function IsConstructor3(value) {
  return IsKindOf3(value, "Constructor");
}
function IsDate22(value) {
  return IsKindOf3(value, "Date");
}
function IsFunction22(value) {
  return IsKindOf3(value, "Function");
}
function IsInteger4(value) {
  return IsKindOf3(value, "Integer");
}
function IsIntersect3(value) {
  return IsKindOf3(value, "Intersect");
}
function IsIterator22(value) {
  return IsKindOf3(value, "Iterator");
}
function IsKindOf3(value, kind) {
  return IsObject5(value) && Kind2 in value && value[Kind2] === kind;
}
function IsLiteralValue3(value) {
  return IsBoolean5(value) || IsNumber5(value) || IsString5(value);
}
function IsLiteral3(value) {
  return IsKindOf3(value, "Literal");
}
function IsMappedKey3(value) {
  return IsKindOf3(value, "MappedKey");
}
function IsMappedResult3(value) {
  return IsKindOf3(value, "MappedResult");
}
function IsNever3(value) {
  return IsKindOf3(value, "Never");
}
function IsNot3(value) {
  return IsKindOf3(value, "Not");
}
function IsNull22(value) {
  return IsKindOf3(value, "Null");
}
function IsNumber32(value) {
  return IsKindOf3(value, "Number");
}
function IsObject32(value) {
  return IsKindOf3(value, "Object");
}
function IsPromise4(value) {
  return IsKindOf3(value, "Promise");
}
function IsRecord3(value) {
  return IsKindOf3(value, "Record");
}
function IsRef3(value) {
  return IsKindOf3(value, "Ref");
}
function IsRegExp22(value) {
  return IsKindOf3(value, "RegExp");
}
function IsString22(value) {
  return IsKindOf3(value, "String");
}
function IsSymbol22(value) {
  return IsKindOf3(value, "Symbol");
}
function IsTemplateLiteral3(value) {
  return IsKindOf3(value, "TemplateLiteral");
}
function IsThis3(value) {
  return IsKindOf3(value, "This");
}
function IsTransform3(value) {
  return IsObject5(value) && TransformKind2 in value;
}
function IsTuple3(value) {
  return IsKindOf3(value, "Tuple");
}
function IsUndefined32(value) {
  return IsKindOf3(value, "Undefined");
}
function IsUnion3(value) {
  return IsKindOf3(value, "Union");
}
function IsUint8Array22(value) {
  return IsKindOf3(value, "Uint8Array");
}
function IsUnknown3(value) {
  return IsKindOf3(value, "Unknown");
}
function IsUnsafe3(value) {
  return IsKindOf3(value, "Unsafe");
}
function IsVoid3(value) {
  return IsKindOf3(value, "Void");
}
function IsKind3(value) {
  return IsObject5(value) && Kind2 in value && IsString5(value[Kind2]);
}
function IsSchema3(value) {
  return IsAny3(value) || IsArray32(value) || IsBoolean22(value) || IsBigInt22(value) || IsAsyncIterator22(value) || IsComputed3(value) || IsConstructor3(value) || IsDate22(value) || IsFunction22(value) || IsInteger4(value) || IsIntersect3(value) || IsIterator22(value) || IsLiteral3(value) || IsMappedKey3(value) || IsMappedResult3(value) || IsNever3(value) || IsNot3(value) || IsNull22(value) || IsNumber32(value) || IsObject32(value) || IsPromise4(value) || IsRecord3(value) || IsRef3(value) || IsRegExp22(value) || IsString22(value) || IsSymbol22(value) || IsTemplateLiteral3(value) || IsThis3(value) || IsTuple3(value) || IsUndefined32(value) || IsUnion3(value) || IsUint8Array22(value) || IsUnknown3(value) || IsUnsafe3(value) || IsVoid3(value) || IsKind3(value);
}
var type_exports = {};
__export2(type_exports, {
  IsAny: () => IsAny22,
  IsArray: () => IsArray42,
  IsAsyncIterator: () => IsAsyncIterator32,
  IsBigInt: () => IsBigInt32,
  IsBoolean: () => IsBoolean32,
  IsComputed: () => IsComputed22,
  IsConstructor: () => IsConstructor22,
  IsDate: () => IsDate32,
  IsFunction: () => IsFunction32,
  IsImport: () => IsImport2,
  IsInteger: () => IsInteger22,
  IsIntersect: () => IsIntersect22,
  IsIterator: () => IsIterator32,
  IsKind: () => IsKind22,
  IsKindOf: () => IsKindOf22,
  IsLiteral: () => IsLiteral22,
  IsLiteralBoolean: () => IsLiteralBoolean2,
  IsLiteralNumber: () => IsLiteralNumber2,
  IsLiteralString: () => IsLiteralString2,
  IsLiteralValue: () => IsLiteralValue22,
  IsMappedKey: () => IsMappedKey22,
  IsMappedResult: () => IsMappedResult22,
  IsNever: () => IsNever22,
  IsNot: () => IsNot22,
  IsNull: () => IsNull32,
  IsNumber: () => IsNumber42,
  IsObject: () => IsObject42,
  IsOptional: () => IsOptional22,
  IsPromise: () => IsPromise22,
  IsProperties: () => IsProperties2,
  IsReadonly: () => IsReadonly22,
  IsRecord: () => IsRecord22,
  IsRecursive: () => IsRecursive2,
  IsRef: () => IsRef22,
  IsRegExp: () => IsRegExp32,
  IsSchema: () => IsSchema22,
  IsString: () => IsString32,
  IsSymbol: () => IsSymbol32,
  IsTemplateLiteral: () => IsTemplateLiteral22,
  IsThis: () => IsThis22,
  IsTransform: () => IsTransform22,
  IsTuple: () => IsTuple22,
  IsUint8Array: () => IsUint8Array32,
  IsUndefined: () => IsUndefined42,
  IsUnion: () => IsUnion22,
  IsUnionLiteral: () => IsUnionLiteral2,
  IsUnknown: () => IsUnknown22,
  IsUnsafe: () => IsUnsafe22,
  IsVoid: () => IsVoid22,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError2
});
var TypeGuardUnknownTypeError2 = class extends TypeBoxError2 {
};
var KnownTypes2 = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern2(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree2(value) {
  if (!IsString5(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties2(value) {
  return IsOptionalBoolean2(value) || IsSchema22(value);
}
function IsOptionalBigInt2(value) {
  return IsUndefined5(value) || IsBigInt5(value);
}
function IsOptionalNumber2(value) {
  return IsUndefined5(value) || IsNumber5(value);
}
function IsOptionalBoolean2(value) {
  return IsUndefined5(value) || IsBoolean5(value);
}
function IsOptionalString2(value) {
  return IsUndefined5(value) || IsString5(value);
}
function IsOptionalPattern2(value) {
  return IsUndefined5(value) || IsString5(value) && IsControlCharacterFree2(value) && IsPattern2(value);
}
function IsOptionalFormat2(value) {
  return IsUndefined5(value) || IsString5(value) && IsControlCharacterFree2(value);
}
function IsOptionalSchema2(value) {
  return IsUndefined5(value) || IsSchema22(value);
}
function IsReadonly22(value) {
  return IsObject5(value) && value[ReadonlyKind2] === "Readonly";
}
function IsOptional22(value) {
  return IsObject5(value) && value[OptionalKind2] === "Optional";
}
function IsAny22(value) {
  return IsKindOf22(value, "Any") && IsOptionalString2(value.$id);
}
function IsArray42(value) {
  return IsKindOf22(value, "Array") && value.type === "array" && IsOptionalString2(value.$id) && IsSchema22(value.items) && IsOptionalNumber2(value.minItems) && IsOptionalNumber2(value.maxItems) && IsOptionalBoolean2(value.uniqueItems) && IsOptionalSchema2(value.contains) && IsOptionalNumber2(value.minContains) && IsOptionalNumber2(value.maxContains);
}
function IsAsyncIterator32(value) {
  return IsKindOf22(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString2(value.$id) && IsSchema22(value.items);
}
function IsBigInt32(value) {
  return IsKindOf22(value, "BigInt") && value.type === "bigint" && IsOptionalString2(value.$id) && IsOptionalBigInt2(value.exclusiveMaximum) && IsOptionalBigInt2(value.exclusiveMinimum) && IsOptionalBigInt2(value.maximum) && IsOptionalBigInt2(value.minimum) && IsOptionalBigInt2(value.multipleOf);
}
function IsBoolean32(value) {
  return IsKindOf22(value, "Boolean") && value.type === "boolean" && IsOptionalString2(value.$id);
}
function IsComputed22(value) {
  return IsKindOf22(value, "Computed") && IsString5(value.target) && IsArray5(value.parameters) && value.parameters.every((schema) => IsSchema22(schema));
}
function IsConstructor22(value) {
  return IsKindOf22(value, "Constructor") && value.type === "Constructor" && IsOptionalString2(value.$id) && IsArray5(value.parameters) && value.parameters.every((schema) => IsSchema22(schema)) && IsSchema22(value.returns);
}
function IsDate32(value) {
  return IsKindOf22(value, "Date") && value.type === "Date" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximumTimestamp) && IsOptionalNumber2(value.exclusiveMinimumTimestamp) && IsOptionalNumber2(value.maximumTimestamp) && IsOptionalNumber2(value.minimumTimestamp) && IsOptionalNumber2(value.multipleOfTimestamp);
}
function IsFunction32(value) {
  return IsKindOf22(value, "Function") && value.type === "Function" && IsOptionalString2(value.$id) && IsArray5(value.parameters) && value.parameters.every((schema) => IsSchema22(schema)) && IsSchema22(value.returns);
}
function IsImport2(value) {
  return IsKindOf22(value, "Import") && HasPropertyKey3(value, "$defs") && IsObject5(value.$defs) && IsProperties2(value.$defs) && HasPropertyKey3(value, "$ref") && IsString5(value.$ref) && value.$ref in value.$defs;
}
function IsInteger22(value) {
  return IsKindOf22(value, "Integer") && value.type === "integer" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
}
function IsProperties2(value) {
  return IsObject5(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree2(key) && IsSchema22(schema));
}
function IsIntersect22(value) {
  return IsKindOf22(value, "Intersect") && (IsString5(value.type) && value.type !== "object" ? false : true) && IsArray5(value.allOf) && value.allOf.every((schema) => IsSchema22(schema) && !IsTransform22(schema)) && IsOptionalString2(value.type) && (IsOptionalBoolean2(value.unevaluatedProperties) || IsOptionalSchema2(value.unevaluatedProperties)) && IsOptionalString2(value.$id);
}
function IsIterator32(value) {
  return IsKindOf22(value, "Iterator") && value.type === "Iterator" && IsOptionalString2(value.$id) && IsSchema22(value.items);
}
function IsKindOf22(value, kind) {
  return IsObject5(value) && Kind2 in value && value[Kind2] === kind;
}
function IsLiteralString2(value) {
  return IsLiteral22(value) && IsString5(value.const);
}
function IsLiteralNumber2(value) {
  return IsLiteral22(value) && IsNumber5(value.const);
}
function IsLiteralBoolean2(value) {
  return IsLiteral22(value) && IsBoolean5(value.const);
}
function IsLiteral22(value) {
  return IsKindOf22(value, "Literal") && IsOptionalString2(value.$id) && IsLiteralValue22(value.const);
}
function IsLiteralValue22(value) {
  return IsBoolean5(value) || IsNumber5(value) || IsString5(value);
}
function IsMappedKey22(value) {
  return IsKindOf22(value, "MappedKey") && IsArray5(value.keys) && value.keys.every((key) => IsNumber5(key) || IsString5(key));
}
function IsMappedResult22(value) {
  return IsKindOf22(value, "MappedResult") && IsProperties2(value.properties);
}
function IsNever22(value) {
  return IsKindOf22(value, "Never") && IsObject5(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot22(value) {
  return IsKindOf22(value, "Not") && IsSchema22(value.not);
}
function IsNull32(value) {
  return IsKindOf22(value, "Null") && value.type === "null" && IsOptionalString2(value.$id);
}
function IsNumber42(value) {
  return IsKindOf22(value, "Number") && value.type === "number" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
}
function IsObject42(value) {
  return IsKindOf22(value, "Object") && value.type === "object" && IsOptionalString2(value.$id) && IsProperties2(value.properties) && IsAdditionalProperties2(value.additionalProperties) && IsOptionalNumber2(value.minProperties) && IsOptionalNumber2(value.maxProperties);
}
function IsPromise22(value) {
  return IsKindOf22(value, "Promise") && value.type === "Promise" && IsOptionalString2(value.$id) && IsSchema22(value.item);
}
function IsRecord22(value) {
  return IsKindOf22(value, "Record") && value.type === "object" && IsOptionalString2(value.$id) && IsAdditionalProperties2(value.additionalProperties) && IsObject5(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern2(keys[0]) && IsObject5(schema.patternProperties) && IsSchema22(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive2(value) {
  return IsObject5(value) && Hint2 in value && value[Hint2] === "Recursive";
}
function IsRef22(value) {
  return IsKindOf22(value, "Ref") && IsOptionalString2(value.$id) && IsString5(value.$ref);
}
function IsRegExp32(value) {
  return IsKindOf22(value, "RegExp") && IsOptionalString2(value.$id) && IsString5(value.source) && IsString5(value.flags) && IsOptionalNumber2(value.maxLength) && IsOptionalNumber2(value.minLength);
}
function IsString32(value) {
  return IsKindOf22(value, "String") && value.type === "string" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minLength) && IsOptionalNumber2(value.maxLength) && IsOptionalPattern2(value.pattern) && IsOptionalFormat2(value.format);
}
function IsSymbol32(value) {
  return IsKindOf22(value, "Symbol") && value.type === "symbol" && IsOptionalString2(value.$id);
}
function IsTemplateLiteral22(value) {
  return IsKindOf22(value, "TemplateLiteral") && value.type === "string" && IsString5(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis22(value) {
  return IsKindOf22(value, "This") && IsOptionalString2(value.$id) && IsString5(value.$ref);
}
function IsTransform22(value) {
  return IsObject5(value) && TransformKind2 in value;
}
function IsTuple22(value) {
  return IsKindOf22(value, "Tuple") && value.type === "array" && IsOptionalString2(value.$id) && IsNumber5(value.minItems) && IsNumber5(value.maxItems) && value.minItems === value.maxItems && (IsUndefined5(value.items) && IsUndefined5(value.additionalItems) && value.minItems === 0 || IsArray5(value.items) && value.items.every((schema) => IsSchema22(schema)));
}
function IsUndefined42(value) {
  return IsKindOf22(value, "Undefined") && value.type === "undefined" && IsOptionalString2(value.$id);
}
function IsUnionLiteral2(value) {
  return IsUnion22(value) && value.anyOf.every((schema) => IsLiteralString2(schema) || IsLiteralNumber2(schema));
}
function IsUnion22(value) {
  return IsKindOf22(value, "Union") && IsOptionalString2(value.$id) && IsObject5(value) && IsArray5(value.anyOf) && value.anyOf.every((schema) => IsSchema22(schema));
}
function IsUint8Array32(value) {
  return IsKindOf22(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minByteLength) && IsOptionalNumber2(value.maxByteLength);
}
function IsUnknown22(value) {
  return IsKindOf22(value, "Unknown") && IsOptionalString2(value.$id);
}
function IsUnsafe22(value) {
  return IsKindOf22(value, "Unsafe");
}
function IsVoid22(value) {
  return IsKindOf22(value, "Void") && value.type === "void" && IsOptionalString2(value.$id);
}
function IsKind22(value) {
  return IsObject5(value) && Kind2 in value && IsString5(value[Kind2]) && !KnownTypes2.includes(value[Kind2]);
}
function IsSchema22(value) {
  return IsObject5(value) && (IsAny22(value) || IsArray42(value) || IsBoolean32(value) || IsBigInt32(value) || IsAsyncIterator32(value) || IsComputed22(value) || IsConstructor22(value) || IsDate32(value) || IsFunction32(value) || IsInteger22(value) || IsIntersect22(value) || IsIterator32(value) || IsLiteral22(value) || IsMappedKey22(value) || IsMappedResult22(value) || IsNever22(value) || IsNot22(value) || IsNull32(value) || IsNumber42(value) || IsObject42(value) || IsPromise22(value) || IsRecord22(value) || IsRef22(value) || IsRegExp32(value) || IsString32(value) || IsSymbol32(value) || IsTemplateLiteral22(value) || IsThis22(value) || IsTuple22(value) || IsUndefined42(value) || IsUnion22(value) || IsUint8Array32(value) || IsUnknown22(value) || IsUnsafe22(value) || IsVoid22(value) || IsKind22(value));
}
var PatternBoolean2 = "(true|false)";
var PatternNumber2 = "(0|[1-9][0-9]*)";
var PatternString2 = "(.*)";
var PatternNever2 = "(?!.*)";
var PatternBooleanExact2 = `^${PatternBoolean2}$`;
var PatternNumberExact2 = `^${PatternNumber2}$`;
var PatternStringExact2 = `^${PatternString2}$`;
var PatternNeverExact2 = `^${PatternNever2}$`;
function SetIncludes2(T, S) {
  return T.includes(S);
}
function SetDistinct2(T) {
  return [...new Set(T)];
}
function SetIntersect2(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve2(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect2(Acc, L);
  }, Init);
}
function SetIntersectMany2(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve2(T.slice(1), T[0]) : [];
}
function SetUnionMany2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
function Any2(options) {
  return CreateType2({ [Kind2]: "Any" }, options);
}
function Array22(items, options) {
  return CreateType2({ [Kind2]: "Array", type: "array", items }, options);
}
function AsyncIterator2(items, options) {
  return CreateType2({ [Kind2]: "AsyncIterator", type: "AsyncIterator", items }, options);
}
function Computed2(target, parameters, options) {
  return CreateType2({ [Kind2]: "Computed", target, parameters }, options);
}
function DiscardKey2(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard2(value, keys) {
  return keys.reduce((acc, key) => DiscardKey2(acc, key), value);
}
function Never2(options) {
  return CreateType2({ [Kind2]: "Never", not: {} }, options);
}
function MappedResult2(properties) {
  return CreateType2({
    [Kind2]: "MappedResult",
    properties
  });
}
function Constructor2(parameters, returns, options) {
  return CreateType2({ [Kind2]: "Constructor", type: "Constructor", parameters, returns }, options);
}
function Function3(parameters, returns, options) {
  return CreateType2({ [Kind2]: "Function", type: "Function", parameters, returns }, options);
}
function UnionCreate2(T, options) {
  return CreateType2({ [Kind2]: "Union", anyOf: T }, options);
}
function IsUnionOptional2(types4) {
  return types4.some((type2) => IsOptional3(type2));
}
function RemoveOptionalFromRest3(types4) {
  return types4.map((left) => IsOptional3(left) ? RemoveOptionalFromType3(left) : left);
}
function RemoveOptionalFromType3(T) {
  return Discard2(T, [OptionalKind2]);
}
function ResolveUnion2(types4, options) {
  const isOptional2 = IsUnionOptional2(types4);
  return isOptional2 ? Optional2(UnionCreate2(RemoveOptionalFromRest3(types4), options)) : UnionCreate2(RemoveOptionalFromRest3(types4), options);
}
function UnionEvaluated2(T, options) {
  return T.length === 1 ? CreateType2(T[0], options) : T.length === 0 ? Never2(options) : ResolveUnion2(T, options);
}
function Union3(types4, options) {
  return types4.length === 0 ? Never2(options) : types4.length === 1 ? CreateType2(types4[0], options) : UnionCreate2(types4, options);
}
var TemplateLiteralParserError2 = class extends TypeBoxError2 {
};
function Unescape2(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped2(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen2(pattern, index) {
  return IsNonEscaped2(pattern, index, "(");
}
function IsCloseParen2(pattern, index) {
  return IsNonEscaped2(pattern, index, ")");
}
function IsSeparator2(pattern, index) {
  return IsNonEscaped2(pattern, index, "|");
}
function IsGroup2(pattern) {
  if (!(IsOpenParen2(pattern, 0) && IsCloseParen2(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      count += 1;
    if (IsCloseParen2(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup2(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr2(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      count += 1;
    if (IsCloseParen2(pattern, index))
      count -= 1;
    if (IsSeparator2(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd2(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      return true;
  }
  return false;
}
function Or2(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      count += 1;
    if (IsCloseParen2(pattern, index))
      count -= 1;
    if (IsSeparator2(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse2(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse2(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And2(pattern) {
  function Group(value, index) {
    if (!IsOpenParen2(value, index))
      throw new TemplateLiteralParserError2(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen2(value, scan))
        count += 1;
      if (IsCloseParen2(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError2(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen2(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse2(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse2(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse2(pattern) {
  return IsGroup2(pattern) ? TemplateLiteralParse2(InGroup2(pattern)) : IsPrecedenceOr2(pattern) ? Or2(pattern) : IsPrecedenceAnd2(pattern) ? And2(pattern) : { type: "const", const: Unescape2(pattern) };
}
function TemplateLiteralParseExact2(pattern) {
  return TemplateLiteralParse2(pattern.slice(1, pattern.length - 1));
}
var TemplateLiteralFiniteError2 = class extends TypeBoxError2 {
};
function IsNumberExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression2(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite2(expression) {
  return IsNumberExpression2(expression) || IsStringExpression2(expression) ? false : IsBooleanExpression2(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError2(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite2(schema) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  return IsTemplateLiteralExpressionFinite2(expression);
}
var TemplateLiteralGenerateError2 = class extends TypeBoxError2 {
};
function* GenerateReduce2(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce2(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd2(expression) {
  return yield* GenerateReduce2(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate2(expr)]));
}
function* GenerateOr2(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate2(expr);
}
function* GenerateConst2(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate2(expression) {
  return expression.type === "and" ? yield* GenerateAnd2(expression) : expression.type === "or" ? yield* GenerateOr2(expression) : expression.type === "const" ? yield* GenerateConst2(expression) : (() => {
    throw new TemplateLiteralGenerateError2("Unknown expression");
  })();
}
function TemplateLiteralGenerate2(schema) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  return IsTemplateLiteralExpressionFinite2(expression) ? [...TemplateLiteralExpressionGenerate2(expression)] : [];
}
function Literal2(value, options) {
  return CreateType2({
    [Kind2]: "Literal",
    const: value,
    type: typeof value
  }, options);
}
function Boolean3(options) {
  return CreateType2({ [Kind2]: "Boolean", type: "boolean" }, options);
}
function BigInt3(options) {
  return CreateType2({ [Kind2]: "BigInt", type: "bigint" }, options);
}
function Number22(options) {
  return CreateType2({ [Kind2]: "Number", type: "number" }, options);
}
function String3(options) {
  return CreateType2({ [Kind2]: "String", type: "string" }, options);
}
function* FromUnion21(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean3() : trim === "number" ? yield Number22() : trim === "bigint" ? yield BigInt3() : trim === "string" ? yield String3() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal2(literal.trim()));
    return literals.length === 0 ? Never2() : literals.length === 1 ? literals[0] : UnionEvaluated2(literals);
  })();
}
function* FromTerminal2(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal2("$");
    const R = FromSyntax2(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion21(syntax.slice(2, i));
      const R = FromSyntax2(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal2(syntax);
}
function* FromSyntax2(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal2(syntax.slice(0, i));
      const R = FromTerminal2(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal2(syntax);
}
function TemplateLiteralSyntax2(syntax) {
  return [...FromSyntax2(syntax)];
}
var TemplateLiteralPatternError2 = class extends TypeBoxError2 {
};
function Escape3(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit22(schema, acc) {
  return IsTemplateLiteral3(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion3(schema) ? `(${schema.anyOf.map((schema2) => Visit22(schema2, acc)).join("|")})` : IsNumber32(schema) ? `${acc}${PatternNumber2}` : IsInteger4(schema) ? `${acc}${PatternNumber2}` : IsBigInt22(schema) ? `${acc}${PatternNumber2}` : IsString22(schema) ? `${acc}${PatternString2}` : IsLiteral3(schema) ? `${acc}${Escape3(schema.const.toString())}` : IsBoolean22(schema) ? `${acc}${PatternBoolean2}` : (() => {
    throw new TemplateLiteralPatternError2(`Unexpected Kind '${schema[Kind2]}'`);
  })();
}
function TemplateLiteralPattern2(kinds) {
  return `^${kinds.map((schema) => Visit22(schema, "")).join("")}$`;
}
function TemplateLiteralToUnion2(schema) {
  const R = TemplateLiteralGenerate2(schema);
  const L = R.map((S) => Literal2(S));
  return UnionEvaluated2(L);
}
function TemplateLiteral2(unresolved, options) {
  const pattern = IsString5(unresolved) ? TemplateLiteralPattern2(TemplateLiteralSyntax2(unresolved)) : TemplateLiteralPattern2(unresolved);
  return CreateType2({ [Kind2]: "TemplateLiteral", type: "string", pattern }, options);
}
function FromTemplateLiteral7(templateLiteral) {
  const keys = TemplateLiteralGenerate2(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion22(types4) {
  const result = [];
  for (const type2 of types4)
    result.push(...IndexPropertyKeys2(type2));
  return result;
}
function FromLiteral7(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys2(type2) {
  return [...new Set(IsTemplateLiteral3(type2) ? FromTemplateLiteral7(type2) : IsUnion3(type2) ? FromUnion22(type2.anyOf) : IsLiteral3(type2) ? FromLiteral7(type2.const) : IsNumber32(type2) ? ["[number]"] : IsInteger4(type2) ? ["[number]"] : [])];
}
function FromProperties20(type2, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index2(type2, IndexPropertyKeys2(properties[K2]), options);
  }
  return result;
}
function FromMappedResult13(type2, mappedResult, options) {
  return FromProperties20(type2, mappedResult.properties, options);
}
function IndexFromMappedResult2(type2, mappedResult, options) {
  const properties = FromMappedResult13(type2, mappedResult, options);
  return MappedResult2(properties);
}
function FromRest8(types4, key) {
  return types4.map((type2) => IndexFromPropertyKey2(type2, key));
}
function FromIntersectRest2(types4) {
  return types4.filter((type2) => !IsNever3(type2));
}
function FromIntersect19(types4, key) {
  return IntersectEvaluated2(FromIntersectRest2(FromRest8(types4, key)));
}
function FromUnionRest2(types4) {
  return types4.some((L) => IsNever3(L)) ? [] : types4;
}
function FromUnion32(types4, key) {
  return UnionEvaluated2(FromUnionRest2(FromRest8(types4, key)));
}
function FromTuple16(types4, key) {
  return key in types4 ? types4[key] : key === "[number]" ? UnionEvaluated2(types4) : Never2();
}
function FromArray18(type2, key) {
  return key === "[number]" ? type2 : Never2();
}
function FromProperty4(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never2();
}
function IndexFromPropertyKey2(type2, propertyKey) {
  return IsIntersect3(type2) ? FromIntersect19(type2.allOf, propertyKey) : IsUnion3(type2) ? FromUnion32(type2.anyOf, propertyKey) : IsTuple3(type2) ? FromTuple16(type2.items ?? [], propertyKey) : IsArray32(type2) ? FromArray18(type2.items, propertyKey) : IsObject32(type2) ? FromProperty4(type2.properties, propertyKey) : Never2();
}
function IndexFromPropertyKeys2(type2, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey2(type2, propertyKey));
}
function FromSchema2(type2, propertyKeys) {
  return UnionEvaluated2(IndexFromPropertyKeys2(type2, propertyKeys));
}
function Index2(type2, key, options) {
  if (IsRef3(type2) || IsRef3(key)) {
    const error3 = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema3(type2) || !IsSchema3(key))
      throw new TypeBoxError2(error3);
    return Computed2("Index", [type2, key]);
  }
  if (IsMappedResult3(key))
    return IndexFromMappedResult2(type2, key, options);
  if (IsMappedKey3(key))
    return IndexFromMappedKey2(type2, key, options);
  return CreateType2(IsSchema3(key) ? FromSchema2(type2, IndexPropertyKeys2(key)) : FromSchema2(type2, key), options);
}
function MappedIndexPropertyKey2(type2, key, options) {
  return { [key]: Index2(type2, [key], Clone3(options)) };
}
function MappedIndexPropertyKeys2(type2, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey2(type2, left, options) };
  }, {});
}
function MappedIndexProperties2(type2, mappedKey, options) {
  return MappedIndexPropertyKeys2(type2, mappedKey.keys, options);
}
function IndexFromMappedKey2(type2, mappedKey, options) {
  const properties = MappedIndexProperties2(type2, mappedKey, options);
  return MappedResult2(properties);
}
function Iterator2(items, options) {
  return CreateType2({ [Kind2]: "Iterator", type: "Iterator", items }, options);
}
function RequiredKeys2(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional3(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object2(properties, options) {
  const required = RequiredKeys2(properties);
  const schematic = required.length > 0 ? { [Kind2]: "Object", type: "object", properties, required } : { [Kind2]: "Object", type: "object", properties };
  return CreateType2(schematic, options);
}
var Object22 = _Object2;
function Promise22(item, options) {
  return CreateType2({ [Kind2]: "Promise", type: "Promise", item }, options);
}
function RemoveReadonly2(schema) {
  return CreateType2(Discard2(schema, [ReadonlyKind2]));
}
function AddReadonly2(schema) {
  return CreateType2({ ...schema, [ReadonlyKind2]: "Readonly" });
}
function ReadonlyWithFlag2(schema, F) {
  return F === false ? RemoveReadonly2(schema) : AddReadonly2(schema);
}
function Readonly2(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult3(schema) ? ReadonlyFromMappedResult2(schema, F) : ReadonlyWithFlag2(schema, F);
}
function FromProperties22(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly2(K[K2], F);
  return Acc;
}
function FromMappedResult22(R, F) {
  return FromProperties22(R.properties, F);
}
function ReadonlyFromMappedResult2(R, F) {
  const P = FromMappedResult22(R, F);
  return MappedResult2(P);
}
function Tuple2(types4, options) {
  return CreateType2(types4.length > 0 ? { [Kind2]: "Tuple", type: "array", items: types4, additionalItems: false, minItems: types4.length, maxItems: types4.length } : { [Kind2]: "Tuple", type: "array", minItems: types4.length, maxItems: types4.length }, options);
}
function FromMappedResult32(K, P) {
  return K in P ? FromSchemaType2(K, P[K]) : MappedResult2(P);
}
function MappedKeyToKnownMappedResultProperties2(K) {
  return { [K]: Literal2(K) };
}
function MappedKeyToUnknownMappedResultProperties2(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal2(L);
  return Acc;
}
function MappedKeyToMappedResultProperties2(K, P) {
  return SetIncludes2(P, K) ? MappedKeyToKnownMappedResultProperties2(K) : MappedKeyToUnknownMappedResultProperties2(P);
}
function FromMappedKey5(K, P) {
  const R = MappedKeyToMappedResultProperties2(K, P);
  return FromMappedResult32(K, R);
}
function FromRest22(K, T) {
  return T.map((L) => FromSchemaType2(K, L));
}
function FromProperties32(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType2(K, T[K2]);
  return Acc;
}
function FromSchemaType2(K, T) {
  const options = { ...T };
  return IsOptional3(T) ? Optional2(FromSchemaType2(K, Discard2(T, [OptionalKind2]))) : IsReadonly3(T) ? Readonly2(FromSchemaType2(K, Discard2(T, [ReadonlyKind2]))) : IsMappedResult3(T) ? FromMappedResult32(K, T.properties) : IsMappedKey3(T) ? FromMappedKey5(K, T.keys) : IsConstructor3(T) ? Constructor2(FromRest22(K, T.parameters), FromSchemaType2(K, T.returns), options) : IsFunction22(T) ? Function3(FromRest22(K, T.parameters), FromSchemaType2(K, T.returns), options) : IsAsyncIterator22(T) ? AsyncIterator2(FromSchemaType2(K, T.items), options) : IsIterator22(T) ? Iterator2(FromSchemaType2(K, T.items), options) : IsIntersect3(T) ? Intersect3(FromRest22(K, T.allOf), options) : IsUnion3(T) ? Union3(FromRest22(K, T.anyOf), options) : IsTuple3(T) ? Tuple2(FromRest22(K, T.items ?? []), options) : IsObject32(T) ? Object22(FromProperties32(K, T.properties), options) : IsArray32(T) ? Array22(FromSchemaType2(K, T.items), options) : IsPromise4(T) ? Promise22(FromSchemaType2(K, T.item), options) : T;
}
function MappedFunctionReturnType2(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType2(L, T);
  return Acc;
}
function Mapped2(key, map3, options) {
  const K = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const RT = map3({ [Kind2]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType2(K, RT);
  return Object22(R, options);
}
function RemoveOptional2(schema) {
  return CreateType2(Discard2(schema, [OptionalKind2]));
}
function AddOptional2(schema) {
  return CreateType2({ ...schema, [OptionalKind2]: "Optional" });
}
function OptionalWithFlag2(schema, F) {
  return F === false ? RemoveOptional2(schema) : AddOptional2(schema);
}
function Optional2(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult3(schema) ? OptionalFromMappedResult2(schema, F) : OptionalWithFlag2(schema, F);
}
function FromProperties42(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional2(P[K2], F);
  return Acc;
}
function FromMappedResult42(R, F) {
  return FromProperties42(R.properties, F);
}
function OptionalFromMappedResult2(R, F) {
  const P = FromMappedResult42(R, F);
  return MappedResult2(P);
}
function IntersectCreate2(T, options = {}) {
  const allObjects = T.every((schema) => IsObject32(schema));
  const clonedUnevaluatedProperties = IsSchema3(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType2(options.unevaluatedProperties === false || IsSchema3(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind2]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind2]: "Intersect", allOf: T }, options);
}
function IsIntersectOptional2(types4) {
  return types4.every((left) => IsOptional3(left));
}
function RemoveOptionalFromType22(type2) {
  return Discard2(type2, [OptionalKind2]);
}
function RemoveOptionalFromRest22(types4) {
  return types4.map((left) => IsOptional3(left) ? RemoveOptionalFromType22(left) : left);
}
function ResolveIntersect2(types4, options) {
  return IsIntersectOptional2(types4) ? Optional2(IntersectCreate2(RemoveOptionalFromRest22(types4), options)) : IntersectCreate2(RemoveOptionalFromRest22(types4), options);
}
function IntersectEvaluated2(types4, options = {}) {
  if (types4.length === 1)
    return CreateType2(types4[0], options);
  if (types4.length === 0)
    return Never2(options);
  if (types4.some((schema) => IsTransform3(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect2(types4, options);
}
function Intersect3(types4, options) {
  if (types4.length === 1)
    return CreateType2(types4[0], options);
  if (types4.length === 0)
    return Never2(options);
  if (types4.some((schema) => IsTransform3(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate2(types4, options);
}
function Ref2(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError2("Ref: $ref must be a string");
  return CreateType2({ [Kind2]: "Ref", $ref }, options);
}
function FromComputed6(target, parameters) {
  return Computed2("Awaited", [Computed2(target, parameters)]);
}
function FromRef15($ref) {
  return Computed2("Awaited", [Ref2($ref)]);
}
function FromIntersect22(types4) {
  return Intersect3(FromRest32(types4));
}
function FromUnion42(types4) {
  return Union3(FromRest32(types4));
}
function FromPromise8(type2) {
  return Awaited2(type2);
}
function FromRest32(types4) {
  return types4.map((type2) => Awaited2(type2));
}
function Awaited2(type2, options) {
  return CreateType2(IsComputed3(type2) ? FromComputed6(type2.target, type2.parameters) : IsIntersect3(type2) ? FromIntersect22(type2.allOf) : IsUnion3(type2) ? FromUnion42(type2.anyOf) : IsPromise4(type2) ? FromPromise8(type2.item) : IsRef3(type2) ? FromRef15(type2.$ref) : type2, options);
}
function FromRest42(types4) {
  const result = [];
  for (const L of types4)
    result.push(KeyOfPropertyKeys2(L));
  return result;
}
function FromIntersect32(types4) {
  const propertyKeysArray = FromRest42(types4);
  const propertyKeys = SetUnionMany2(propertyKeysArray);
  return propertyKeys;
}
function FromUnion52(types4) {
  const propertyKeysArray = FromRest42(types4);
  const propertyKeys = SetIntersectMany2(propertyKeysArray);
  return propertyKeys;
}
function FromTuple22(types4) {
  return types4.map((_, indexer) => indexer.toString());
}
function FromArray22(_) {
  return ["[number]"];
}
function FromProperties52(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties2(patternProperties) {
  if (!includePatternProperties2)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys2(type2) {
  return IsIntersect3(type2) ? FromIntersect32(type2.allOf) : IsUnion3(type2) ? FromUnion52(type2.anyOf) : IsTuple3(type2) ? FromTuple22(type2.items ?? []) : IsArray32(type2) ? FromArray22(type2.items) : IsObject32(type2) ? FromProperties52(type2.properties) : IsRecord3(type2) ? FromPatternProperties2(type2.patternProperties) : [];
}
var includePatternProperties2 = false;
function FromComputed22(target, parameters) {
  return Computed2("KeyOf", [Computed2(target, parameters)]);
}
function FromRef22($ref) {
  return Computed2("KeyOf", [Ref2($ref)]);
}
function KeyOfFromType2(type2, options) {
  const propertyKeys = KeyOfPropertyKeys2(type2);
  const propertyKeyTypes = KeyOfPropertyKeysToRest2(propertyKeys);
  const result = UnionEvaluated2(propertyKeyTypes);
  return CreateType2(result, options);
}
function KeyOfPropertyKeysToRest2(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number22() : Literal2(L));
}
function KeyOf2(type2, options) {
  return IsComputed3(type2) ? FromComputed22(type2.target, type2.parameters) : IsRef3(type2) ? FromRef22(type2.$ref) : IsMappedResult3(type2) ? KeyOfFromMappedResult2(type2, options) : KeyOfFromType2(type2, options);
}
function FromProperties62(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf2(properties[K2], Clone3(options));
  return result;
}
function FromMappedResult52(mappedResult, options) {
  return FromProperties62(mappedResult.properties, options);
}
function KeyOfFromMappedResult2(mappedResult, options) {
  const properties = FromMappedResult52(mappedResult, options);
  return MappedResult2(properties);
}
function CompositeKeys2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys2(L));
  return SetDistinct2(Acc);
}
function FilterNever2(T) {
  return T.filter((L) => !IsNever3(L));
}
function CompositeProperty2(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys2(L, [K]));
  return FilterNever2(Acc);
}
function CompositeProperties2(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated2(CompositeProperty2(T, L));
  }
  return Acc;
}
function Composite2(T, options) {
  const K = CompositeKeys2(T);
  const P = CompositeProperties2(T, K);
  const R = Object22(P, options);
  return R;
}
function Date22(options) {
  return CreateType2({ [Kind2]: "Date", type: "Date" }, options);
}
function Null2(options) {
  return CreateType2({ [Kind2]: "Null", type: "null" }, options);
}
function Symbol22(options) {
  return CreateType2({ [Kind2]: "Symbol", type: "symbol" }, options);
}
function Undefined2(options) {
  return CreateType2({ [Kind2]: "Undefined", type: "undefined" }, options);
}
function Uint8Array22(options) {
  return CreateType2({ [Kind2]: "Uint8Array", type: "Uint8Array" }, options);
}
function Unknown2(options) {
  return CreateType2({ [Kind2]: "Unknown" }, options);
}
function FromArray32(T) {
  return T.map((L) => FromValue3(L, false));
}
function FromProperties72(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly2(FromValue3(value[K], false));
  return Acc;
}
function ConditionalReadonly2(T, root) {
  return root === true ? T : Readonly2(T);
}
function FromValue3(value, root) {
  return IsAsyncIterator5(value) ? ConditionalReadonly2(Any2(), root) : IsIterator5(value) ? ConditionalReadonly2(Any2(), root) : IsArray5(value) ? Readonly2(Tuple2(FromArray32(value))) : IsUint8Array5(value) ? Uint8Array22() : IsDate5(value) ? Date22() : IsObject5(value) ? ConditionalReadonly2(Object22(FromProperties72(value)), root) : IsFunction5(value) ? ConditionalReadonly2(Function3([], Unknown2()), root) : IsUndefined5(value) ? Undefined2() : IsNull5(value) ? Null2() : IsSymbol5(value) ? Symbol22() : IsBigInt5(value) ? BigInt3() : IsNumber5(value) ? Literal2(value) : IsBoolean5(value) ? Literal2(value) : IsString5(value) ? Literal2(value) : Object22({});
}
function Const2(T, options) {
  return CreateType2(FromValue3(T, true), options);
}
function ConstructorParameters2(schema, options) {
  return Tuple2(schema.parameters, options);
}
function Enum2(item, options) {
  if (IsUndefined5(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal2(value));
  return Union3(anyOf, { ...options, [Hint2]: "Enum" });
}
var ExtendsResolverError2 = class extends TypeBoxError2 {
};
var ExtendsResult2;
(function(ExtendsResult22) {
  ExtendsResult22[ExtendsResult22["Union"] = 0] = "Union";
  ExtendsResult22[ExtendsResult22["True"] = 1] = "True";
  ExtendsResult22[ExtendsResult22["False"] = 2] = "False";
})(ExtendsResult2 || (ExtendsResult2 = {}));
function IntoBooleanResult2(result) {
  return result === ExtendsResult2.False ? result : ExtendsResult2.True;
}
function Throw2(message2) {
  throw new ExtendsResolverError2(message2);
}
function IsStructuralRight2(right) {
  return type_exports.IsNever(right) || type_exports.IsIntersect(right) || type_exports.IsUnion(right) || type_exports.IsUnknown(right) || type_exports.IsAny(right);
}
function StructuralRight2(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight2(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) ? FromUnionRight2(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight2(left, right) : type_exports.IsAny(right) ? FromAnyRight2(left, right) : Throw2("StructuralRight");
}
function FromAnyRight2(left, right) {
  return ExtendsResult2.True;
}
function FromAny5(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) && right.anyOf.some((schema) => type_exports.IsAny(schema) || type_exports.IsUnknown(schema)) ? ExtendsResult2.True : type_exports.IsUnion(right) ? ExtendsResult2.Union : type_exports.IsUnknown(right) ? ExtendsResult2.True : type_exports.IsAny(right) ? ExtendsResult2.True : ExtendsResult2.Union;
}
function FromArrayRight2(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult2.False : type_exports.IsAny(left) ? ExtendsResult2.Union : type_exports.IsNever(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromArray42(left, right) {
  return type_exports.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : !type_exports.IsArray(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.items, right.items));
}
function FromAsyncIterator8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !type_exports.IsAsyncIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.items, right.items));
}
function FromBigInt6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsBigInt(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromBooleanRight2(left, right) {
  return type_exports.IsLiteralBoolean(left) ? ExtendsResult2.True : type_exports.IsBoolean(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromBoolean6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsBoolean(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromConstructor9(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : !type_exports.IsConstructor(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit32(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.returns, right.returns));
}
function FromDate8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsDate(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromFunction8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : !type_exports.IsFunction(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit32(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.returns, right.returns));
}
function FromIntegerRight2(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsNumber(left.const) ? ExtendsResult2.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromInteger6(left, right) {
  return type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : ExtendsResult2.False;
}
function FromIntersectRight2(left, right) {
  return right.allOf.every((schema) => Visit32(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromIntersect42(left, right) {
  return left.allOf.some((schema) => Visit32(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromIterator8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !type_exports.IsIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.items, right.items));
}
function FromLiteral22(left, right) {
  return type_exports.IsLiteral(right) && right.const === left.const ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsString(right) ? FromStringRight2(left, right) : type_exports.IsNumber(right) ? FromNumberRight2(left, right) : type_exports.IsInteger(right) ? FromIntegerRight2(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight2(left, right) : ExtendsResult2.False;
}
function FromNeverRight2(left, right) {
  return ExtendsResult2.False;
}
function FromNever6(left, right) {
  return ExtendsResult2.True;
}
function UnwrapTNot2(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!type_exports.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown2();
}
function FromNot8(left, right) {
  return type_exports.IsNot(left) ? Visit32(UnwrapTNot2(left), right) : type_exports.IsNot(right) ? Visit32(left, UnwrapTNot2(right)) : Throw2("Invalid fallthrough for Not");
}
function FromNull6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsNull(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromNumberRight2(left, right) {
  return type_exports.IsLiteralNumber(left) ? ExtendsResult2.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromNumber6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function IsObjectPropertyCount2(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike2(schema) {
  return IsObjectArrayLike2(schema);
}
function IsObjectSymbolLike2(schema) {
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "description" in schema.properties && type_exports.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (type_exports.IsString(schema.properties.description.anyOf[0]) && type_exports.IsUndefined(schema.properties.description.anyOf[1]) || type_exports.IsString(schema.properties.description.anyOf[1]) && type_exports.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectBooleanLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectBigIntLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectDateLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectUint8ArrayLike2(schema) {
  return IsObjectArrayLike2(schema);
}
function IsObjectFunctionLike2(schema) {
  const length = Number22();
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit32(schema.properties["length"], length)) === ExtendsResult2.True;
}
function IsObjectConstructorLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectArrayLike2(schema) {
  const length = Number22();
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit32(schema.properties["length"], length)) === ExtendsResult2.True;
}
function IsObjectPromiseLike2(schema) {
  const then = Function3([Any2()], Any2());
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "then" in schema.properties && IntoBooleanResult2(Visit32(schema.properties["then"], then)) === ExtendsResult2.True;
}
function Property2(left, right) {
  return Visit32(left, right) === ExtendsResult2.False ? ExtendsResult2.False : type_exports.IsOptional(left) && !type_exports.IsOptional(right) ? ExtendsResult2.False : ExtendsResult2.True;
}
function FromObjectRight2(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult2.False : type_exports.IsAny(left) ? ExtendsResult2.Union : type_exports.IsNever(left) || type_exports.IsLiteralString(left) && IsObjectStringLike2(right) || type_exports.IsLiteralNumber(left) && IsObjectNumberLike2(right) || type_exports.IsLiteralBoolean(left) && IsObjectBooleanLike2(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike2(right) || type_exports.IsBigInt(left) && IsObjectBigIntLike2(right) || type_exports.IsString(left) && IsObjectStringLike2(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike2(right) || type_exports.IsNumber(left) && IsObjectNumberLike2(right) || type_exports.IsInteger(left) && IsObjectNumberLike2(right) || type_exports.IsBoolean(left) && IsObjectBooleanLike2(right) || type_exports.IsUint8Array(left) && IsObjectUint8ArrayLike2(right) || type_exports.IsDate(left) && IsObjectDateLike2(right) || type_exports.IsConstructor(left) && IsObjectConstructorLike2(right) || type_exports.IsFunction(left) && IsObjectFunctionLike2(right) ? ExtendsResult2.True : type_exports.IsRecord(left) && type_exports.IsString(RecordKey3(left)) ? (() => {
    return right[Hint2] === "Record" ? ExtendsResult2.True : ExtendsResult2.False;
  })() : type_exports.IsRecord(left) && type_exports.IsNumber(RecordKey3(left)) ? (() => {
    return IsObjectPropertyCount2(right, 0) ? ExtendsResult2.True : ExtendsResult2.False;
  })() : ExtendsResult2.False;
}
function FromObject19(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : !type_exports.IsObject(right) ? ExtendsResult2.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult2.False;
      }
      if (type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult2.True;
      }
      if (Property2(left.properties[key], right.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })();
}
function FromPromise22(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) && IsObjectPromiseLike2(right) ? ExtendsResult2.True : !type_exports.IsPromise(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.item, right.item));
}
function RecordKey3(schema) {
  return PatternNumberExact2 in schema.patternProperties ? Number22() : (PatternStringExact2 in schema.patternProperties) ? String3() : Throw2("Unknown record key pattern");
}
function RecordValue3(schema) {
  return PatternNumberExact2 in schema.patternProperties ? schema.patternProperties[PatternNumberExact2] : (PatternStringExact2 in schema.patternProperties) ? schema.patternProperties[PatternStringExact2] : Throw2("Unable to get record value schema");
}
function FromRecordRight2(left, right) {
  const [Key, Value] = [RecordKey3(right), RecordValue3(right)];
  return type_exports.IsLiteralString(left) && type_exports.IsNumber(Key) && IntoBooleanResult2(Visit32(left, Value)) === ExtendsResult2.True ? ExtendsResult2.True : type_exports.IsUint8Array(left) && type_exports.IsNumber(Key) ? Visit32(left, Value) : type_exports.IsString(left) && type_exports.IsNumber(Key) ? Visit32(left, Value) : type_exports.IsArray(left) && type_exports.IsNumber(Key) ? Visit32(left, Value) : type_exports.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property2(Value, left.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })() : ExtendsResult2.False;
}
function FromRecord14(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : !type_exports.IsRecord(right) ? ExtendsResult2.False : Visit32(RecordValue3(left), RecordValue3(right));
}
function FromRegExp5(left, right) {
  const L = type_exports.IsRegExp(left) ? String3() : left;
  const R = type_exports.IsRegExp(right) ? String3() : right;
  return Visit32(L, R);
}
function FromStringRight2(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsString(left.const) ? ExtendsResult2.True : type_exports.IsString(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromString6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsString(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromSymbol6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsSymbol(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromTemplateLiteral22(left, right) {
  return type_exports.IsTemplateLiteral(left) ? Visit32(TemplateLiteralToUnion2(left), right) : type_exports.IsTemplateLiteral(right) ? Visit32(left, TemplateLiteralToUnion2(right)) : Throw2("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple2(left, right) {
  return type_exports.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit32(schema, right.items) === ExtendsResult2.True);
}
function FromTupleRight2(left, right) {
  return type_exports.IsNever(left) ? ExtendsResult2.True : type_exports.IsUnknown(left) ? ExtendsResult2.False : type_exports.IsAny(left) ? ExtendsResult2.Union : ExtendsResult2.False;
}
function FromTuple32(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : type_exports.IsArray(right) && IsArrayOfTuple2(left, right) ? ExtendsResult2.True : !type_exports.IsTuple(right) ? ExtendsResult2.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) || !value_exports.IsUndefined(left.items) && value_exports.IsUndefined(right.items) ? ExtendsResult2.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) ? ExtendsResult2.True : left.items.every((schema, index) => Visit32(schema, right.items[index]) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUint8Array5(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsUint8Array(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUndefined6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsVoid(right) ? FromVoidRight2(left, right) : type_exports.IsUndefined(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnionRight2(left, right) {
  return right.anyOf.some((schema) => Visit32(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnion62(left, right) {
  return left.anyOf.every((schema) => Visit32(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnknownRight2(left, right) {
  return ExtendsResult2.True;
}
function FromUnknown5(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight2(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) ? FromUnionRight2(left, right) : type_exports.IsAny(right) ? FromAnyRight2(left, right) : type_exports.IsString(right) ? FromStringRight2(left, right) : type_exports.IsNumber(right) ? FromNumberRight2(left, right) : type_exports.IsInteger(right) ? FromIntegerRight2(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight2(left, right) : type_exports.IsArray(right) ? FromArrayRight2(left, right) : type_exports.IsTuple(right) ? FromTupleRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsUnknown(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromVoidRight2(left, right) {
  return type_exports.IsUndefined(left) ? ExtendsResult2.True : type_exports.IsUndefined(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromVoid5(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) ? FromUnionRight2(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight2(left, right) : type_exports.IsAny(right) ? FromAnyRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsVoid(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function Visit32(left, right) {
  return type_exports.IsTemplateLiteral(left) || type_exports.IsTemplateLiteral(right) ? FromTemplateLiteral22(left, right) : type_exports.IsRegExp(left) || type_exports.IsRegExp(right) ? FromRegExp5(left, right) : type_exports.IsNot(left) || type_exports.IsNot(right) ? FromNot8(left, right) : type_exports.IsAny(left) ? FromAny5(left, right) : type_exports.IsArray(left) ? FromArray42(left, right) : type_exports.IsBigInt(left) ? FromBigInt6(left, right) : type_exports.IsBoolean(left) ? FromBoolean6(left, right) : type_exports.IsAsyncIterator(left) ? FromAsyncIterator8(left, right) : type_exports.IsConstructor(left) ? FromConstructor9(left, right) : type_exports.IsDate(left) ? FromDate8(left, right) : type_exports.IsFunction(left) ? FromFunction8(left, right) : type_exports.IsInteger(left) ? FromInteger6(left, right) : type_exports.IsIntersect(left) ? FromIntersect42(left, right) : type_exports.IsIterator(left) ? FromIterator8(left, right) : type_exports.IsLiteral(left) ? FromLiteral22(left, right) : type_exports.IsNever(left) ? FromNever6(left, right) : type_exports.IsNull(left) ? FromNull6(left, right) : type_exports.IsNumber(left) ? FromNumber6(left, right) : type_exports.IsObject(left) ? FromObject19(left, right) : type_exports.IsRecord(left) ? FromRecord14(left, right) : type_exports.IsString(left) ? FromString6(left, right) : type_exports.IsSymbol(left) ? FromSymbol6(left, right) : type_exports.IsTuple(left) ? FromTuple32(left, right) : type_exports.IsPromise(left) ? FromPromise22(left, right) : type_exports.IsUint8Array(left) ? FromUint8Array5(left, right) : type_exports.IsUndefined(left) ? FromUndefined6(left, right) : type_exports.IsUnion(left) ? FromUnion62(left, right) : type_exports.IsUnknown(left) ? FromUnknown5(left, right) : type_exports.IsVoid(left) ? FromVoid5(left, right) : Throw2(`Unknown left type operand '${left[Kind2]}'`);
}
function ExtendsCheck2(left, right) {
  return Visit32(left, right);
}
function FromProperties82(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends2(P[K2], Right, True, False, Clone3(options));
  return Acc;
}
function FromMappedResult62(Left, Right, True, False, options) {
  return FromProperties82(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult2(Left, Right, True, False, options) {
  const P = FromMappedResult62(Left, Right, True, False, options);
  return MappedResult2(P);
}
function ExtendsResolve2(left, right, trueType, falseType) {
  const R = ExtendsCheck2(left, right);
  return R === ExtendsResult2.Union ? Union3([trueType, falseType]) : R === ExtendsResult2.True ? trueType : falseType;
}
function Extends2(L, R, T, F, options) {
  return IsMappedResult3(L) ? ExtendsFromMappedResult2(L, R, T, F, options) : IsMappedKey3(L) ? CreateType2(ExtendsFromMappedKey2(L, R, T, F, options)) : CreateType2(ExtendsResolve2(L, R, T, F), options);
}
function FromPropertyKey4(K, U, L, R, options) {
  return {
    [K]: Extends2(Literal2(K), U, L, R, Clone3(options))
  };
}
function FromPropertyKeys4(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey4(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey22(K, U, L, R, options) {
  return FromPropertyKeys4(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey2(T, U, L, R, options) {
  const P = FromMappedKey22(T, U, L, R, options);
  return MappedResult2(P);
}
function ExcludeFromTemplateLiteral2(L, R) {
  return Exclude2(TemplateLiteralToUnion2(L), R);
}
function ExcludeRest2(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck2(inner, R) === ExtendsResult2.False);
  return excluded.length === 1 ? excluded[0] : Union3(excluded);
}
function Exclude2(L, R, options = {}) {
  if (IsTemplateLiteral3(L))
    return CreateType2(ExcludeFromTemplateLiteral2(L, R), options);
  if (IsMappedResult3(L))
    return CreateType2(ExcludeFromMappedResult2(L, R), options);
  return CreateType2(IsUnion3(L) ? ExcludeRest2(L.anyOf, R) : ExtendsCheck2(L, R) !== ExtendsResult2.False ? Never2() : L, options);
}
function FromProperties92(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude2(P[K2], U);
  return Acc;
}
function FromMappedResult72(R, T) {
  return FromProperties92(R.properties, T);
}
function ExcludeFromMappedResult2(R, T) {
  const P = FromMappedResult72(R, T);
  return MappedResult2(P);
}
function ExtractFromTemplateLiteral2(L, R) {
  return Extract2(TemplateLiteralToUnion2(L), R);
}
function ExtractRest2(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck2(inner, R) !== ExtendsResult2.False);
  return extracted.length === 1 ? extracted[0] : Union3(extracted);
}
function Extract2(L, R, options) {
  if (IsTemplateLiteral3(L))
    return CreateType2(ExtractFromTemplateLiteral2(L, R), options);
  if (IsMappedResult3(L))
    return CreateType2(ExtractFromMappedResult2(L, R), options);
  return CreateType2(IsUnion3(L) ? ExtractRest2(L.anyOf, R) : ExtendsCheck2(L, R) !== ExtendsResult2.False ? L : Never2(), options);
}
function FromProperties102(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract2(P[K2], T);
  return Acc;
}
function FromMappedResult82(R, T) {
  return FromProperties102(R.properties, T);
}
function ExtractFromMappedResult2(R, T) {
  const P = FromMappedResult82(R, T);
  return MappedResult2(P);
}
function InstanceType2(schema, options) {
  return CreateType2(schema.returns, options);
}
function Integer2(options) {
  return CreateType2({ [Kind2]: "Integer", type: "integer" }, options);
}
function MappedIntrinsicPropertyKey2(K, M, options) {
  return {
    [K]: Intrinsic2(Literal2(K), M, Clone3(options))
  };
}
function MappedIntrinsicPropertyKeys2(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey2(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties2(T, M, options) {
  return MappedIntrinsicPropertyKeys2(T["keys"], M, options);
}
function IntrinsicFromMappedKey2(T, M, options) {
  const P = MappedIntrinsicProperties2(T, M, options);
  return MappedResult2(P);
}
function ApplyUncapitalize2(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize2(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase2(value) {
  return value.toUpperCase();
}
function ApplyLowercase2(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral32(schema, mode, options) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite2(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue2(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate2(expression)];
  const literals = strings.map((value) => Literal2(value));
  const mapped = FromRest52(literals, mode);
  const union = Union3(mapped);
  return TemplateLiteral2([union], options);
}
function FromLiteralValue2(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize2(value) : mode === "Capitalize" ? ApplyCapitalize2(value) : mode === "Uppercase" ? ApplyUppercase2(value) : mode === "Lowercase" ? ApplyLowercase2(value) : value : value.toString();
}
function FromRest52(T, M) {
  return T.map((L) => Intrinsic2(L, M));
}
function Intrinsic2(schema, mode, options = {}) {
  return IsMappedKey3(schema) ? IntrinsicFromMappedKey2(schema, mode, options) : IsTemplateLiteral3(schema) ? FromTemplateLiteral32(schema, mode, options) : IsUnion3(schema) ? Union3(FromRest52(schema.anyOf, mode), options) : IsLiteral3(schema) ? Literal2(FromLiteralValue2(schema.const, mode), options) : CreateType2(schema, options);
}
function Capitalize2(T, options = {}) {
  return Intrinsic2(T, "Capitalize", options);
}
function Lowercase2(T, options = {}) {
  return Intrinsic2(T, "Lowercase", options);
}
function Uncapitalize2(T, options = {}) {
  return Intrinsic2(T, "Uncapitalize", options);
}
function Uppercase2(T, options = {}) {
  return Intrinsic2(T, "Uppercase", options);
}
function FromProperties112(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit2(properties[K2], propertyKeys, Clone3(options));
  return result;
}
function FromMappedResult92(mappedResult, propertyKeys, options) {
  return FromProperties112(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult2(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult92(mappedResult, propertyKeys, options);
  return MappedResult2(properties);
}
function FromIntersect52(types4, propertyKeys) {
  return types4.map((type2) => OmitResolve2(type2, propertyKeys));
}
function FromUnion72(types4, propertyKeys) {
  return types4.map((type2) => OmitResolve2(type2, propertyKeys));
}
function FromProperty22(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
}
function FromProperties122(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty22(T, K2), properties);
}
function FromObject22(properties, propertyKeys) {
  const options = Discard2(properties, [TransformKind2, "$id", "required", "properties"]);
  const omittedProperties = FromProperties122(properties["properties"], propertyKeys);
  return Object22(omittedProperties, options);
}
function UnionFromPropertyKeys3(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue3(key) ? [...result2, Literal2(key)] : result2, []);
  return Union3(result);
}
function OmitResolve2(properties, propertyKeys) {
  return IsIntersect3(properties) ? Intersect3(FromIntersect52(properties.allOf, propertyKeys)) : IsUnion3(properties) ? Union3(FromUnion72(properties.anyOf, propertyKeys)) : IsObject32(properties) ? FromObject22(properties, propertyKeys) : Object22({});
}
function Omit2(type2, key, options) {
  const typeKey = IsArray5(key) ? UnionFromPropertyKeys3(key) : key;
  const propertyKeys = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const isTypeRef = IsRef3(type2);
  const isKeyRef = IsRef3(key);
  return IsMappedResult3(type2) ? OmitFromMappedResult2(type2, propertyKeys, options) : IsMappedKey3(key) ? OmitFromMappedKey2(type2, key, options) : isTypeRef && isKeyRef ? Computed2("Omit", [type2, typeKey], options) : !isTypeRef && isKeyRef ? Computed2("Omit", [type2, typeKey], options) : isTypeRef && !isKeyRef ? Computed2("Omit", [type2, typeKey], options) : CreateType2({ ...OmitResolve2(type2, propertyKeys), ...options });
}
function FromPropertyKey22(type2, key, options) {
  return { [key]: Omit2(type2, [key], Clone3(options)) };
}
function FromPropertyKeys22(type2, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey22(type2, LK, options) };
  }, {});
}
function FromMappedKey32(type2, mappedKey, options) {
  return FromPropertyKeys22(type2, mappedKey.keys, options);
}
function OmitFromMappedKey2(type2, mappedKey, options) {
  const properties = FromMappedKey32(type2, mappedKey, options);
  return MappedResult2(properties);
}
function FromProperties132(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick2(properties[K2], propertyKeys, Clone3(options));
  return result;
}
function FromMappedResult102(mappedResult, propertyKeys, options) {
  return FromProperties132(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult2(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult102(mappedResult, propertyKeys, options);
  return MappedResult2(properties);
}
function FromIntersect62(types4, propertyKeys) {
  return types4.map((type2) => PickResolve2(type2, propertyKeys));
}
function FromUnion82(types4, propertyKeys) {
  return types4.map((type2) => PickResolve2(type2, propertyKeys));
}
function FromProperties142(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject32(T, K) {
  const options = Discard2(T, [TransformKind2, "$id", "required", "properties"]);
  const properties = FromProperties142(T["properties"], K);
  return Object22(properties, options);
}
function UnionFromPropertyKeys22(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue3(key) ? [...result2, Literal2(key)] : result2, []);
  return Union3(result);
}
function PickResolve2(properties, propertyKeys) {
  return IsIntersect3(properties) ? Intersect3(FromIntersect62(properties.allOf, propertyKeys)) : IsUnion3(properties) ? Union3(FromUnion82(properties.anyOf, propertyKeys)) : IsObject32(properties) ? FromObject32(properties, propertyKeys) : Object22({});
}
function Pick2(type2, key, options) {
  const typeKey = IsArray5(key) ? UnionFromPropertyKeys22(key) : key;
  const propertyKeys = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const isTypeRef = IsRef3(type2);
  const isKeyRef = IsRef3(key);
  return IsMappedResult3(type2) ? PickFromMappedResult2(type2, propertyKeys, options) : IsMappedKey3(key) ? PickFromMappedKey2(type2, key, options) : isTypeRef && isKeyRef ? Computed2("Pick", [type2, typeKey], options) : !isTypeRef && isKeyRef ? Computed2("Pick", [type2, typeKey], options) : isTypeRef && !isKeyRef ? Computed2("Pick", [type2, typeKey], options) : CreateType2({ ...PickResolve2(type2, propertyKeys), ...options });
}
function FromPropertyKey32(type2, key, options) {
  return {
    [key]: Pick2(type2, [key], Clone3(options))
  };
}
function FromPropertyKeys32(type2, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey32(type2, leftKey, options) };
  }, {});
}
function FromMappedKey42(type2, mappedKey, options) {
  return FromPropertyKeys32(type2, mappedKey.keys, options);
}
function PickFromMappedKey2(type2, mappedKey, options) {
  const properties = FromMappedKey42(type2, mappedKey, options);
  return MappedResult2(properties);
}
function FromComputed32(target, parameters) {
  return Computed2("Partial", [Computed2(target, parameters)]);
}
function FromRef32($ref) {
  return Computed2("Partial", [Ref2($ref)]);
}
function FromProperties152(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional2(properties[K]);
  return partialProperties;
}
function FromObject42(T) {
  const options = Discard2(T, [TransformKind2, "$id", "required", "properties"]);
  const properties = FromProperties152(T["properties"]);
  return Object22(properties, options);
}
function FromRest62(types4) {
  return types4.map((type2) => PartialResolve2(type2));
}
function PartialResolve2(type2) {
  return IsComputed3(type2) ? FromComputed32(type2.target, type2.parameters) : IsRef3(type2) ? FromRef32(type2.$ref) : IsIntersect3(type2) ? Intersect3(FromRest62(type2.allOf)) : IsUnion3(type2) ? Union3(FromRest62(type2.anyOf)) : IsObject32(type2) ? FromObject42(type2) : Object22({});
}
function Partial2(type2, options) {
  if (IsMappedResult3(type2)) {
    return PartialFromMappedResult2(type2, options);
  } else {
    return CreateType2({ ...PartialResolve2(type2), ...options });
  }
}
function FromProperties162(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial2(K[K2], Clone3(options));
  return Acc;
}
function FromMappedResult112(R, options) {
  return FromProperties162(R.properties, options);
}
function PartialFromMappedResult2(R, options) {
  const P = FromMappedResult112(R, options);
  return MappedResult2(P);
}
function RecordCreateFromPattern2(pattern, T, options) {
  return CreateType2({ [Kind2]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys2(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object22(result, { ...options, [Hint2]: "Record" });
}
function FromTemplateLiteralKey2(K, T, options) {
  return IsTemplateLiteralFinite2(K) ? RecordCreateFromKeys2(IndexPropertyKeys2(K), T, options) : RecordCreateFromPattern2(K.pattern, T, options);
}
function FromUnionKey2(key, type2, options) {
  return RecordCreateFromKeys2(IndexPropertyKeys2(Union3(key)), type2, options);
}
function FromLiteralKey2(key, type2, options) {
  return RecordCreateFromKeys2([key.toString()], type2, options);
}
function FromRegExpKey2(key, type2, options) {
  return RecordCreateFromPattern2(key.source, type2, options);
}
function FromStringKey2(key, type2, options) {
  const pattern = IsUndefined5(key.pattern) ? PatternStringExact2 : key.pattern;
  return RecordCreateFromPattern2(pattern, type2, options);
}
function FromAnyKey2(_, type2, options) {
  return RecordCreateFromPattern2(PatternStringExact2, type2, options);
}
function FromNeverKey2(_key, type2, options) {
  return RecordCreateFromPattern2(PatternNeverExact2, type2, options);
}
function FromIntegerKey2(_key, type2, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, type2, options);
}
function FromNumberKey2(_, type2, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, type2, options);
}
function Record2(key, type2, options = {}) {
  return IsComputed3(type2) ? Computed2("Record", [key, Computed2(type2.target, type2.parameters)], options) : IsComputed3(key) ? Computed2("Record", [Computed2(type2.target, type2.parameters), type2], options) : IsRef3(key) ? Computed2("Record", [Ref2(key.$ref), type2]) : IsUnion3(key) ? FromUnionKey2(key.anyOf, type2, options) : IsTemplateLiteral3(key) ? FromTemplateLiteralKey2(key, type2, options) : IsLiteral3(key) ? FromLiteralKey2(key.const, type2, options) : IsInteger4(key) ? FromIntegerKey2(key, type2, options) : IsNumber32(key) ? FromNumberKey2(key, type2, options) : IsRegExp22(key) ? FromRegExpKey2(key, type2, options) : IsString22(key) ? FromStringKey2(key, type2, options) : IsAny3(key) ? FromAnyKey2(key, type2, options) : IsNever3(key) ? FromNeverKey2(key, type2, options) : Never2(options);
}
function FromComputed42(target, parameters) {
  return Computed2("Required", [Computed2(target, parameters)]);
}
function FromRef42($ref) {
  return Computed2("Required", [Ref2($ref)]);
}
function FromProperties172(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard2(properties[K], [OptionalKind2]);
  return requiredProperties;
}
function FromObject52(type2) {
  const options = Discard2(type2, [TransformKind2, "$id", "required", "properties"]);
  const properties = FromProperties172(type2["properties"]);
  return Object22(properties, options);
}
function FromRest72(types4) {
  return types4.map((type2) => RequiredResolve2(type2));
}
function RequiredResolve2(type2) {
  return IsComputed3(type2) ? FromComputed42(type2.target, type2.parameters) : IsRef3(type2) ? FromRef42(type2.$ref) : IsIntersect3(type2) ? Intersect3(FromRest72(type2.allOf)) : IsUnion3(type2) ? Union3(FromRest72(type2.anyOf)) : IsObject32(type2) ? FromObject52(type2) : Object22({});
}
function Required2(type2, options) {
  if (IsMappedResult3(type2)) {
    return RequiredFromMappedResult2(type2, options);
  } else {
    return CreateType2({ ...RequiredResolve2(type2), ...options });
  }
}
function FromProperties182(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required2(P[K2], options);
  return Acc;
}
function FromMappedResult122(R, options) {
  return FromProperties182(R.properties, options);
}
function RequiredFromMappedResult2(R, options) {
  const P = FromMappedResult122(R, options);
  return MappedResult2(P);
}
function DerefParameters(moduleProperties, types4) {
  return types4.map((type2) => {
    return IsRef3(type2) ? Deref2(moduleProperties, type2.$ref) : FromType3(moduleProperties, type2);
  });
}
function Deref2(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef3(moduleProperties[ref]) ? Deref2(moduleProperties, moduleProperties[ref].$ref) : FromType3(moduleProperties, moduleProperties[ref]) : Never2();
}
function FromAwaited2(parameters) {
  return Awaited2(parameters[0]);
}
function FromIndex2(parameters) {
  return Index2(parameters[0], parameters[1]);
}
function FromKeyOf2(parameters) {
  return KeyOf2(parameters[0]);
}
function FromPartial2(parameters) {
  return Partial2(parameters[0]);
}
function FromOmit2(parameters) {
  return Omit2(parameters[0], parameters[1]);
}
function FromPick2(parameters) {
  return Pick2(parameters[0], parameters[1]);
}
function FromRecord22(parameters) {
  return Record2(parameters[0], parameters[1]);
}
function FromRequired2(parameters) {
  return Required2(parameters[0]);
}
function FromComputed52(moduleProperties, target, parameters) {
  const dereferenced = DerefParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited2(dereferenced) : target === "Index" ? FromIndex2(dereferenced) : target === "KeyOf" ? FromKeyOf2(dereferenced) : target === "Partial" ? FromPartial2(dereferenced) : target === "Omit" ? FromOmit2(dereferenced) : target === "Pick" ? FromPick2(dereferenced) : target === "Record" ? FromRecord22(dereferenced) : target === "Required" ? FromRequired2(dereferenced) : Never2();
}
function FromObject62(moduleProperties, properties) {
  return Object22(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType3(moduleProperties, properties[key]) };
  }, {}));
}
function FromConstructor22(moduleProperties, parameters, instanceType) {
  return Constructor2(FromRest82(moduleProperties, parameters), FromType3(moduleProperties, instanceType));
}
function FromFunction22(moduleProperties, parameters, returnType) {
  return Function3(FromRest82(moduleProperties, parameters), FromType3(moduleProperties, returnType));
}
function FromTuple42(moduleProperties, types4) {
  return Tuple2(FromRest82(moduleProperties, types4));
}
function FromIntersect72(moduleProperties, types4) {
  return Intersect3(FromRest82(moduleProperties, types4));
}
function FromUnion92(moduleProperties, types4) {
  return Union3(FromRest82(moduleProperties, types4));
}
function FromArray52(moduleProperties, type2) {
  return Array22(FromType3(moduleProperties, type2));
}
function FromAsyncIterator22(moduleProperties, type2) {
  return AsyncIterator2(FromType3(moduleProperties, type2));
}
function FromIterator22(moduleProperties, type2) {
  return Iterator2(FromType3(moduleProperties, type2));
}
function FromRest82(moduleProperties, types4) {
  return types4.map((type2) => FromType3(moduleProperties, type2));
}
function FromType3(moduleProperties, type2) {
  return IsOptional3(type2) ? CreateType2(FromType3(moduleProperties, Discard2(type2, [OptionalKind2])), type2) : IsReadonly3(type2) ? CreateType2(FromType3(moduleProperties, Discard2(type2, [ReadonlyKind2])), type2) : IsArray32(type2) ? CreateType2(FromArray52(moduleProperties, type2.items), type2) : IsAsyncIterator22(type2) ? CreateType2(FromAsyncIterator22(moduleProperties, type2.items), type2) : IsComputed3(type2) ? CreateType2(FromComputed52(moduleProperties, type2.target, type2.parameters)) : IsConstructor3(type2) ? CreateType2(FromConstructor22(moduleProperties, type2.parameters, type2.returns), type2) : IsFunction22(type2) ? CreateType2(FromFunction22(moduleProperties, type2.parameters, type2.returns), type2) : IsIntersect3(type2) ? CreateType2(FromIntersect72(moduleProperties, type2.allOf), type2) : IsIterator22(type2) ? CreateType2(FromIterator22(moduleProperties, type2.items), type2) : IsObject32(type2) ? CreateType2(FromObject62(moduleProperties, type2.properties), type2) : IsTuple3(type2) ? CreateType2(FromTuple42(moduleProperties, type2.items || []), type2) : IsUnion3(type2) ? CreateType2(FromUnion92(moduleProperties, type2.anyOf), type2) : type2;
}
function ComputeType2(moduleProperties, key) {
  return key in moduleProperties ? FromType3(moduleProperties, moduleProperties[key]) : Never2();
}
function ComputeModuleProperties2(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType2(moduleProperties, key) };
  }, {});
}
var TModule2 = class {
  constructor($defs) {
    const computed = ComputeModuleProperties2($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType2(this.$defs[key], options) };
    return CreateType2({ [Kind2]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
};
function Module2(properties) {
  return new TModule2(properties);
}
function Not3(type2, options) {
  return CreateType2({ [Kind2]: "Not", not: type2 }, options);
}
function Parameters2(schema, options) {
  return Tuple2(schema.parameters, options);
}
function ReadonlyOptional2(schema) {
  return Readonly2(Optional2(schema));
}
var Ordinal2 = 0;
function Recursive2(callback, options = {}) {
  if (IsUndefined5(options.$id))
    options.$id = `T${Ordinal2++}`;
  const thisType = CloneType2(callback({ [Kind2]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType2({ [Hint2]: "Recursive", ...thisType }, options);
}
function RegExp22(unresolved, options) {
  const expr = IsString5(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType2({ [Kind2]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}
function RestResolve2(T) {
  return IsIntersect3(T) ? T.allOf : IsUnion3(T) ? T.anyOf : IsTuple3(T) ? T.items ?? [] : [];
}
function Rest2(T) {
  return RestResolve2(T);
}
function ReturnType2(schema, options) {
  return CreateType2(schema.returns, options);
}
var TransformDecodeBuilder2 = class {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode4) {
    return new TransformEncodeBuilder2(this.schema, decode4);
  }
};
var TransformEncodeBuilder2 = class {
  constructor(schema, decode4) {
    this.schema = schema;
    this.decode = decode4;
  }
  EncodeTransform(encode3, schema) {
    const Encode2 = (value) => schema[TransformKind2].Encode(encode3(value));
    const Decode2 = (value) => this.decode(schema[TransformKind2].Decode(value));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema, [TransformKind2]: Codec };
  }
  EncodeSchema(encode3, schema) {
    const Codec = { Decode: this.decode, Encode: encode3 };
    return { ...schema, [TransformKind2]: Codec };
  }
  Encode(encode3) {
    return IsTransform3(this.schema) ? this.EncodeTransform(encode3, this.schema) : this.EncodeSchema(encode3, this.schema);
  }
};
function Transform2(schema) {
  return new TransformDecodeBuilder2(schema);
}
function Unsafe2(options = {}) {
  return CreateType2({ [Kind2]: options[Kind2] ?? "Unsafe" }, options);
}
function Void2(options) {
  return CreateType2({ [Kind2]: "Void", type: "void" }, options);
}
var type_exports2 = {};
__export2(type_exports2, {
  Any: () => Any2,
  Array: () => Array22,
  AsyncIterator: () => AsyncIterator2,
  Awaited: () => Awaited2,
  BigInt: () => BigInt3,
  Boolean: () => Boolean3,
  Capitalize: () => Capitalize2,
  Composite: () => Composite2,
  Const: () => Const2,
  Constructor: () => Constructor2,
  ConstructorParameters: () => ConstructorParameters2,
  Date: () => Date22,
  Enum: () => Enum2,
  Exclude: () => Exclude2,
  Extends: () => Extends2,
  Extract: () => Extract2,
  Function: () => Function3,
  Index: () => Index2,
  InstanceType: () => InstanceType2,
  Integer: () => Integer2,
  Intersect: () => Intersect3,
  Iterator: () => Iterator2,
  KeyOf: () => KeyOf2,
  Literal: () => Literal2,
  Lowercase: () => Lowercase2,
  Mapped: () => Mapped2,
  Module: () => Module2,
  Never: () => Never2,
  Not: () => Not3,
  Null: () => Null2,
  Number: () => Number22,
  Object: () => Object22,
  Omit: () => Omit2,
  Optional: () => Optional2,
  Parameters: () => Parameters2,
  Partial: () => Partial2,
  Pick: () => Pick2,
  Promise: () => Promise22,
  Readonly: () => Readonly2,
  ReadonlyOptional: () => ReadonlyOptional2,
  Record: () => Record2,
  Recursive: () => Recursive2,
  Ref: () => Ref2,
  RegExp: () => RegExp22,
  Required: () => Required2,
  Rest: () => Rest2,
  ReturnType: () => ReturnType2,
  String: () => String3,
  Symbol: () => Symbol22,
  TemplateLiteral: () => TemplateLiteral2,
  Transform: () => Transform2,
  Tuple: () => Tuple2,
  Uint8Array: () => Uint8Array22,
  Uncapitalize: () => Uncapitalize2,
  Undefined: () => Undefined2,
  Union: () => Union3,
  Unknown: () => Unknown2,
  Unsafe: () => Unsafe2,
  Uppercase: () => Uppercase2,
  Void: () => Void2
});
var Type2 = type_exports2;
var jwt = ({
  name = "jwt",
  secret,
  alg = "HS256",
  crit,
  schema,
  nbf,
  exp,
  ...payload
}) => {
  if (!secret)
    throw new Error("Secret can't be empty");
  const key = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  const validator = schema ? getSchemaValidator2(Type2.Intersect([
    schema,
    Type2.Object({
      iss: Type2.Optional(Type2.String()),
      sub: Type2.Optional(Type2.String()),
      aud: Type2.Optional(Type2.Union([Type2.String(), Type2.Array(Type2.String())])),
      jti: Type2.Optional(Type2.String()),
      nbf: Type2.Optional(Type2.Union([Type2.String(), Type2.Number()])),
      exp: Type2.Optional(Type2.Union([Type2.String(), Type2.Number()])),
      iat: Type2.Optional(Type2.String())
    })
  ]), {}) : undefined;
  return new Elysia({
    name: "@elysiajs/jwt",
    seed: {
      name,
      secret,
      alg,
      crit,
      schema,
      nbf,
      exp,
      ...payload
    }
  }).decorate(name, {
    sign(morePayload) {
      let jwt2 = new SignJWT({
        ...payload,
        ...morePayload,
        nbf: undefined,
        exp: undefined
      }).setProtectedHeader({
        alg,
        crit
      });
      if (nbf)
        jwt2 = jwt2.setNotBefore(nbf);
      if (exp)
        jwt2 = jwt2.setExpirationTime(exp);
      return jwt2.sign(key);
    },
    async verify(jwt2) {
      if (!jwt2)
        return false;
      try {
        const data = (await jwtVerify(jwt2, key)).payload;
        if (validator && !validator.Check(data))
          throw new ValidationError2("JWT", validator, data);
        return data;
      } catch (_) {
        return false;
      }
    }
  });
};

// src/config/auth.config.ts
var import_dotenv = __toESM(require_main(), 1);
import { join as join2 } from "path";
var __dirname = "D:\\PROJECT\\WEB_APP\\04-ENVIROMENTS\\src\\config";
import_dotenv.default.config({ path: join2(__dirname, "../../.env") });
var JWT_SECRET = process.env.JWT_SECRET;
var JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN;
function getExpiresInSeconds() {
  const expiresIn = JWT_EXPIRES_IN;
  const unit = expiresIn.slice(-1);
  const value = parseInt(expiresIn.slice(0, -1));
  switch (unit) {
    case "s":
      return value;
    case "m":
      return value * 60;
    case "h":
      return value * 60 * 60;
    case "d":
      return value * 60 * 60 * 24;
    case "w":
      return value * 60 * 60 * 24 * 7;
    default:
      return parseInt(expiresIn);
  }
}
var authConfig = {
  jwt: {
    secret: JWT_SECRET,
    expiresIn: JWT_EXPIRES_IN
  }
};

// node_modules/bcryptjs/index.js
import nodeCrypto from "crypto";
var randomFallback = null;
function randomBytes(len) {
  try {
    return crypto.getRandomValues(new Uint8Array(len));
  } catch {}
  try {
    return nodeCrypto.randomBytes(len);
  } catch {}
  if (!randomFallback) {
    throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
  }
  return randomFallback(len);
}
function genSaltSync(rounds, seed_length) {
  rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof rounds !== "number")
    throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
  if (rounds < 4)
    rounds = 4;
  else if (rounds > 31)
    rounds = 31;
  var salt = [];
  salt.push("$2b$");
  if (rounds < 10)
    salt.push("0");
  salt.push(rounds.toString());
  salt.push("$");
  salt.push(base64_encode(randomBytes(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
  return salt.join("");
}
function genSalt(rounds, seed_length, callback) {
  if (typeof seed_length === "function")
    callback = seed_length, seed_length = undefined;
  if (typeof rounds === "function")
    callback = rounds, rounds = undefined;
  if (typeof rounds === "undefined")
    rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
  else if (typeof rounds !== "number")
    throw Error("illegal arguments: " + typeof rounds);
  function _async(callback2) {
    nextTick(function() {
      try {
        callback2(null, genSaltSync(rounds));
      } catch (err) {
        callback2(err);
      }
    });
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve2, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(res);
      });
    });
}
function hash2(password, salt, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password === "string" && typeof salt === "number")
      genSalt(salt, function(err, salt2) {
        _hash(password, salt2, callback2, progressCallback);
      });
    else if (typeof password === "string" && typeof salt === "string")
      _hash(password, salt, callback2, progressCallback);
    else
      nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof password + ", " + typeof salt)));
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve2, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(res);
      });
    });
}
function safeStringCompare(known, unknown) {
  var diff = known.length ^ unknown.length;
  for (var i = 0;i < known.length; ++i) {
    diff |= known.charCodeAt(i) ^ unknown.charCodeAt(i);
  }
  return diff === 0;
}
function compare(password, hashValue, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password !== "string" || typeof hashValue !== "string") {
      nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof password + ", " + typeof hashValue)));
      return;
    }
    if (hashValue.length !== 60) {
      nextTick(callback2.bind(this, null, false));
      return;
    }
    hash2(password, hashValue.substring(0, 29), function(err, comp) {
      if (err)
        callback2(err);
      else
        callback2(null, safeStringCompare(comp, hashValue));
    }, progressCallback);
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve2, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(res);
      });
    });
}
var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
function utf8Length(string) {
  var len = 0, c = 0;
  for (var i = 0;i < string.length; ++i) {
    c = string.charCodeAt(i);
    if (c < 128)
      len += 1;
    else if (c < 2048)
      len += 2;
    else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len += 4;
    } else
      len += 3;
  }
  return len;
}
function utf8Array(string) {
  var offset = 0, c1, c2;
  var buffer = new Array(utf8Length(string));
  for (var i = 0, k = string.length;i < k; ++i) {
    c1 = string.charCodeAt(i);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return buffer;
}
var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
var BASE64_INDEX = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  -1,
  -1,
  -1,
  -1,
  -1
];
function base64_encode(b, len) {
  var off = 0, rs = [], c1, c2;
  if (len <= 0 || len > b.length)
    throw Error("Illegal len: " + len);
  while (off < len) {
    c1 = b[off++] & 255;
    rs.push(BASE64_CODE[c1 >> 2 & 63]);
    c1 = (c1 & 3) << 4;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 4 & 15;
    rs.push(BASE64_CODE[c1 & 63]);
    c1 = (c2 & 15) << 2;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 6 & 3;
    rs.push(BASE64_CODE[c1 & 63]);
    rs.push(BASE64_CODE[c2 & 63]);
  }
  return rs.join("");
}
function base64_decode(s, len) {
  var off = 0, slen = s.length, olen = 0, rs = [], c1, c2, c3, c4, o, code;
  if (len <= 0)
    throw Error("Illegal len: " + len);
  while (off < slen - 1 && olen < len) {
    code = s.charCodeAt(off++);
    c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    code = s.charCodeAt(off++);
    c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c1 == -1 || c2 == -1)
      break;
    o = c1 << 2 >>> 0;
    o |= (c2 & 48) >> 4;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen)
      break;
    code = s.charCodeAt(off++);
    c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c3 == -1)
      break;
    o = (c2 & 15) << 4 >>> 0;
    o |= (c3 & 60) >> 2;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen)
      break;
    code = s.charCodeAt(off++);
    c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    o = (c3 & 3) << 6 >>> 0;
    o |= c4;
    rs.push(String.fromCharCode(o));
    ++olen;
  }
  var res = [];
  for (off = 0;off < olen; off++)
    res.push(rs[off].charCodeAt(0));
  return res;
}
var BCRYPT_SALT_LEN = 16;
var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
var BLOWFISH_NUM_ROUNDS = 16;
var MAX_EXECUTION_TIME = 100;
var P_ORIG = [
  608135816,
  2242054355,
  320440878,
  57701188,
  2752067618,
  698298832,
  137296536,
  3964562569,
  1160258022,
  953160567,
  3193202383,
  887688300,
  3232508343,
  3380367581,
  1065670069,
  3041331479,
  2450970073,
  2306472731
];
var S_ORIG = [
  3509652390,
  2564797868,
  805139163,
  3491422135,
  3101798381,
  1780907670,
  3128725573,
  4046225305,
  614570311,
  3012652279,
  134345442,
  2240740374,
  1667834072,
  1901547113,
  2757295779,
  4103290238,
  227898511,
  1921955416,
  1904987480,
  2182433518,
  2069144605,
  3260701109,
  2620446009,
  720527379,
  3318853667,
  677414384,
  3393288472,
  3101374703,
  2390351024,
  1614419982,
  1822297739,
  2954791486,
  3608508353,
  3174124327,
  2024746970,
  1432378464,
  3864339955,
  2857741204,
  1464375394,
  1676153920,
  1439316330,
  715854006,
  3033291828,
  289532110,
  2706671279,
  2087905683,
  3018724369,
  1668267050,
  732546397,
  1947742710,
  3462151702,
  2609353502,
  2950085171,
  1814351708,
  2050118529,
  680887927,
  999245976,
  1800124847,
  3300911131,
  1713906067,
  1641548236,
  4213287313,
  1216130144,
  1575780402,
  4018429277,
  3917837745,
  3693486850,
  3949271944,
  596196993,
  3549867205,
  258830323,
  2213823033,
  772490370,
  2760122372,
  1774776394,
  2652871518,
  566650946,
  4142492826,
  1728879713,
  2882767088,
  1783734482,
  3629395816,
  2517608232,
  2874225571,
  1861159788,
  326777828,
  3124490320,
  2130389656,
  2716951837,
  967770486,
  1724537150,
  2185432712,
  2364442137,
  1164943284,
  2105845187,
  998989502,
  3765401048,
  2244026483,
  1075463327,
  1455516326,
  1322494562,
  910128902,
  469688178,
  1117454909,
  936433444,
  3490320968,
  3675253459,
  1240580251,
  122909385,
  2157517691,
  634681816,
  4142456567,
  3825094682,
  3061402683,
  2540495037,
  79693498,
  3249098678,
  1084186820,
  1583128258,
  426386531,
  1761308591,
  1047286709,
  322548459,
  995290223,
  1845252383,
  2603652396,
  3431023940,
  2942221577,
  3202600964,
  3727903485,
  1712269319,
  422464435,
  3234572375,
  1170764815,
  3523960633,
  3117677531,
  1434042557,
  442511882,
  3600875718,
  1076654713,
  1738483198,
  4213154764,
  2393238008,
  3677496056,
  1014306527,
  4251020053,
  793779912,
  2902807211,
  842905082,
  4246964064,
  1395751752,
  1040244610,
  2656851899,
  3396308128,
  445077038,
  3742853595,
  3577915638,
  679411651,
  2892444358,
  2354009459,
  1767581616,
  3150600392,
  3791627101,
  3102740896,
  284835224,
  4246832056,
  1258075500,
  768725851,
  2589189241,
  3069724005,
  3532540348,
  1274779536,
  3789419226,
  2764799539,
  1660621633,
  3471099624,
  4011903706,
  913787905,
  3497959166,
  737222580,
  2514213453,
  2928710040,
  3937242737,
  1804850592,
  3499020752,
  2949064160,
  2386320175,
  2390070455,
  2415321851,
  4061277028,
  2290661394,
  2416832540,
  1336762016,
  1754252060,
  3520065937,
  3014181293,
  791618072,
  3188594551,
  3933548030,
  2332172193,
  3852520463,
  3043980520,
  413987798,
  3465142937,
  3030929376,
  4245938359,
  2093235073,
  3534596313,
  375366246,
  2157278981,
  2479649556,
  555357303,
  3870105701,
  2008414854,
  3344188149,
  4221384143,
  3956125452,
  2067696032,
  3594591187,
  2921233993,
  2428461,
  544322398,
  577241275,
  1471733935,
  610547355,
  4027169054,
  1432588573,
  1507829418,
  2025931657,
  3646575487,
  545086370,
  48609733,
  2200306550,
  1653985193,
  298326376,
  1316178497,
  3007786442,
  2064951626,
  458293330,
  2589141269,
  3591329599,
  3164325604,
  727753846,
  2179363840,
  146436021,
  1461446943,
  4069977195,
  705550613,
  3059967265,
  3887724982,
  4281599278,
  3313849956,
  1404054877,
  2845806497,
  146425753,
  1854211946,
  1266315497,
  3048417604,
  3681880366,
  3289982499,
  2909710000,
  1235738493,
  2632868024,
  2414719590,
  3970600049,
  1771706367,
  1449415276,
  3266420449,
  422970021,
  1963543593,
  2690192192,
  3826793022,
  1062508698,
  1531092325,
  1804592342,
  2583117782,
  2714934279,
  4024971509,
  1294809318,
  4028980673,
  1289560198,
  2221992742,
  1669523910,
  35572830,
  157838143,
  1052438473,
  1016535060,
  1802137761,
  1753167236,
  1386275462,
  3080475397,
  2857371447,
  1040679964,
  2145300060,
  2390574316,
  1461121720,
  2956646967,
  4031777805,
  4028374788,
  33600511,
  2920084762,
  1018524850,
  629373528,
  3691585981,
  3515945977,
  2091462646,
  2486323059,
  586499841,
  988145025,
  935516892,
  3367335476,
  2599673255,
  2839830854,
  265290510,
  3972581182,
  2759138881,
  3795373465,
  1005194799,
  847297441,
  406762289,
  1314163512,
  1332590856,
  1866599683,
  4127851711,
  750260880,
  613907577,
  1450815602,
  3165620655,
  3734664991,
  3650291728,
  3012275730,
  3704569646,
  1427272223,
  778793252,
  1343938022,
  2676280711,
  2052605720,
  1946737175,
  3164576444,
  3914038668,
  3967478842,
  3682934266,
  1661551462,
  3294938066,
  4011595847,
  840292616,
  3712170807,
  616741398,
  312560963,
  711312465,
  1351876610,
  322626781,
  1910503582,
  271666773,
  2175563734,
  1594956187,
  70604529,
  3617834859,
  1007753275,
  1495573769,
  4069517037,
  2549218298,
  2663038764,
  504708206,
  2263041392,
  3941167025,
  2249088522,
  1514023603,
  1998579484,
  1312622330,
  694541497,
  2582060303,
  2151582166,
  1382467621,
  776784248,
  2618340202,
  3323268794,
  2497899128,
  2784771155,
  503983604,
  4076293799,
  907881277,
  423175695,
  432175456,
  1378068232,
  4145222326,
  3954048622,
  3938656102,
  3820766613,
  2793130115,
  2977904593,
  26017576,
  3274890735,
  3194772133,
  1700274565,
  1756076034,
  4006520079,
  3677328699,
  720338349,
  1533947780,
  354530856,
  688349552,
  3973924725,
  1637815568,
  332179504,
  3949051286,
  53804574,
  2852348879,
  3044236432,
  1282449977,
  3583942155,
  3416972820,
  4006381244,
  1617046695,
  2628476075,
  3002303598,
  1686838959,
  431878346,
  2686675385,
  1700445008,
  1080580658,
  1009431731,
  832498133,
  3223435511,
  2605976345,
  2271191193,
  2516031870,
  1648197032,
  4164389018,
  2548247927,
  300782431,
  375919233,
  238389289,
  3353747414,
  2531188641,
  2019080857,
  1475708069,
  455242339,
  2609103871,
  448939670,
  3451063019,
  1395535956,
  2413381860,
  1841049896,
  1491858159,
  885456874,
  4264095073,
  4001119347,
  1565136089,
  3898914787,
  1108368660,
  540939232,
  1173283510,
  2745871338,
  3681308437,
  4207628240,
  3343053890,
  4016749493,
  1699691293,
  1103962373,
  3625875870,
  2256883143,
  3830138730,
  1031889488,
  3479347698,
  1535977030,
  4236805024,
  3251091107,
  2132092099,
  1774941330,
  1199868427,
  1452454533,
  157007616,
  2904115357,
  342012276,
  595725824,
  1480756522,
  206960106,
  497939518,
  591360097,
  863170706,
  2375253569,
  3596610801,
  1814182875,
  2094937945,
  3421402208,
  1082520231,
  3463918190,
  2785509508,
  435703966,
  3908032597,
  1641649973,
  2842273706,
  3305899714,
  1510255612,
  2148256476,
  2655287854,
  3276092548,
  4258621189,
  236887753,
  3681803219,
  274041037,
  1734335097,
  3815195456,
  3317970021,
  1899903192,
  1026095262,
  4050517792,
  356393447,
  2410691914,
  3873677099,
  3682840055,
  3913112168,
  2491498743,
  4132185628,
  2489919796,
  1091903735,
  1979897079,
  3170134830,
  3567386728,
  3557303409,
  857797738,
  1136121015,
  1342202287,
  507115054,
  2535736646,
  337727348,
  3213592640,
  1301675037,
  2528481711,
  1895095763,
  1721773893,
  3216771564,
  62756741,
  2142006736,
  835421444,
  2531993523,
  1442658625,
  3659876326,
  2882144922,
  676362277,
  1392781812,
  170690266,
  3921047035,
  1759253602,
  3611846912,
  1745797284,
  664899054,
  1329594018,
  3901205900,
  3045908486,
  2062866102,
  2865634940,
  3543621612,
  3464012697,
  1080764994,
  553557557,
  3656615353,
  3996768171,
  991055499,
  499776247,
  1265440854,
  648242737,
  3940784050,
  980351604,
  3713745714,
  1749149687,
  3396870395,
  4211799374,
  3640570775,
  1161844396,
  3125318951,
  1431517754,
  545492359,
  4268468663,
  3499529547,
  1437099964,
  2702547544,
  3433638243,
  2581715763,
  2787789398,
  1060185593,
  1593081372,
  2418618748,
  4260947970,
  69676912,
  2159744348,
  86519011,
  2512459080,
  3838209314,
  1220612927,
  3339683548,
  133810670,
  1090789135,
  1078426020,
  1569222167,
  845107691,
  3583754449,
  4072456591,
  1091646820,
  628848692,
  1613405280,
  3757631651,
  526609435,
  236106946,
  48312990,
  2942717905,
  3402727701,
  1797494240,
  859738849,
  992217954,
  4005476642,
  2243076622,
  3870952857,
  3732016268,
  765654824,
  3490871365,
  2511836413,
  1685915746,
  3888969200,
  1414112111,
  2273134842,
  3281911079,
  4080962846,
  172450625,
  2569994100,
  980381355,
  4109958455,
  2819808352,
  2716589560,
  2568741196,
  3681446669,
  3329971472,
  1835478071,
  660984891,
  3704678404,
  4045999559,
  3422617507,
  3040415634,
  1762651403,
  1719377915,
  3470491036,
  2693910283,
  3642056355,
  3138596744,
  1364962596,
  2073328063,
  1983633131,
  926494387,
  3423689081,
  2150032023,
  4096667949,
  1749200295,
  3328846651,
  309677260,
  2016342300,
  1779581495,
  3079819751,
  111262694,
  1274766160,
  443224088,
  298511866,
  1025883608,
  3806446537,
  1145181785,
  168956806,
  3641502830,
  3584813610,
  1689216846,
  3666258015,
  3200248200,
  1692713982,
  2646376535,
  4042768518,
  1618508792,
  1610833997,
  3523052358,
  4130873264,
  2001055236,
  3610705100,
  2202168115,
  4028541809,
  2961195399,
  1006657119,
  2006996926,
  3186142756,
  1430667929,
  3210227297,
  1314452623,
  4074634658,
  4101304120,
  2273951170,
  1399257539,
  3367210612,
  3027628629,
  1190975929,
  2062231137,
  2333990788,
  2221543033,
  2438960610,
  1181637006,
  548689776,
  2362791313,
  3372408396,
  3104550113,
  3145860560,
  296247880,
  1970579870,
  3078560182,
  3769228297,
  1714227617,
  3291629107,
  3898220290,
  166772364,
  1251581989,
  493813264,
  448347421,
  195405023,
  2709975567,
  677966185,
  3703036547,
  1463355134,
  2715995803,
  1338867538,
  1343315457,
  2802222074,
  2684532164,
  233230375,
  2599980071,
  2000651841,
  3277868038,
  1638401717,
  4028070440,
  3237316320,
  6314154,
  819756386,
  300326615,
  590932579,
  1405279636,
  3267499572,
  3150704214,
  2428286686,
  3959192993,
  3461946742,
  1862657033,
  1266418056,
  963775037,
  2089974820,
  2263052895,
  1917689273,
  448879540,
  3550394620,
  3981727096,
  150775221,
  3627908307,
  1303187396,
  508620638,
  2975983352,
  2726630617,
  1817252668,
  1876281319,
  1457606340,
  908771278,
  3720792119,
  3617206836,
  2455994898,
  1729034894,
  1080033504,
  976866871,
  3556439503,
  2881648439,
  1522871579,
  1555064734,
  1336096578,
  3548522304,
  2579274686,
  3574697629,
  3205460757,
  3593280638,
  3338716283,
  3079412587,
  564236357,
  2993598910,
  1781952180,
  1464380207,
  3163844217,
  3332601554,
  1699332808,
  1393555694,
  1183702653,
  3581086237,
  1288719814,
  691649499,
  2847557200,
  2895455976,
  3193889540,
  2717570544,
  1781354906,
  1676643554,
  2592534050,
  3230253752,
  1126444790,
  2770207658,
  2633158820,
  2210423226,
  2615765581,
  2414155088,
  3127139286,
  673620729,
  2805611233,
  1269405062,
  4015350505,
  3341807571,
  4149409754,
  1057255273,
  2012875353,
  2162469141,
  2276492801,
  2601117357,
  993977747,
  3918593370,
  2654263191,
  753973209,
  36408145,
  2530585658,
  25011837,
  3520020182,
  2088578344,
  530523599,
  2918365339,
  1524020338,
  1518925132,
  3760827505,
  3759777254,
  1202760957,
  3985898139,
  3906192525,
  674977740,
  4174734889,
  2031300136,
  2019492241,
  3983892565,
  4153806404,
  3822280332,
  352677332,
  2297720250,
  60907813,
  90501309,
  3286998549,
  1016092578,
  2535922412,
  2839152426,
  457141659,
  509813237,
  4120667899,
  652014361,
  1966332200,
  2975202805,
  55981186,
  2327461051,
  676427537,
  3255491064,
  2882294119,
  3433927263,
  1307055953,
  942726286,
  933058658,
  2468411793,
  3933900994,
  4215176142,
  1361170020,
  2001714738,
  2830558078,
  3274259782,
  1222529897,
  1679025792,
  2729314320,
  3714953764,
  1770335741,
  151462246,
  3013232138,
  1682292957,
  1483529935,
  471910574,
  1539241949,
  458788160,
  3436315007,
  1807016891,
  3718408830,
  978976581,
  1043663428,
  3165965781,
  1927990952,
  4200891579,
  2372276910,
  3208408903,
  3533431907,
  1412390302,
  2931980059,
  4132332400,
  1947078029,
  3881505623,
  4168226417,
  2941484381,
  1077988104,
  1320477388,
  886195818,
  18198404,
  3786409000,
  2509781533,
  112762804,
  3463356488,
  1866414978,
  891333506,
  18488651,
  661792760,
  1628790961,
  3885187036,
  3141171499,
  876946877,
  2693282273,
  1372485963,
  791857591,
  2686433993,
  3759982718,
  3167212022,
  3472953795,
  2716379847,
  445679433,
  3561995674,
  3504004811,
  3574258232,
  54117162,
  3331405415,
  2381918588,
  3769707343,
  4154350007,
  1140177722,
  4074052095,
  668550556,
  3214352940,
  367459370,
  261225585,
  2610173221,
  4209349473,
  3468074219,
  3265815641,
  314222801,
  3066103646,
  3808782860,
  282218597,
  3406013506,
  3773591054,
  379116347,
  1285071038,
  846784868,
  2669647154,
  3771962079,
  3550491691,
  2305946142,
  453669953,
  1268987020,
  3317592352,
  3279303384,
  3744833421,
  2610507566,
  3859509063,
  266596637,
  3847019092,
  517658769,
  3462560207,
  3443424879,
  370717030,
  4247526661,
  2224018117,
  4143653529,
  4112773975,
  2788324899,
  2477274417,
  1456262402,
  2901442914,
  1517677493,
  1846949527,
  2295493580,
  3734397586,
  2176403920,
  1280348187,
  1908823572,
  3871786941,
  846861322,
  1172426758,
  3287448474,
  3383383037,
  1655181056,
  3139813346,
  901632758,
  1897031941,
  2986607138,
  3066810236,
  3447102507,
  1393639104,
  373351379,
  950779232,
  625454576,
  3124240540,
  4148612726,
  2007998917,
  544563296,
  2244738638,
  2330496472,
  2058025392,
  1291430526,
  424198748,
  50039436,
  29584100,
  3605783033,
  2429876329,
  2791104160,
  1057563949,
  3255363231,
  3075367218,
  3463963227,
  1469046755,
  985887462
];
var C_ORIG = [
  1332899944,
  1700884034,
  1701343084,
  1684370003,
  1668446532,
  1869963892
];
function _encipher(lr, off, P, S) {
  var n, l = lr[off], r = lr[off + 1];
  l ^= P[0];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[1];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[2];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[3];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[4];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[5];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[6];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[7];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[8];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[9];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[10];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[11];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[12];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[13];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[14];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[15];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[16];
  lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
  lr[off + 1] = l;
  return lr;
}
function _streamtoword(data, offp) {
  for (var i = 0, word = 0;i < 4; ++i)
    word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
  return { key: word, offp };
}
function _key(key, P, S) {
  var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0;i < plen; i++)
    sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
  for (i = 0;i < plen; i += 2)
    lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0;i < slen; i += 2)
    lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _ekskey(data, key, P, S) {
  var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0;i < plen; i++)
    sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
  offp = 0;
  for (i = 0;i < plen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0;i < slen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _crypt(b, salt, rounds, callback, progressCallback) {
  var cdata = C_ORIG.slice(), clen = cdata.length, err;
  if (rounds < 4 || rounds > 31) {
    err = Error("Illegal number of rounds (4-31): " + rounds);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.length !== BCRYPT_SALT_LEN) {
    err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  rounds = 1 << rounds >>> 0;
  var P, S, i = 0, j;
  if (typeof Int32Array === "function") {
    P = new Int32Array(P_ORIG);
    S = new Int32Array(S_ORIG);
  } else {
    P = P_ORIG.slice();
    S = S_ORIG.slice();
  }
  _ekskey(salt, b, P, S);
  function next2() {
    if (progressCallback)
      progressCallback(i / rounds);
    if (i < rounds) {
      var start = Date.now();
      for (;i < rounds; ) {
        i = i + 1;
        _key(b, P, S);
        _key(salt, P, S);
        if (Date.now() - start > MAX_EXECUTION_TIME)
          break;
      }
    } else {
      for (i = 0;i < 64; i++)
        for (j = 0;j < clen >> 1; j++)
          _encipher(cdata, j << 1, P, S);
      var ret = [];
      for (i = 0;i < clen; i++)
        ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
      if (callback) {
        callback(null, ret);
        return;
      } else
        return ret;
    }
    if (callback)
      nextTick(next2);
  }
  if (typeof callback !== "undefined") {
    next2();
  } else {
    var res;
    while (true)
      if (typeof (res = next2()) !== "undefined")
        return res || [];
  }
}
function _hash(password, salt, callback, progressCallback) {
  var err;
  if (typeof password !== "string" || typeof salt !== "string") {
    err = Error("Invalid string / salt: Not a string");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var minor2, offset;
  if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
    err = Error("Invalid salt version: " + salt.substring(0, 2));
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.charAt(2) === "$")
    minor2 = String.fromCharCode(0), offset = 3;
  else {
    minor2 = salt.charAt(2);
    if (minor2 !== "a" && minor2 !== "b" && minor2 !== "y" || salt.charAt(3) !== "$") {
      err = Error("Invalid salt revision: " + salt.substring(2, 4));
      if (callback) {
        nextTick(callback.bind(this, err));
        return;
      } else
        throw err;
    }
    offset = 4;
  }
  if (salt.charAt(offset + 2) > "$") {
    err = Error("Missing salt rounds");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
  password += minor2 >= "a" ? "\x00" : "";
  var passwordb = utf8Array(password), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
  function finish(bytes) {
    var res = [];
    res.push("$2");
    if (minor2 >= "a")
      res.push(minor2);
    res.push("$");
    if (rounds < 10)
      res.push("0");
    res.push(rounds.toString());
    res.push("$");
    res.push(base64_encode(saltb, saltb.length));
    res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
    return res.join("");
  }
  if (typeof callback == "undefined")
    return finish(_crypt(passwordb, saltb, rounds));
  else {
    _crypt(passwordb, saltb, rounds, function(err2, bytes) {
      if (err2)
        callback(err2, null);
      else
        callback(null, finish(bytes));
    }, progressCallback);
  }
}

// src/controllers/auth.controller.ts
var import_dotenv2 = __toESM(require_main(), 1);
import { join as join3 } from "path";

// src/utils/function.ts
import crypto5 from "crypto";
var hash256 = (text) => {
  const hash3 = crypto5.createHash("sha256");
  hash3.update(text);
  return hash3.digest("hex");
};

// src/controllers/auth.controller.ts
var __dirname = "D:\\PROJECT\\WEB_APP\\04-ENVIROMENTS\\src\\controllers";
import_dotenv2.default.config({ path: join3(__dirname, "../../.env") });
var registerController = async ({ body, set: set2 }) => {
  console.log("เริ่มกระบวนการลงทะเบียน");
  const { username, password, cid, full_name, email } = body;
  try {
    const hashedCidForCheck = hash256(cid);
    console.log("กำลังตรวจสอบว่ามีชื่อผู้ใช้ อีเมล หรือเลขบัตรประชาชนซ้ำหรือไม่...");
    const existingUser = await pool.query("SELECT * FROM users WHERE username = $1 OR email = $2 OR cid = $3", [username, email, hashedCidForCheck]);
    if (existingUser.rows.length > 0) {
      const existingRecord = existingUser.rows[0];
      if (existingRecord.username === username) {
        console.log("พบชื่อผู้ใช้ซ้ำ");
        set2.status = 400;
        return { message: "ชื่อผู้ใช้นี้มีในระบบแล้ว" };
      } else if (existingRecord.email === email) {
        console.log("พบอีเมลซ้ำ");
        set2.status = 400;
        return { message: "อีเมลนี้มีในระบบแล้ว" };
      } else if (existingRecord.cid === hashedCidForCheck) {
        console.log("พบเลขบัตรประชาชนซ้ำ");
        set2.status = 400;
        return { message: "เลขบัตรประชาชนนี้ได้ลงทะเบียนในระบบแล้ว" };
      } else {
        console.log("พบข้อมูลซ้ำ");
        set2.status = 400;
        return { message: "ข้อมูลนี้มีในระบบแล้ว" };
      }
    }
    try {
      console.log("กำลังตรวจสอบเลขบัตรประชาชนกับ API...");
      const checkCidUrl = `${process.env.CHECK_CID_URL}/api/check-doctor?cid=${cid}`;
      const checkCidResponse = await fetch(checkCidUrl, {
        method: "GET",
        headers: {
          "cid-api-token": "!banglen@11301_nakhonpathom"
        }
      });
      if (!checkCidResponse.ok && checkCidResponse.status !== 404) {
        console.error("เกิดข้อผิดพลาดในการตรวจสอบเลขบัตรประชาชน:", await checkCidResponse.text());
        set2.status = 500;
        return { message: "เกิดข้อผิดพลาดในการเชื่อมต่อกับระบบตรวจสอบเลขบัตรประชาชน กรุณาลองใหม่อีกครั้ง" };
      }
      const cidData = await checkCidResponse.json();
      console.log("ผลการตรวจสอบเลขบัตรประชาชน:", cidData);
      if (!cidData.success || cidData.statusCode === 404) {
        console.log("ไม่พบข้อมูลเลขบัตรประชาชนในระบบ");
        set2.status = 400;
        return { message: "ไม่พบข้อมูลเลขบัตรประชาชนนี้ในระบบ ไม่สามารถลงทะเบียนได้" };
      }
      console.log("ตรวจสอบเลขบัตรประชาชนสำเร็จ: " + cidData.message);
    } catch (error3) {
      console.error("เกิดข้อผิดพลาดในการตรวจสอบเลขบัตรประชาชน:", error3);
      set2.status = 500;
      return { message: "เกิดข้อผิดพลาดในการตรวจสอบเลขบัตรประชาชน กรุณาลองใหม่อีกครั้ง" };
    }
    console.log("กำลังเข้ารหัสรหัสผ่าน...");
    const hashedPassword = await hash2(password, 10);
    console.log("กำลังบันทึกข้อมูลผู้ใช้ใหม่ลงในฐานข้อมูล...");
    const hashedCid = hash256(cid);
    console.log("เข้ารหัส CID เรียบร้อยแล้ว");
    await pool.query("INSERT INTO users (username, password, full_name, email, role, cid) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *", [username, hashedPassword, full_name, email, "user", hashedCid]);
    console.log("ลงทะเบียนสำเร็จ");
    set2.status = 201;
    return { message: "ลงทะเบียนสำเร็จ" };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการลงทะเบียน:", error3);
    set2.status = 500;
    return { message: "เกิดข้อผิดพลาดในการลงทะเบียน" };
  }
};
var loginController = async ({ body, jwt: jwt2, set: set2 }) => {
  console.log("เริ่มกระบวนการเข้าสู่ระบบ");
  const { username, password } = body;
  try {
    console.log("กำลังค้นหาข้อมูลผู้ใช้ในฐานข้อมูล...");
    const user = await pool.query("SELECT * FROM users WHERE username = $1", [username]);
    if (user.rows.length === 0) {
      console.log("ไม่พบชื่อผู้ใช้ในระบบ");
      set2.status = 401;
      return { success: false, message: "ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง" };
    }
    console.log("กำลังตรวจสอบรหัสผ่าน...");
    const validPassword = await compare(password, user.rows[0].password);
    if (!validPassword) {
      console.log("รหัสผ่านไม่ถูกต้อง");
      set2.status = 401;
      return { success: false, message: "ชื่อผู้ใช้หรือรหัสผ่านไม่ถูกต้อง" };
    }
    console.log("กำลังสร้าง JWT token...");
    const token = await jwt2.sign({
      user_id: user.rows[0].user_id,
      username: user.rows[0].username,
      full_name: user.rows[0].full_name,
      role: user.rows[0].role,
      iat: Math.floor(Date.now() / 1000)
    });
    console.log("สร้าง token สำเร็จ:", token.substring(0, 20) + "...");
    const expiresInSeconds = getExpiresInSeconds();
    const expiresAt = new Date(Date.now() + expiresInSeconds * 1000);
    console.log("กำลังบันทึก token ลงในฐานข้อมูล...");
    await pool.query("INSERT INTO tokens (user_id, token, expires_at, login_last) VALUES ($1, $2, $3, CURRENT_TIMESTAMP) " + "ON CONFLICT (user_id) DO UPDATE SET " + "token = EXCLUDED.token, " + "expires_at = EXCLUDED.expires_at, " + "login_last = CURRENT_TIMESTAMP", [user.rows[0].user_id, token, expiresAt]);
    set2.status = 302;
    set2.headers = {
      Location: "/water-dashboard",
      "Set-Cookie": `auth_token=${token}; HttpOnly; Path=/; Max-Age=${getExpiresInSeconds()}; SameSite=strict`
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการเข้าสู่ระบบ:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการเข้าสู่ระบบ" };
  }
};
var logoutController = async ({ cookie, set: set2 }) => {
  console.log("กำลังออกจากระบบ...");
  const cookieObj = cookie;
  const token = cookieObj.auth_token?.toString() || undefined;
  if (token) {
    console.log("กำลังลบ token จากฐานข้อมูล...");
    try {
      await pool.query("DELETE FROM tokens WHERE token = $1", [token]);
      console.log("ลบ token สำเร็จ");
    } catch (error3) {
      console.error("เกิดข้อผิดพลาดในการลบ token:", error3);
    }
  }
  set2.headers = {
    "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`,
    Location: "/"
  };
  set2.status = 302;
  console.log("ออกจากระบบสำเร็จ");
};
var statusController = async ({ cookie, jwt: jwt2 }) => {
  console.log("ตรวจสอบสถานะการเข้าสู่ระบบ");
  const cookieObj = cookie;
  const token = cookieObj.auth_token?.toString() || undefined;
  console.log("Token type:", typeof token);
  console.log("Token value:", token ? token.substring(0, 20) + "..." : "ไม่มี");
  if (!token) {
    console.log("ไม่พบ token ใน cookie");
    return {
      isAuthenticated: false,
      user: null
    };
  }
  try {
    console.log("กำลังตรวจสอบ token ในฐานข้อมูล...");
    const tokenResult = await pool.query("SELECT * FROM tokens WHERE token = $1 AND expires_at > NOW()", [token]);
    if (tokenResult.rows.length === 0) {
      console.log("ไม่พบ token ในฐานข้อมูลหรือ token หมดอายุแล้ว");
      return {
        isAuthenticated: false,
        user: null,
        message: "Token หมดอายุหรือไม่ถูกต้อง กรุณาเข้าสู่ระบบใหม่"
      };
    }
    console.log("กำลังตรวจสอบความถูกต้องของ token...");
    const payload = await jwt2.verify(token);
    if (!payload) {
      console.log("token ไม่ถูกต้อง");
      return {
        isAuthenticated: false,
        user: null
      };
    }
    console.log("token ถูกต้องและยังไม่หมดอายุ - ผู้ใช้:", payload.username);
    return {
      isAuthenticated: true,
      user: payload
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการตรวจสอบ token:", error3);
    return {
      isAuthenticated: false,
      user: null,
      message: "เกิดข้อผิดพลาดในการตรวจสอบ token"
    };
  }
};

// src/routes/routes.controllers.ts
var authController = new Elysia({ prefix: "/api/auth" }).use(import_cookie2.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).post("/register", registerController).post("/login", loginController).get("/logout", logoutController).get("/status", statusController);

// src/routes/static.routes.ts
var staticRoutes = new Elysia().get("/style.css", () => Bun.file("public/style.css")).get("/script.js", () => Bun.file("public/script.js")).get("/login.js", () => Bun.file("public/login.js")).get("/register.js", () => Bun.file("public/register.js")).get("/electric-dashboard.css", () => Bun.file("public/main/electric/electric-dashboard.css")).get("/electric-dashboard.js", () => Bun.file("public/main/electric/electric-dashboard.js")).get("/waste-dashboard.css", () => Bun.file("public/main/waste/waste-dashboard.css")).get("/waste-dashboard.js", () => Bun.file("public/main/waste/waste-dashboard.js")).get("/water-dashboard.css", () => Bun.file("public/main/water-treat/water-dashboard.css")).get("/water-dashboard.js", () => Bun.file("public/main/water-treat/water-dashboard.js")).get("/electric-manage.css", () => Bun.file("public/main/electric/electric-manage.css")).get("/electric-manage.js", () => Bun.file("public/main/electric/electric-manage.js")).get("/waste-manage.css", () => Bun.file("public/main/waste/waste-manage.css")).get("/waste-manage.js", () => Bun.file("public/main/waste/waste-manage.js")).get("/water-manage.css", () => Bun.file("public/main/water-treat/water-manage.css")).get("/water-manage.js", () => Bun.file("public/main/water-treat/water-manage.js")).get("/assets/:module/:file", ({ params }) => {
  const { module, file: file3 } = params;
  if (module === "electric") {
    return Bun.file(`public/main/electric/${file3}`);
  } else if (module === "waste") {
    return Bun.file(`public/main/waste/${file3}`);
  } else if (module === "water") {
    return Bun.file(`public/main/water-treat/${file3}`);
  } else if (module === "common") {
    return Bun.file(`public/${file3}`);
  } else {
    return new Response("Not Found", { status: 404 });
  }
}).get("/assets/water/water-treat-dashboard-css/:file", ({ params }) => {
  return Bun.file(`public/main/water-treat/water-treat-dashboard-css/${params.file}`);
}).get("/assets/water/water-treat-dashboard-js/:file", ({ params }) => {
  return Bun.file(`public/main/water-treat/water-treat-dashboard-js/${params.file}`);
}).get("/assets/water/water-treat-manage-css/:file", ({ params }) => {
  return Bun.file(`public/main/water-treat/water-treat-manage-css/${params.file}`);
}).get("/assets/water/water-treat-manage-js/:file", ({ params }) => {
  return Bun.file(`public/main/water-treat/water-treat-manage-js/${params.file}`);
}).get("/assets/waste/waste-dashboard-css/:file", ({ params }) => {
  return Bun.file(`public/main/waste/waste-dashboard-css/${params.file}`);
}).get("/assets/waste/waste-dashboard-js/:file", ({ params }) => {
  return Bun.file(`public/main/waste/waste-dashboard-js/${params.file}`);
}).get("/assets/waste/waste-manage-css/:file", ({ params }) => {
  return Bun.file(`public/main/waste/waste-manage-css/${params.file}`);
}).get("/assets/waste/waste-manage-js/:file", ({ params }) => {
  return Bun.file(`public/main/waste/waste-manage-js/${params.file}`);
});
console.log("กำหนดเส้นทางสำหรับไฟล์ static สำเร็จ");

// src/routes/main.routes.ts
var import_cookie3 = __toESM(require_cjs4(), 1);
var mainRoutes = new Elysia().use(import_cookie3.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).get("/", () => {
  console.log("มีการเรียกใช้งานหน้าแรก");
  return new Response(null, {
    status: 302,
    headers: { Location: "/water-dashboard" }
  });
}).get("/login", async ({ cookie: cookie3, jwt: jwt2, query }) => {
  console.log("มีการเรียกใช้งานหน้า login");
  const cookieObj = cookie3;
  const token = cookieObj.auth_token?.toString();
  if (token) {
    try {
      const payload = await jwt2.verify(token);
      if (payload) {
        const tokenResult = await pool.query("SELECT * FROM tokens WHERE token = $1 AND expires_at > NOW()", [token]);
        if (tokenResult.rows.length > 0) {
          return new Response(null, {
            status: 302,
            headers: { Location: "/water-dashboard" }
          });
        } else {
          console.log("Token หมดอายุหรือไม่มีในระบบ");
          return new Response(Bun.file("public/login.html"), {
            headers: {
              "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
            }
          });
        }
      }
    } catch (error3) {
      console.error("เกิดข้อผิดพลาดในการตรวจสอบ token:", error3);
      return new Response(Bun.file("public/login.html"), {
        headers: {
          "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
        }
      });
    }
  }
  return Bun.file("public/login.html");
}).get("/register", async ({ cookie: cookie3, jwt: jwt2 }) => {
  console.log("มีการเรียกใช้งานหน้า register");
  const cookieObj = cookie3;
  const token = cookieObj.auth_token?.toString();
  if (token) {
    try {
      const payload = await jwt2.verify(token);
      if (payload) {
        const tokenResult = await pool.query("SELECT * FROM tokens WHERE token = $1 AND expires_at > NOW()", [token]);
        if (tokenResult.rows.length > 0) {
          return new Response(null, {
            status: 302,
            headers: { Location: "/water-dashboard" }
          });
        } else {
          console.log("Token หมดอายุหรือไม่มีในระบบ");
          return new Response(Bun.file("public/register.html"), {
            headers: {
              "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
            }
          });
        }
      }
    } catch (error3) {
      console.error("เกิดข้อผิดพลาดในการตรวจสอบ token:", error3);
      return new Response(Bun.file("public/register.html"), {
        headers: {
          "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
        }
      });
    }
  }
  return Bun.file("public/register.html");
}).get("/electric-dashboard", () => {
  console.log("มีการเรียกใช้งานหน้า electric dashboard (clean URL)");
  return Bun.file("public/main/electric/electric-dashboard.html");
}).get("/water-dashboard", () => {
  console.log("มีการเรียกใช้งานหน้า water dashboard (clean URL)");
  return Bun.file("public/main/water-treat/water-dashboard.html");
}).get("/waste-dashboard", () => {
  console.log("มีการเรียกใช้งานหน้า waste dashboard (clean URL)");
  return Bun.file("public/main/waste/waste-dashboard.html");
});
console.log("กำหนดเส้นทางหลักสำเร็จ");

// src/routes/fallback.routes.ts
var fallbackRoutes = new Elysia().get("/main/*", () => {
  console.log("มีการพยายามเข้าถึงไฟล์ในโฟลเดอร์ main โดยตรง - กำลังเปลี่ยนเส้นทางไปหน้าหลัก");
  return new Response(null, {
    status: 302,
    headers: { Location: "/water-dashboard" }
  });
}).all("*", ({ path }) => {
  console.log(`ไม่พบเส้นทาง: ${path}`);
  return new Response(null, {
    status: 302,
    headers: { Location: "/water-dashboard" }
  });
});
console.log("กำหนดเส้นทาง fallback สำเร็จ");

// src/routes/protected.routes.ts
var import_cookie4 = __toESM(require_cjs4(), 1);
var protectedRoutes = new Elysia().use(import_cookie4.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).derive(async ({ cookie: cookie4, jwt: jwt2, set: set2 }) => {
  console.log("เริ่มตรวจสอบการยืนยันตัวตน");
  if (!cookie4 || typeof cookie4 !== "object") {
    console.log("ไม่พบข้อมูล cookie");
    set2.status = 302;
    set2.headers = {
      Location: "/login",
      "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
    };
    return { authorized: false };
  }
  const cookieObj = cookie4;
  const token = cookieObj.auth_token?.toString() || undefined;
  console.log("Token type:", typeof token);
  console.log("Token value:", token ? token.substring(0, 20) + "..." : "ไม่มี");
  if (!token) {
    console.log("ไม่พบ token ใน cookie - กำลังเปลี่ยนเส้นทางไปยังหน้าเข้าสู่ระบบ");
    set2.status = 302;
    set2.headers = {
      Location: "/login",
      "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
    };
    return { authorized: false };
  }
  try {
    console.log("กำลังตรวจสอบ token ในฐานข้อมูล...");
    const tokenResult = await pool.query("SELECT * FROM tokens WHERE token = $1 AND expires_at > NOW()", [token]);
    if (tokenResult.rows.length === 0) {
      console.log("ไม่พบ token ในฐานข้อมูลหรือ token หมดอายุแล้ว - กำลังเปลี่ยนเส้นทางไปยังหน้าเข้าสู่ระบบ");
      set2.status = 302;
      set2.headers = {
        Location: "/login",
        "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
      };
      return { authorized: false };
    }
    console.log("กำลังตรวจสอบความถูกต้องของ token...");
    const payload = await jwt2.verify(token);
    if (!payload) {
      console.log("token ไม่ถูกต้อง - กำลังเปลี่ยนเส้นทางไปยังหน้าเข้าสู่ระบบ");
      set2.status = 302;
      set2.headers = {
        Location: "/login",
        "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
      };
      return { authorized: false };
    }
    console.log("ตรวจสอบ token สำเร็จ - ผู้ใช้:", payload);
    return { authorized: true, user: payload };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการตรวจสอบ token:", error3);
    console.log("กำลังเปลี่ยนเส้นทางไปยังหน้าเข้าสู่ระบบ");
    set2.status = 302;
    set2.headers = {
      Location: "/login",
      "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
    };
    return { authorized: false };
  }
}).get("/electric-manage", async ({ authorized, user }) => {
  if (!authorized) {
    return new Response(null, {
      status: 302,
      headers: {
        Location: "/login",
        "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
      }
    });
  }
  console.log("กำลังเข้าถึงหน้าจัดการระบบไฟฟ้า โดยผู้ใช้:", user?.username);
  return Bun.file("public/main/electric/electric-manage.html");
}).get("/water-manage", async ({ authorized, user }) => {
  if (!authorized) {
    return new Response(null, {
      status: 302,
      headers: {
        Location: "/login",
        "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
      }
    });
  }
  console.log("กำลังเข้าถึงหน้าจัดการระบบบำบัดน้ำ โดยผู้ใช้:", user?.username);
  return Bun.file("public/main/water-treat/water-manage.html");
}).get("/waste-manage", async ({ authorized, user }) => {
  if (!authorized) {
    return new Response(null, {
      status: 302,
      headers: {
        Location: "/login",
        "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
      }
    });
  }
  console.log("กำลังเข้าถึงหน้าจัดการระบบจัดการขยะ โดยผู้ใช้:", user?.username);
  return Bun.file("public/main/waste/waste-manage.html");
});

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
var kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
var typeOfTest = (type2) => (thing) => typeof thing === type2;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject3 = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject3(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length;i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0;i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key2;
  while (i-- > 0) {
    _key2 = keys[i];
    if (key === _key2.toLowerCase()) {
      return _key2;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length;i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject3(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject3(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(typeof setImmediate === "function", isFunction(_global.postMessage));
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject3,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message2, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error3, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error3, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error3.message, code, config, request, response);
  axiosError.cause = error3;
  axiosError.name = error3.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData);
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode3(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\x00"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder3) {
  const _encode = encoder3 ? function(value) {
    return encoder3.call(this, value, encode3);
  } : encode3;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode4(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode4;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/node/index.js
import crypto6 from "crypto";

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
import url from "url";
var URLSearchParams_default = url.URLSearchParams;

// node_modules/axios/lib/platform/node/index.js
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  crypto6.randomFillSync(randomValues);
  for (let i = 0;i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }
  return str;
};
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var exports_utils = {};
__export(exports_utils, {
  origin: () => origin,
  navigator: () => _navigator,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasBrowserEnv: () => hasBrowserEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || undefined;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...exports_utils,
  ...node_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams, Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0;i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder3) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder3 || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData, this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": undefined
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split(`
`).forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === undefined || _rewrite === true || _rewrite === undefined && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message2, config, request) {
  AxiosError_default.call(this, message2 == null ? "canceled" : message2, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError_default("Request failed with status code " + response.status, [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
import http from "http";
import https from "https";
import util4 from "util";
import zlib from "zlib";

// node_modules/axios/lib/env/data.js
var VERSION = "1.8.4";

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri2);
  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri2 = protocol.length ? uri2.slice(protocol.length + 1) : uri2;
    const match = DATA_URL_PATTERN.exec(uri2);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// node_modules/axios/lib/adapters/http.js
import stream3 from "stream";

// node_modules/axios/lib/helpers/AxiosTransformStream.js
import stream from "stream";
var kInternals = Symbol("internals");

class AxiosTransformStream extends stream.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1000 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
var AxiosTransformStream_default = AxiosTransformStream;

// node_modules/axios/lib/adapters/http.js
import { EventEmitter } from "events";

// node_modules/axios/lib/helpers/formDataToStream.js
import util3 from "util";
import { Readable } from "stream";

// node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = typeof TextEncoder === "function" ? new TextEncoder : new util3.TextEncoder;
var CRLF = `\r
`;
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async* encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}
var formDataToStream = (form3, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form3)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form3.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
var formDataToStream_default = formDataToStream;

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
import stream2 from "stream";

class ZlibHeaderTransformStream extends stream2.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
}
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify;

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(zlib.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = platform_default.protocols.map((protocol) => {
  return protocol + ":";
});
var flushOnFinish = (stream4, [throttled, flush]) => {
  stream4.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve2, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve2(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var resolveFamily = ({ address, family }) => {
  if (!utils_default.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
var buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
var http_default = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve2, reject, onDone) {
    let { data, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter;
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve2, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream3.Readable.from(convertedData);
      }
      return settle(resolve2, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default,
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_BAD_REQUEST, config));
    }
    const headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const { onUploadProgress, onDownloadProgress } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util4.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {}
      }
    } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = stream3.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {} else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", AxiosError_default.ERR_BAD_REQUEST, config));
      }
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError_default("Request body larger than maxBodyLength limit", AxiosError_default.ERR_BAD_REQUEST, config));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = stream3.Readable.from(data, { objectMode: false });
      }
      data = stream3.pipeline([data, new AxiosTransformStream_default({
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", flushOnFinish(data, progressEventDecorator(contentLength, progressEventReducer(asyncDecorator(onUploadProgress), false, 3))));
    }
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path;
    try {
      path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set("Accept-Encoding", "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""), false);
    const options = {
      path,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils_default.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream_default({
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(transformStream, progressEventDecorator(responseLength, progressEventReducer(asyncDecorator(onDownloadProgress), true, 3))));
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default);
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(zlib.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? stream3.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = stream3.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve2, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default("stream has been aborted", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest);
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError_default.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve2, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1000 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError_default("error trying to parse `config.timeout` to int", AxiosError_default.ERR_BAD_OPTION_VALUE, config, req));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = config.transitional || transitional_default;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, req));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform_default.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(new URL(platform_default.origin), platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? {
  write(name, value, expires, path, domain, secure) {
    const cookie4 = [name + "=" + encodeURIComponent(value)];
    utils_default.isNumber(expires) && cookie4.push("expires=" + new Date(expires).toGMTString());
    utils_default.isString(path) && cookie4.push("path=" + path);
    utils_default.isString(domain) && cookie4.push("domain=" + domain);
    secure === true && cookie4.push("secure");
    document.cookie = cookie4.join("; ");
  },
  read(name) {
    const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
    return match ? decodeURIComponent(match[3]) : null;
  },
  remove(name) {
    this.write(name, "", Date.now() - 86400000);
  }
} : {
  write() {},
  read() {
    return null;
  },
  remove() {}
};

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type2, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest;
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    requestData === undefined && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController;
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream4) {
  if (stream4[Symbol.asyncIterator]) {
    yield* stream4;
    return;
  }
  const reader = stream4.getReader();
  try {
    for (;; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream4, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream4, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder3) => (str) => encoder3.encode(str))(new TextEncoder) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream,
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
    !resolvers[type2] && (resolvers[type2] = utils_default.isFunction(res[type2]) ? (res2) => res2[type2]() : (_, config) => {
      throw new AxiosError_default(`Response type '${type2}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response);
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
      response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
        flush && flush();
        unsubscribe && unsubscribe();
      }), options);
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve2, reject) => {
      settle(resolve2, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request), {
        cause: err.cause || err
      });
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {}
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0;i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === undefined) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
      let s = length ? reasons.length > 1 ? `since :
` + reasons.map(renderReason).join(`
`) : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators[type2] = function validator(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError_default.ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;

class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default,
      response: new InterceptorManager_default
    };
  }
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error;
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += `
` + stack;
          }
        } catch (e) {}
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== undefined) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== undefined) {} else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(headers.common, headers[config.method]);
    headers && utils_default.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
      delete headers[method];
    });
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error3) {
        onRejected.call(this, error3);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error3) {
      return Promise.reject(error3);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message2, config, request);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController;
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// src/config/auth.provider.config.ts
var import_dotenv3 = __toESM(require_main(), 1);
import { join as join4 } from "path";
var __dirname = "D:\\PROJECT\\WEB_APP\\04-ENVIROMENTS\\src\\config";
import_dotenv3.default.config({ path: join4(__dirname, "../../.env") });
var authConfig2 = {
  healthId: {
    baseUrl: process.env.HEALTH_ID_URL || "",
    clientId: process.env.HEALTH_ID_CLIENT_ID || "",
    clientSecret: process.env.HEALTH_ID_CLIENT_SECRET || ""
  },
  providerId: {
    baseUrl: process.env.PROVIDER_ID_URL || "",
    clientId: process.env.PROVIDER_ID_CLIENT_ID || "",
    clientSecret: process.env.PROVIDER_ID_CLIENT_SECRET || ""
  },
  redirect: {
    redirectUri: process.env.CALL_BACK_URL || ""
  }
};

// src/controllers/auth.provider.controller.ts
class AuthControllerProvider {
  getAuthorizationUrl() {
    if (!authConfig2.healthId.clientId) {
      throw new Error("Client ID is required");
    }
    const params = new URLSearchParams({
      client_id: authConfig2.healthId.clientId,
      redirect_uri: authConfig2.redirect.redirectUri,
      response_type: "code"
    });
    return `${authConfig2.healthId.baseUrl}/oauth/redirect?${params.toString()}`;
  }
  async getAccessTokenHealthId(code) {
    try {
      console.log("\uD83D\uDD04 กำลังขอ Access Token จาก HealthID");
      console.log("\uD83D\uDCE4 ส่งข้อมูล:", {
        grant_type: "authorization_code",
        code,
        redirect_uri: authConfig2.redirect.redirectUri,
        client_id: authConfig2.healthId.clientId
      });
      const response = await axios_default.post(`${authConfig2.healthId.baseUrl}/api/v1/token`, {
        grant_type: "authorization_code",
        code,
        redirect_uri: authConfig2.redirect.redirectUri,
        client_id: authConfig2.healthId.clientId,
        client_secret: authConfig2.healthId.clientSecret
      }, {
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        }
      });
      console.log("\uD83D\uDCE5 ได้รับการตอบกลับ:", {
        status: response.status,
        statusText: response.statusText,
        data: {
          access_token: response.data.data.access_token,
          token_type: response.data.data.token_type,
          expires_in: response.data.data.expires_in,
          account_id: response.data.data.account_id
        }
      });
      return response.data.data;
    } catch (error3) {
      console.error("❌ เกิดข้อผิดพลาดในการขอ Access Token:", error3);
      throw new Error("Failed to get access token");
    }
  }
  async getProviderIDToken(healthIdToken) {
    try {
      const response = await axios_default.post(`${authConfig2.providerId.baseUrl}/api/v1/services/token`, {
        client_id: authConfig2.providerId.clientId,
        secret_key: authConfig2.providerId.clientSecret,
        token_by: "Health ID",
        token: healthIdToken
      }, {
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (response.data.status === 200) {
        return response.data.data;
      }
      throw new Error(response.data.message || "Failed to get provider token");
    } catch (error3) {
      console.error("Error getting provider token:", error3);
      throw new Error("Failed to get provider token");
    }
  }
  async getProviderProfile(providerToken) {
    try {
      const response = await axios_default.get(`${authConfig2.providerId.baseUrl}/api/v1/services/profile`, {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${providerToken}`,
          "client-id": authConfig2.providerId.clientId,
          "secret-key": authConfig2.providerId.clientSecret
        },
        params: {
          moph_center_token: "1",
          moph_idp_permission: "1",
          position_type: "1"
        }
      });
      if (response.data.status === 200) {
        return response.data.data;
      }
      throw new Error(response.data.message || "Failed to get provider profile");
    } catch (error3) {
      console.error("Error getting provider profile:", error3);
      throw new Error("Failed to get provider profile");
    }
  }
  async loginProvider() {
    try {
      console.log("\uD83D\uDCDD เริ่มกระบวนการเข้าสู่ระบบ");
      const authUrl = this.getAuthorizationUrl();
      console.log(`\uD83D\uDD04 กำลังเปลี่ยนเส้นทางไปยัง: ${authUrl}`);
      return Response.redirect(authUrl);
    } catch (error3) {
      console.error("Error getting provider profile:", error3);
      throw new Error("Failed to get provider profile");
    }
  }
  async callbackProvider({ query, jwt: jwt2, set: set2 }) {
    try {
      const { code } = query;
      if (!code) {
        console.error("❌ ไม่พบ code จากระบบ");
        return Response.redirect("/login?error=missing_code");
      }
      const healthIdToken = await this.getAccessTokenHealthId(code);
      const providerIdToken = await this.getProviderIDToken(healthIdToken.access_token);
      console.log("\uD83D\uDCE5 ได้รับ Provider ID Token:", providerIdToken.access_token.substring(0, 10) + "...");
      const profile = await this.getProviderProfile(providerIdToken.access_token);
      console.log("\uD83D\uDCE5 ได้รับข้อมูล Provider Profile สำเร็จ");
      if (!profile.hash_cid) {
        console.error("❌ ไม่พบข้อมูล hash_cid ใน Provider Profile");
        return Response.redirect("/login?error=user_not_found");
      }
      console.log("\uD83D\uDD0D กำลังตรวจสอบ hash_cid กับฐานข้อมูล...");
      const userResult = await pool.query("SELECT * FROM users WHERE cid = $1", [profile.hash_cid]);
      if (userResult.rows.length === 0) {
        console.log("❌ ไม่พบข้อมูลผู้ใช้ที่ตรงกับ hash_cid นี้");
        return Response.redirect("/login?error=user_not_found");
      }
      const user = userResult.rows[0];
      console.log("✅ พบข้อมูลผู้ใช้ที่ตรงกับ hash_cid");
      const token = await jwt2.sign({
        user_id: user.user_id,
        username: user.username,
        full_name: user.full_name,
        role: user.role,
        iat: Math.floor(Date.now() / 1000)
      });
      console.log("\uD83D\uDD11 สร้าง JWT token สำเร็จ");
      const expiresInSeconds = getExpiresInSeconds();
      const expiresAt = new Date(Date.now() + expiresInSeconds * 1000);
      await pool.query("INSERT INTO tokens (user_id, token, expires_at, login_last) VALUES ($1, $2, $3, CURRENT_TIMESTAMP) " + "ON CONFLICT (user_id) DO UPDATE SET " + "token = EXCLUDED.token, " + "expires_at = EXCLUDED.expires_at, " + "login_last = CURRENT_TIMESTAMP", [user.user_id, token, expiresAt]);
      console.log("\uD83D\uDE80 เข้าสู่ระบบสำเร็จ กำลังเปลี่ยนเส้นทางไปยังหน้าแดชบอร์ด");
      const response = new Response(null, {
        status: 302,
        headers: {
          Location: "/water-dashboard?login_success=provider",
          "Set-Cookie": `auth_token=${token}; HttpOnly; Path=/; Max-Age=${getExpiresInSeconds()}; SameSite=Lax`
        }
      });
      return response;
    } catch (error3) {
      console.error("❌ เกิดข้อผิดพลาดในการยืนยันตัวตน:", error3);
      return Response.redirect("/login?error=auth_failed");
    }
  }
}

// src/routes/routes.provider.ts
var import_cookie5 = __toESM(require_cjs4(), 1);
var authProvider = new AuthControllerProvider;
console.log("\uD83D\uDE80 เริ่มต้นระบบ Authentication");
var authRoutesProvider = new Elysia({ prefix: "/auth" }).use(import_cookie5.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).get("/login-provider", () => authProvider.loginProvider()).get("/callback-provider", ({ query, jwt: jwt2, set: set2 }) => authProvider.callbackProvider({ query, jwt: jwt2, set: set2 }));

// src/routes/routes-water-treat/routes.enviroments.ts
var import_cookie6 = __toESM(require_cjs4(), 1);

// src/controllers/data-events.controller.ts
var clients = new Map;
async function createDataEventStream({ set: set2 }) {
  set2.headers = {
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
    Connection: "keep-alive",
    "Access-Control-Allow-Origin": "*"
  };
  const clientId = Date.now().toString();
  console.log(`Client connected: ${clientId}`);
  const stream4 = new ReadableStream({
    start(controller) {
      clients.set(clientId, controller);
      const initialData = `data: ${JSON.stringify({
        type: "connected",
        message: "Connected successfully",
        timestamp: new Date().toISOString()
      })}

`;
      controller.enqueue(new TextEncoder().encode(initialData));
    },
    cancel() {
      clients.delete(clientId);
      console.log(`Client disconnected: ${clientId}`);
    }
  });
  return new Response(stream4);
}
function notifyClients(eventType, data) {
  const eventData = `data: ${JSON.stringify({
    type: eventType,
    data,
    timestamp: new Date().toISOString()
  })}

`;
  const encodedData = new TextEncoder().encode(eventData);
  clients.forEach((controller, clientId) => {
    try {
      controller.enqueue(encodedData);
    } catch (error3) {
      console.error(`Error sending to client ${clientId}:`, error3);
      clients.delete(clientId);
    }
  });
}

// src/middleware/auth.middleware.ts
async function verifyAuthToken({ cookie: cookie5, jwt: jwt2, set: set2 }) {
  try {
    if (!cookie5 || typeof cookie5 !== "object") {
      set2.status = 401;
      return { authorized: false, message: "ไม่ได้เข้าสู่ระบบ" };
    }
    const cookieObj = cookie5;
    const token = cookieObj.auth_token?.toString();
    if (!token) {
      set2.status = 401;
      return { authorized: false, message: "ไม่ได้เข้าสู่ระบบ" };
    }
    const tokenResult = await pool.query("SELECT * FROM tokens WHERE token = $1 AND expires_at > NOW()", [token]);
    if (tokenResult.rows.length === 0) {
      console.log("Token หมดอายุหรือไม่มีในระบบ");
      set2.status = 401;
      set2.headers = {
        "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
      };
      return {
        authorized: false,
        message: "Token หมดอายุหรือไม่ถูกต้อง กรุณาเข้าสู่ระบบใหม่",
        tokenExpired: true
      };
    }
    const payload = await jwt2.verify(token);
    if (!payload) {
      set2.status = 401;
      set2.headers = {
        "Set-Cookie": `auth_token=; HttpOnly; Path=/; Max-Age=0; SameSite=strict`
      };
      return { authorized: false, message: "Token ไม่ถูกต้อง กรุณาเข้าสู่ระบบใหม่" };
    }
    return {
      authorized: true,
      user: payload,
      userId: payload.user_id,
      role: payload.role
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการตรวจสอบ token:", error3);
    set2.status = 500;
    return {
      authorized: false,
      message: "เกิดข้อผิดพลาดในการตรวจสอบการยืนยันตัวตน",
      tokenExpired: true
    };
  }
}

// src/controllers/controllers-water-treat/environmental.controller.ts
var getEnvironmentalData = async ({ query, cookie: cookie5, jwt: jwt2, set: set2 }) => {
  console.log("กำลังดึงข้อมูลสิ่งแวดล้อม");
  try {
    const authResult = await verifyAuthToken({ cookie: cookie5, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userRole = authResult.role;
    const userId = authResult.userId;
    const page = parseInt(query.page || "1");
    const pageSize = parseInt(query.pageSize || "10");
    const offset = (page - 1) * pageSize;
    const startDate = query.startDate ? new Date(query.startDate) : null;
    const endDate = query.endDate ? new Date(query.endDate) : null;
    let conditions = [];
    let queryParams = [];
    let index = 1;
    if (userRole !== "admin") {
      conditions.push(`e.user_id = $${index++}`);
      queryParams.push(userId);
    }
    if (startDate) {
      conditions.push(`DATE(e.record_date) >= $${index++}`);
      queryParams.push(startDate);
    }
    if (endDate) {
      const endOfDay = new Date(endDate);
      endOfDay.setHours(23, 59, 59, 999);
      conditions.push(`DATE(e.record_date) <= $${index++}`);
      queryParams.push(endOfDay);
    }
    let totalQuery = `SELECT COUNT(*) FROM environmental_data e`;
    if (conditions.length > 0) {
      totalQuery += ` WHERE ${conditions.join(" AND ")}`;
    }
    let dataQuery = `
        SELECT e.*, u.full_name 
        FROM environmental_data e
        LEFT JOIN users u ON e.user_id = u.user_id
      `;
    if (conditions.length > 0) {
      dataQuery += ` WHERE ${conditions.join(" AND ")}`;
    }
    if ((startDate || endDate) && conditions.length > 0) {
      dataQuery += ` ORDER BY e.record_date ASC`;
    } else {
      dataQuery += ` ORDER BY e.record_date DESC`;
    }
    dataQuery += ` LIMIT $${index++} OFFSET $${index++}`;
    queryParams.push(pageSize, offset);
    const totalResult = await pool.query(totalQuery, queryParams.slice(0, -2));
    const total = parseInt(totalResult.rows[0].count);
    const result = await pool.query(dataQuery, queryParams);
    console.log(`ดึงข้อมูลสำเร็จ: ${result.rows.length} รายการ จากทั้งหมด ${total} รายการ`);
    return {
      success: true,
      data: result.rows,
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize)
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูล:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการดึงข้อมูล" };
  }
};
var getEnvironmentalDataById = async ({ params, cookie: cookie5, jwt: jwt2, set: set2 }) => {
  console.log(`กำลังดึงข้อมูลสิ่งแวดล้อมรหัส ${params.id}`);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie5, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userRole = authResult.role;
    const userId = authResult.userId;
    const result = await pool.query(`SELECT e.*, u.full_name 
         FROM environmental_data e
         LEFT JOIN users u ON e.user_id = u.user_id
         WHERE e.info_id = $1`, [params.id]);
    if (result.rows.length === 0) {
      set2.status = 404;
      return { success: false, message: "ไม่พบข้อมูล" };
    }
    if (userRole !== "admin" && result.rows[0].user_id !== userId) {
      set2.status = 403;
      return { success: false, message: "ไม่มีสิทธิ์เข้าถึงข้อมูลนี้" };
    }
    console.log(`ดึงข้อมูลสำเร็จ: ${result.rows[0].info_id}`);
    return {
      success: true,
      data: result.rows[0]
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูล:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการดึงข้อมูล" };
  }
};
var getEnvironmentalDataExists = async ({ params, cookie: cookie5, jwt: jwt2, set: set2 }) => {
  console.log(`กำลังตรวจสอบการมีอยู่ของข้อมูล ID: ${params.id}`);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie5, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const result = await pool.query(`SELECT EXISTS (SELECT 1 FROM environmental_data WHERE info_id = $1)`, [
      params.id
    ]);
    const exists = result.rows[0].exists;
    console.log(`ข้อมูล ID ${params.id} ${exists ? "มีอยู่" : "ไม่มีอยู่"}`);
    return {
      success: true,
      exists
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการตรวจสอบการมีอยู่ของข้อมูล:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการตรวจสอบการมีอยู่ของข้อมูล" };
  }
};
var addEnvironmentalData = async ({ body, cookie: cookie5, jwt: jwt2, set: set2 }) => {
  console.log("กำลังเพิ่มข้อมูลน้ำเสีย");
  try {
    const authResult = await verifyAuthToken({ cookie: cookie5, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userId = authResult.userId;
    let recordDate;
    if (body.record_date) {
      recordDate = new Date(body.record_date);
    } else {
      recordDate = new Date;
    }
    const result = await pool.query(`INSERT INTO environmental_data (
      user_id, record_date, 
      electricity_usage, water_usage, wastewater_inflow, wastewater_outflow, chemical_usage,
      treatment_system_status_id, water_pump_status_id, aerator_status_id, 
      wastewater_mixer_status_id, chemical_mixer_status_id, sludge_pump_status_id,
      ph_value, sludge_removal, residual_chlorine
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
    RETURNING *`, [
      userId,
      recordDate,
      body.electricity_usage,
      body.water_usage,
      body.wastewater_inflow,
      body.wastewater_outflow,
      body.chemical_usage,
      body.treatment_system_status_id,
      body.water_pump_status_id,
      body.aerator_status_id,
      body.wastewater_mixer_status_id,
      body.chemical_mixer_status_id,
      body.sludge_pump_status_id,
      body.ph_value,
      body.sludge_removal,
      body.residual_chlorine
    ]);
    console.log(`เพิ่มข้อมูลน้ำเสียสำเร็จ: ${result.rows[0].info_id}`);
    notifyClients("create", {
      info_id: result.rows[0].info_id,
      message: "มีการเพิ่มข้อมูลใหม่",
      timestamp: new Date().toISOString()
    });
    return {
      success: true,
      message: "เพิ่มข้อมูลสำเร็จ",
      data: result.rows[0]
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการเพิ่มข้อมูล:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการเพิ่มข้อมูล" };
  }
};
var updateEnvironmentalData = async ({ params, body, cookie: cookie5, jwt: jwt2, set: set2 }) => {
  console.log(`กำลังแก้ไขข้อมูลสิ่งแวดล้อมรหัส ${params.id}`);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie5, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const existsCheck = await pool.query(`SELECT EXISTS (SELECT 1 FROM environmental_data WHERE info_id = $1)`, [
      params.id
    ]);
    if (!existsCheck.rows[0].exists) {
      set2.status = 404;
      return { success: false, message: "ไม่พบข้อมูลที่ต้องการแก้ไข" };
    }
    const {
      electricity_usage,
      water_usage,
      wastewater_inflow,
      wastewater_outflow,
      chemical_usage,
      treatment_system_status_id,
      water_pump_status_id,
      aerator_status_id,
      wastewater_mixer_status_id,
      chemical_mixer_status_id,
      sludge_pump_status_id,
      ph_value,
      sludge_removal,
      residual_chlorine
    } = body;
    await pool.query(`UPDATE environmental_data 
        SET electricity_usage = $1, 
            water_usage = $2, 
            wastewater_inflow = $3, 
            wastewater_outflow = $4, 
            chemical_usage = $5,
            treatment_system_status_id = $6, 
            water_pump_status_id = $7, 
            aerator_status_id = $8, 
            wastewater_mixer_status_id = $9, 
            chemical_mixer_status_id = $10, 
            sludge_pump_status_id = $11,
            ph_value = $12, 
            sludge_removal = $13, 
            residual_chlorine = $14,
            updated_at = NOW()
        WHERE info_id = $15`, [
      electricity_usage,
      water_usage,
      wastewater_inflow,
      wastewater_outflow,
      chemical_usage,
      treatment_system_status_id,
      water_pump_status_id,
      aerator_status_id,
      wastewater_mixer_status_id,
      chemical_mixer_status_id,
      sludge_pump_status_id,
      ph_value,
      sludge_removal,
      residual_chlorine,
      params.id
    ]);
    console.log(`แก้ไขข้อมูลสำเร็จ: ${params.id}`);
    notifyClients("update", {
      info_id: params.id,
      message: "มีการแก้ไขข้อมูล",
      timestamp: new Date().toISOString()
    });
    return {
      success: true,
      message: "แก้ไขข้อมูลสำเร็จ"
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการแก้ไขข้อมูล:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการแก้ไขข้อมูล" };
  }
};
var deleteEnvironmentalData = async ({ params, cookie: cookie5, jwt: jwt2, set: set2 }) => {
  console.log(`กำลังลบข้อมูลสิ่งแวดล้อมรหัส ${params.id}`);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie5, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const existsCheck = await pool.query(`SELECT EXISTS (SELECT 1 FROM environmental_data WHERE info_id = $1)`, [
      params.id
    ]);
    if (!existsCheck.rows[0].exists) {
      set2.status = 404;
      return { success: false, message: "ไม่พบข้อมูลที่ต้องการลบ" };
    }
    await pool.query("DELETE FROM environmental_data WHERE info_id = $1", [params.id]);
    console.log(`ลบข้อมูลสำเร็จ: ${params.id}`);
    notifyClients("delete", {
      info_id: params.id,
      message: "มีการลบข้อมูล",
      timestamp: new Date().toISOString()
    });
    return {
      success: true,
      message: "ลบข้อมูลสำเร็จ"
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการลบข้อมูล:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการลบข้อมูล" };
  }
};

// src/routes/routes-water-treat/routes.enviroments.ts
var environmentalController = new Elysia({ prefix: "/api/environmental-data" }).use(import_cookie6.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).get("/", getEnvironmentalData).get("/:id", getEnvironmentalDataById).put("/:id", updateEnvironmentalData).delete("/:id", deleteEnvironmentalData).get("/:id/exists", getEnvironmentalDataExists);
var addEnvironmentalDataController = new Elysia({ prefix: "/api/add-environmental-data" }).use(import_cookie6.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).post("/", addEnvironmentalData);

// src/controllers/controllers-water-treat/dashboard.controller.ts
var getMonthlySummary = async ({ query }) => {
  console.log("กำลังดึงข้อมูลสรุปรายเดือนสำหรับ Dashboard");
  try {
    const startDate = query?.startDate || null;
    const endDate = query?.endDate || null;
    console.log(`พารามิเตอร์: startDate=${startDate}, endDate=${endDate}`);
    let dateFrom = new Date;
    dateFrom.setMonth(dateFrom.getMonth() - 6);
    let dateFromStr = dateFrom.toISOString().split("T")[0];
    if (startDate) {
      dateFromStr = startDate;
    }
    let dateTo = new Date;
    let dateToStr = dateTo.toISOString().split("T")[0];
    if (endDate) {
      dateToStr = endDate;
    }
    const monthlySummaryQuery = `
        SELECT 
          DATE_TRUNC('month', record_date)::date as month_date,
          TO_CHAR(record_date, 'YYYY-MM') as month_year,
          SUM(electricity_usage) as total_electricity,
          SUM(water_usage) as total_water,
          SUM(wastewater_inflow) as total_wastewater_in,
          SUM(wastewater_outflow) as total_wastewater_out,
          SUM(chemical_usage) as total_chemical,
          SUM(sludge_removal) as total_sludge,
          AVG(ph_value) as avg_ph,
          AVG(residual_chlorine) as avg_chlorine
        FROM environmental_data
        WHERE DATE(record_date) BETWEEN $1 AND $2
        GROUP BY month_date, month_year
        ORDER BY month_date
      `;
    const monthlySummaryResult = await pool.query(monthlySummaryQuery, [dateFromStr, dateToStr]);
    const monthlyStatusQuery = `
        SELECT 
          TO_CHAR(record_date, 'YYYY-MM') as month_year,
          
          COUNT(CASE WHEN treatment_system_status_id = 1 THEN 1 END) as treatment_normal,
          COUNT(CASE WHEN treatment_system_status_id = 2 THEN 1 END) as treatment_abnormal,
          COUNT(CASE WHEN treatment_system_status_id = 3 THEN 1 END) as treatment_maintenance,
          COUNT(CASE WHEN treatment_system_status_id = 4 THEN 1 END) as treatment_inactive,
          COUNT(CASE WHEN treatment_system_status_id = 5 THEN 1 END) as treatment_unknown,
          
          COUNT(CASE WHEN water_pump_status_id = 1 THEN 1 END) as pump_normal,
          COUNT(CASE WHEN water_pump_status_id = 2 THEN 1 END) as pump_abnormal,
          COUNT(CASE WHEN water_pump_status_id = 3 THEN 1 END) as pump_maintenance,
          COUNT(CASE WHEN water_pump_status_id = 4 THEN 1 END) as pump_inactive,
          COUNT(CASE WHEN water_pump_status_id = 5 THEN 1 END) as pump_unknown,
          
          COUNT(CASE WHEN aerator_status_id = 1 THEN 1 END) as aerator_normal,
          COUNT(CASE WHEN aerator_status_id = 2 THEN 1 END) as aerator_abnormal,
          COUNT(CASE WHEN aerator_status_id = 3 THEN 1 END) as aerator_maintenance,
          COUNT(CASE WHEN aerator_status_id = 4 THEN 1 END) as aerator_inactive,
          COUNT(CASE WHEN aerator_status_id = 5 THEN 1 END) as aerator_unknown,
          
          COUNT(CASE WHEN wastewater_mixer_status_id = 1 THEN 1 END) as mixer_normal,
          COUNT(CASE WHEN wastewater_mixer_status_id = 2 THEN 1 END) as mixer_abnormal,
          COUNT(CASE WHEN wastewater_mixer_status_id = 3 THEN 1 END) as mixer_maintenance,
          COUNT(CASE WHEN wastewater_mixer_status_id = 4 THEN 1 END) as mixer_inactive,
          COUNT(CASE WHEN wastewater_mixer_status_id = 5 THEN 1 END) as mixer_unknown,
          
          COUNT(CASE WHEN chemical_mixer_status_id = 1 THEN 1 END) as chem_normal,
          COUNT(CASE WHEN chemical_mixer_status_id = 2 THEN 1 END) as chem_abnormal,
          COUNT(CASE WHEN chemical_mixer_status_id = 3 THEN 1 END) as chem_maintenance,
          COUNT(CASE WHEN chemical_mixer_status_id = 4 THEN 1 END) as chem_inactive,
          COUNT(CASE WHEN chemical_mixer_status_id = 5 THEN 1 END) as chem_unknown,
          
          COUNT(CASE WHEN sludge_pump_status_id = 1 THEN 1 END) as sludge_normal,
          COUNT(CASE WHEN sludge_pump_status_id = 2 THEN 1 END) as sludge_abnormal,
          COUNT(CASE WHEN sludge_pump_status_id = 3 THEN 1 END) as sludge_maintenance,
          COUNT(CASE WHEN sludge_pump_status_id = 4 THEN 1 END) as sludge_inactive,
          COUNT(CASE WHEN sludge_pump_status_id = 5 THEN 1 END) as sludge_unknown
        FROM environmental_data
        WHERE DATE(record_date) BETWEEN $1 AND $2
        GROUP BY month_year
        ORDER BY month_year
      `;
    const statusResult = await pool.query(monthlyStatusQuery, [dateFromStr, dateToStr]);
    let responseData = {
      monthlySummary: monthlySummaryResult.rows,
      statusSummary: statusResult.rows
    };
    if (monthlySummaryResult.rows.length === 0 && statusResult.rows.length === 0) {
      console.log("ไม่พบข้อมูลในช่วงเวลาที่เลือก");
      responseData = {
        monthlySummary: [],
        statusSummary: [],
        noData: true
      };
    }
    console.log("ดึงข้อมูลสรุปรายเดือนสำเร็จ");
    return responseData;
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลสรุปรายเดือน:", error3);
    return new Response(JSON.stringify({ error: "เกิดข้อผิดพลาดในการดึงข้อมูล" }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
};
var getSummaryStats = async ({ query }) => {
  console.log("กำลังดึงข้อมูลสถิติสรุปสำหรับ Dashboard");
  try {
    const startDate = query?.startDate || null;
    const endDate = query?.endDate || null;
    console.log(`พารามิเตอร์: startDate=${startDate}, endDate=${endDate}`);
    let dateFrom = new Date;
    dateFrom.setMonth(dateFrom.getMonth() - 6);
    let dateFromStr = dateFrom.toISOString().split("T")[0];
    if (startDate) {
      dateFromStr = startDate;
    }
    let dateTo = new Date;
    let dateToStr = dateTo.toISOString().split("T")[0];
    if (endDate) {
      dateToStr = endDate;
    }
    const averagesQuery = `
        SELECT 
          AVG(electricity_usage) as avg_electricity,
          AVG(water_usage) as avg_water,
          AVG(wastewater_inflow) as avg_wastewater_in,
          AVG(wastewater_outflow) as avg_wastewater_out,
          AVG(chemical_usage) as avg_chemical,
          AVG(sludge_removal) as avg_sludge,
          AVG(ph_value) as avg_ph,
          AVG(residual_chlorine) as avg_chlorine
        FROM environmental_data
        WHERE DATE(record_date) BETWEEN $1 AND $2
      `;
    const averagesResult = await pool.query(averagesQuery, [dateFromStr, dateToStr]);
    const statusCountQuery = `
        SELECT
          COUNT(*) as total_records,
          
          SUM(CASE WHEN treatment_system_status_id = 1 THEN 1 ELSE 0 END) as treatment_normal,
          SUM(CASE WHEN treatment_system_status_id = 2 THEN 1 ELSE 0 END) as treatment_abnormal,
          SUM(CASE WHEN treatment_system_status_id = 3 THEN 1 ELSE 0 END) as treatment_maintenance,
          SUM(CASE WHEN treatment_system_status_id = 4 THEN 1 ELSE 0 END) as treatment_inactive,
          SUM(CASE WHEN treatment_system_status_id = 5 THEN 1 ELSE 0 END) as treatment_unknown,
          
          SUM(CASE WHEN water_pump_status_id = 1 THEN 1 ELSE 0 END) as pump_normal,
          SUM(CASE WHEN water_pump_status_id = 2 THEN 1 ELSE 0 END) as pump_abnormal,
          SUM(CASE WHEN water_pump_status_id = 3 THEN 1 ELSE 0 END) as pump_maintenance,
          SUM(CASE WHEN water_pump_status_id = 4 THEN 1 ELSE 0 END) as pump_inactive,
          SUM(CASE WHEN water_pump_status_id = 5 THEN 1 ELSE 0 END) as pump_unknown,
          
          SUM(CASE WHEN aerator_status_id = 1 THEN 1 ELSE 0 END) as aerator_normal,
          SUM(CASE WHEN aerator_status_id = 2 THEN 1 ELSE 0 END) as aerator_abnormal,
          SUM(CASE WHEN aerator_status_id = 3 THEN 1 ELSE 0 END) as aerator_maintenance,
          SUM(CASE WHEN aerator_status_id = 4 THEN 1 ELSE 0 END) as aerator_inactive,
          SUM(CASE WHEN aerator_status_id = 5 THEN 1 ELSE 0 END) as aerator_unknown,
          
          SUM(CASE WHEN wastewater_mixer_status_id = 1 THEN 1 ELSE 0 END) as mixer_normal,
          SUM(CASE WHEN wastewater_mixer_status_id = 2 THEN 1 ELSE 0 END) as mixer_abnormal,
          SUM(CASE WHEN wastewater_mixer_status_id = 3 THEN 1 ELSE 0 END) as mixer_maintenance,
          SUM(CASE WHEN wastewater_mixer_status_id = 4 THEN 1 ELSE 0 END) as mixer_inactive,
          SUM(CASE WHEN wastewater_mixer_status_id = 5 THEN 1 ELSE 0 END) as mixer_unknown,
          
          SUM(CASE WHEN chemical_mixer_status_id = 1 THEN 1 ELSE 0 END) as chem_normal,
          SUM(CASE WHEN chemical_mixer_status_id = 2 THEN 1 ELSE 0 END) as chem_abnormal,
          SUM(CASE WHEN chemical_mixer_status_id = 3 THEN 1 ELSE 0 END) as chem_maintenance,
          SUM(CASE WHEN chemical_mixer_status_id = 4 THEN 1 ELSE 0 END) as chem_inactive,
          SUM(CASE WHEN chemical_mixer_status_id = 5 THEN 1 ELSE 0 END) as chem_unknown,
          
          SUM(CASE WHEN sludge_pump_status_id = 1 THEN 1 ELSE 0 END) as sludge_normal,
          SUM(CASE WHEN sludge_pump_status_id = 2 THEN 1 ELSE 0 END) as sludge_abnormal,
          SUM(CASE WHEN sludge_pump_status_id = 3 THEN 1 ELSE 0 END) as sludge_maintenance,
          SUM(CASE WHEN sludge_pump_status_id = 4 THEN 1 ELSE 0 END) as sludge_inactive,
          SUM(CASE WHEN sludge_pump_status_id = 5 THEN 1 ELSE 0 END) as sludge_unknown
        FROM environmental_data
        WHERE DATE(record_date) BETWEEN $1 AND $2
      `;
    const statusCountResult = await pool.query(statusCountQuery, [dateFromStr, dateToStr]);
    const statusCount = statusCountResult.rows[0];
    const totalRecords = Number(statusCount.total_records) || 1;
    const calculatePercentage = (value) => {
      return parseFloat((value / totalRecords * 100).toFixed(1));
    };
    const summaryStats = {
      averages: {
        electricity: parseFloat(averagesResult.rows[0].avg_electricity) || 0,
        water: parseFloat(averagesResult.rows[0].avg_water) || 0,
        wastewater_in: parseFloat(averagesResult.rows[0].avg_wastewater_in) || 0,
        wastewater_out: parseFloat(averagesResult.rows[0].avg_wastewater_out) || 0,
        chemical: parseFloat(averagesResult.rows[0].avg_chemical) || 0,
        sludge: parseFloat(averagesResult.rows[0].avg_sludge) || 0,
        ph: parseFloat(averagesResult.rows[0].avg_ph) || 0,
        chlorine: parseFloat(averagesResult.rows[0].avg_chlorine) || 0
      },
      status_percentages: {
        treatment: {
          normal: calculatePercentage(statusCount.treatment_normal),
          abnormal: calculatePercentage(statusCount.treatment_abnormal),
          maintenance: calculatePercentage(statusCount.treatment_maintenance),
          inactive: calculatePercentage(statusCount.treatment_inactive),
          unknown: calculatePercentage(statusCount.treatment_unknown)
        },
        pump: {
          normal: calculatePercentage(statusCount.pump_normal),
          abnormal: calculatePercentage(statusCount.pump_abnormal),
          maintenance: calculatePercentage(statusCount.pump_maintenance),
          inactive: calculatePercentage(statusCount.pump_inactive),
          unknown: calculatePercentage(statusCount.pump_unknown)
        },
        aerator: {
          normal: calculatePercentage(statusCount.aerator_normal),
          abnormal: calculatePercentage(statusCount.aerator_abnormal),
          maintenance: calculatePercentage(statusCount.aerator_maintenance),
          inactive: calculatePercentage(statusCount.aerator_inactive),
          unknown: calculatePercentage(statusCount.aerator_unknown)
        },
        mixer: {
          normal: calculatePercentage(statusCount.mixer_normal),
          abnormal: calculatePercentage(statusCount.mixer_abnormal),
          maintenance: calculatePercentage(statusCount.mixer_maintenance),
          inactive: calculatePercentage(statusCount.mixer_inactive),
          unknown: calculatePercentage(statusCount.mixer_unknown)
        },
        chem: {
          normal: calculatePercentage(statusCount.chem_normal),
          abnormal: calculatePercentage(statusCount.chem_abnormal),
          maintenance: calculatePercentage(statusCount.chem_maintenance),
          inactive: calculatePercentage(statusCount.chem_inactive),
          unknown: calculatePercentage(statusCount.chem_unknown)
        },
        sludge: {
          normal: calculatePercentage(statusCount.sludge_normal),
          abnormal: calculatePercentage(statusCount.sludge_abnormal),
          maintenance: calculatePercentage(statusCount.sludge_maintenance),
          inactive: calculatePercentage(statusCount.sludge_inactive),
          unknown: calculatePercentage(statusCount.sludge_unknown)
        }
      }
    };
    if (totalRecords === 0) {
      return {
        summaryStats: null,
        noData: true
      };
    }
    console.log("ดึงข้อมูลสถิติสรุปสำเร็จ");
    return {
      summaryStats,
      noData: false
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลสถิติสรุป:", error3);
    return new Response(JSON.stringify({ error: "เกิดข้อผิดพลาดในการดึงข้อมูล" }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
};
var getDailyData = async ({ params, cookie: cookie6, jwt: jwt2, set: set2 }) => {
  console.log("กำลังดึงข้อมูลรายวันตามเดือน");
  try {
    const { year: year2, month } = params;
    const authResult = await verifyAuthToken({ cookie: cookie6, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    if (!year2 || !month || isNaN(Number(year2)) || isNaN(Number(month))) {
      return new Response(JSON.stringify({ error: "รูปแบบ year หรือ month ไม่ถูกต้อง" }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    const startOfMonth = `${year2}-${month.padStart(2, "0")}-01`;
    const lastDay = new Date(Number(year2), Number(month), 0).getDate();
    const endOfMonth = `${year2}-${month.padStart(2, "0")}-${lastDay}`;
    console.log(`ดึงข้อมูลรายวันระหว่าง ${startOfMonth} ถึง ${endOfMonth}`);
    const dailyDataQuery = `
        SELECT 
          record_date,
          TO_CHAR(record_date, 'HH24:MI:SS') as record_time,
          electricity_usage,
          water_usage,
          wastewater_inflow,
          wastewater_outflow,
          chemical_usage,
          sludge_removal,
          ph_value,
          residual_chlorine,
          treatment_system_status_id,
          water_pump_status_id,
          aerator_status_id,
          wastewater_mixer_status_id,
          chemical_mixer_status_id,
          sludge_pump_status_id
        FROM environmental_data
        WHERE DATE(record_date) BETWEEN $1 AND $2
        ORDER BY record_date
      `;
    const dailyDataResult = await pool.query(dailyDataQuery, [startOfMonth, endOfMonth]);
    const statusMap = {
      1: "ปกติ",
      2: "ผิดปกติ",
      3: "ซ่อมบำรุง",
      4: "ไม่ใช้งาน",
      5: "ไม่ระบุ"
    };
    const formattedData = dailyDataResult.rows.map((row) => {
      const recordDate = new Date(row.record_date);
      const formattedDate = recordDate.toLocaleDateString("th-TH");
      const formattedTime = row.record_time || recordDate.toLocaleTimeString("th-TH");
      return {
        วันที่: `${formattedDate} ${formattedTime}`,
        การใช้ไฟฟ้า: row.electricity_usage + " kWh",
        การใช้น้ำ: row.water_usage + " ลบ.ม.",
        น้ำเสียเข้าระบบ: row.wastewater_inflow + " ลบ.ม.",
        น้ำออกจากระบบ: row.wastewater_outflow + " ลบ.ม.",
        การใช้สารเคมี: row.chemical_usage + " กก.",
        ปริมาณตะกอน: row.sludge_removal + " ลบ.ม.",
        ค่า_pH: row.ph_value,
        คลอรีนตกค้าง: row.residual_chlorine + " มก./ล.",
        สถานะ: {
          ระบบบำบัด: statusMap[row.treatment_system_status_id] || "ไม่ระบุ",
          เครื่องสูบน้ำ: statusMap[row.water_pump_status_id] || "ไม่ระบุ",
          เครื่องเติมอากาศ: statusMap[row.aerator_status_id] || "ไม่ระบุ",
          เครื่องกวนน้ำเสีย: statusMap[row.wastewater_mixer_status_id] || "ไม่ระบุ",
          เครื่องกวนสารเคมี: statusMap[row.chemical_mixer_status_id] || "ไม่ระบุ",
          เครื่องสูบตะกอน: statusMap[row.sludge_pump_status_id] || "ไม่ระบุ"
        }
      };
    });
    if (formattedData.length === 0) {
      return {
        month: `${year2}-${month}`,
        dailyData: [],
        noData: true
      };
    }
    console.log(`ดึงข้อมูลรายวันของเดือน ${year2}-${month} สำเร็จ มีข้อมูล ${formattedData.length} วัน`);
    return {
      month: `${year2}-${month}`,
      dailyData: formattedData,
      noData: false
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลรายวัน:", error3);
    return new Response(JSON.stringify({ error: "เกิดข้อผิดพลาดในการดึงข้อมูล" }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
};
var getDailyDataRange = async ({ query, cookie: cookie6, jwt: jwt2, set: set2 }) => {
  console.log("กำลังดึงข้อมูลรายวันตามช่วงวันที่");
  try {
    const authResult = await verifyAuthToken({ cookie: cookie6, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const startDate = query?.startDate || null;
    const endDate = query?.endDate || null;
    if (!startDate || !endDate) {
      return new Response(JSON.stringify({ error: "กรุณาระบุวันที่เริ่มต้นและวันที่สิ้นสุด" }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    console.log(`ดึงข้อมูลรายวันระหว่าง ${startDate} ถึง ${endDate}`);
    const dailyDataQuery = `
        SELECT 
          record_date,
          TO_CHAR(record_date, 'HH24:MI:SS') as record_time,
          electricity_usage,
          water_usage,
          wastewater_inflow,
          wastewater_outflow,
          chemical_usage,
          sludge_removal,
          ph_value,
          residual_chlorine,
          treatment_system_status_id,
          water_pump_status_id,
          aerator_status_id,
          wastewater_mixer_status_id,
          chemical_mixer_status_id,
          sludge_pump_status_id
        FROM environmental_data
        WHERE DATE(record_date) BETWEEN $1 AND $2
        ORDER BY record_date
      `;
    const dailyDataResult = await pool.query(dailyDataQuery, [startDate, endDate]);
    const statusMap = {
      1: "ปกติ",
      2: "ผิดปกติ",
      3: "ซ่อมบำรุง",
      4: "ไม่ใช้งาน",
      5: "ไม่ระบุ"
    };
    const formattedData = dailyDataResult.rows.map((row) => {
      const recordDate = new Date(row.record_date);
      const formattedDate = recordDate.toLocaleDateString("th-TH");
      const formattedTime = row.record_time || recordDate.toLocaleTimeString("th-TH");
      return {
        วันที่: `${formattedDate} ${formattedTime}`,
        การใช้ไฟฟ้า: row.electricity_usage !== null && row.electricity_usage !== undefined ? row.electricity_usage + " kWh" : null,
        การใช้น้ำ: row.water_usage !== null && row.water_usage !== undefined ? row.water_usage + " ลบ.ม." : null,
        น้ำเสียเข้าระบบ: row.wastewater_inflow !== null && row.wastewater_inflow !== undefined ? row.wastewater_inflow + " ลบ.ม." : null,
        น้ำออกจากระบบ: row.wastewater_outflow !== null && row.wastewater_outflow !== undefined ? row.wastewater_outflow + " ลบ.ม." : null,
        การใช้สารเคมี: row.chemical_usage !== null && row.chemical_usage !== undefined ? row.chemical_usage + " กก." : null,
        ปริมาณตะกอน: row.sludge_removal !== null && row.sludge_removal !== undefined ? row.sludge_removal + " ลบ.ม." : null,
        ค่า_pH: row.ph_value !== null && row.ph_value !== undefined ? row.ph_value : null,
        คลอรีนตกค้าง: row.residual_chlorine !== null && row.residual_chlorine !== undefined ? row.residual_chlorine + " มก./ล." : null,
        สถานะ: {
          ระบบบำบัด: statusMap[row.treatment_system_status_id] || "ไม่ระบุ",
          เครื่องสูบน้ำ: statusMap[row.water_pump_status_id] || "ไม่ระบุ",
          เครื่องเติมอากาศ: statusMap[row.aerator_status_id] || "ไม่ระบุ",
          เครื่องกวนน้ำเสีย: statusMap[row.wastewater_mixer_status_id] || "ไม่ระบุ",
          เครื่องกวนสารเคมี: statusMap[row.chemical_mixer_status_id] || "ไม่ระบุ",
          เครื่องสูบตะกอน: statusMap[row.sludge_pump_status_id] || "ไม่ระบุ"
        }
      };
    });
    if (formattedData.length === 0) {
      return {
        dateRange: {
          startDate,
          endDate
        },
        dailyData: [],
        noData: true
      };
    }
    console.log(`ดึงข้อมูลรายวันระหว่าง ${startDate} ถึง ${endDate} สำเร็จ มีข้อมูล ${formattedData.length} รายการ`);
    return {
      dateRange: {
        startDate,
        endDate
      },
      dailyData: formattedData,
      noData: false
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลรายวัน:", error3);
    return new Response(JSON.stringify({ error: "เกิดข้อผิดพลาดในการดึงข้อมูล" }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
};

// src/routes/routes-water-treat/routes.dashboard.ts
var dashboardController = new Elysia({ prefix: "/api/dashboard-data" }).get("/monthly-summary", getMonthlySummary).get("/summary-stats", getSummaryStats).get("/daily-data/:year/:month", getDailyData).get("/daily-data-range", getDailyDataRange);

// src/routes/routes-water-treat/routes.equipment.ts
var import_cookie7 = __toESM(require_cjs4(), 1);

// src/controllers/controllers-water-treat/equipment-status.controller.ts
var getEquipmentStatus = async ({ cookie: cookie6, jwt: jwt2, set: set2 }) => {
  console.log("กำลังดึงข้อมูลสถานะอุปกรณ์ทั้งหมด");
  try {
    const cookieObj = cookie6;
    const token = cookieObj.auth_token?.toString();
    if (!token) {
      set2.status = 401;
      return { success: false, message: "ไม่ได้เข้าสู่ระบบ" };
    }
    const payload = await jwt2.verify(token);
    if (!payload) {
      set2.status = 401;
      return { success: false, message: "ไม่ได้เข้าสู่ระบบ" };
    }
    const result = await pool.query(`SELECT * FROM equipment_status ORDER BY status_id ASC`);
    console.log(`ดึงข้อมูลสถานะอุปกรณ์สำเร็จ: ${result.rows.length} รายการ`);
    return {
      success: true,
      data: result.rows,
      total: result.rows.length
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลสถานะอุปกรณ์:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการดึงข้อมูลสถานะอุปกรณ์" };
  }
};

// src/routes/routes-water-treat/routes.equipment.ts
var equipmentStatusController = new Elysia({ prefix: "/api/equipment-status" }).use(import_cookie7.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).get("/", getEquipmentStatus);

// src/routes/routes-waste/routes.dashboard.waste.ts
var import_cookie8 = __toESM(require_cjs4(), 1);

// src/controllers/controllers-waste/dashboard.waste.controller.ts
var getMonthlyWasteData = async ({ query, set: set2 }) => {
  try {
    const { wasteTypeId, startDate, endDate } = query;
    if (!wasteTypeId) {
      set2.status = 400;
      return {
        success: false,
        message: "กรุณาระบุประเภทขยะ"
      };
    }
    const currentYear = new Date().getFullYear();
    const defaultStartDate = `${currentYear}-01-01`;
    const defaultEndDate = `${currentYear}-12-31`;
    const from = startDate || defaultStartDate;
    const to = endDate || defaultEndDate;
    const monthlyWasteQuery = `
      SELECT 
        TO_CHAR(wr.recorded_date, 'YYYY-MM') as month,
        COALESCE(SUM(wr.amount), 0) as amount
      FROM 
        waste_records wr
      WHERE 
        wr.waste_type_id = $1 AND
        DATE(wr.recorded_date) BETWEEN $2 AND $3
      GROUP BY 
        TO_CHAR(wr.recorded_date, 'YYYY-MM')
      ORDER BY 
        month
    `;
    const wasteTypeQuery = `
      SELECT id, name FROM waste_types WHERE id = $1
    `;
    const monthlyResult = await pool.query(monthlyWasteQuery, [wasteTypeId, from, to]);
    const typeResult = await pool.query(wasteTypeQuery, [wasteTypeId]);
    if (typeResult.rows.length === 0) {
      set2.status = 404;
      return {
        success: false,
        message: "ไม่พบประเภทขยะที่ระบุ"
      };
    }
    const monthlyData = monthlyResult.rows.map((row) => {
      const [year2, month] = row.month.split("-");
      const date2 = new Date(parseInt(year2), parseInt(month) - 1, 1);
      const month_label = date2.toLocaleDateString("th-TH", { month: "short", year: "numeric" });
      return {
        month: row.month,
        month_label,
        amount: parseFloat(row.amount)
      };
    });
    const totalAmount = monthlyData.reduce((sum, item) => sum + item.amount, 0);
    return {
      success: true,
      data: {
        wasteTypeId: parseInt(wasteTypeId),
        wasteTypeName: typeResult.rows[0].name,
        monthlyData,
        totalAmount,
        period: {
          from,
          to
        }
      }
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลปริมาณขยะรายเดือน:", error3);
    set2.status = 500;
    return {
      success: false,
      message: "เกิดข้อผิดพลาดในการดึงข้อมูลปริมาณขยะรายเดือน"
    };
  }
};
var getComparisonWasteData = async ({ query, set: set2 }) => {
  try {
    const { startDate, endDate } = query;
    const currentYear = new Date().getFullYear();
    const defaultStartDate = `${currentYear}-01-01`;
    const defaultEndDate = `${currentYear}-12-31`;
    const from = startDate || defaultStartDate;
    const to = endDate || defaultEndDate;
    const comparisonQuery = `
      SELECT 
        wt.id as waste_type_id,
        wt.name as waste_type_name,
        COALESCE(SUM(wr.amount), 0) as total_amount,
        TO_CHAR(wr.recorded_date, 'YYYY-MM') as month
      FROM 
        waste_types wt
      LEFT JOIN 
        waste_records wr ON wt.id = wr.waste_type_id 
        AND DATE(wr.recorded_date) BETWEEN $1 AND $2
      GROUP BY 
        wt.id, wt.name, TO_CHAR(wr.recorded_date, 'YYYY-MM')
      ORDER BY 
        wt.id, month
    `;
    const result = await pool.query(comparisonQuery, [from, to]);
    const wasteTypeMap = new Map;
    const months = new Set;
    result.rows.forEach((row) => {
      if (row.month) {
        months.add(row.month);
        if (!wasteTypeMap.has(row.waste_type_id)) {
          wasteTypeMap.set(row.waste_type_id, {
            id: row.waste_type_id,
            name: row.waste_type_name,
            monthlyData: {}
          });
        }
        wasteTypeMap.get(row.waste_type_id).monthlyData[row.month] = parseFloat(row.total_amount);
      }
    });
    const sortedMonths = Array.from(months).sort();
    const monthLabels = sortedMonths.map((month) => {
      const [year2, monthNum] = month.split("-");
      const date2 = new Date(parseInt(year2), parseInt(monthNum) - 1, 1);
      return date2.toLocaleDateString("th-TH", { month: "short", year: "numeric" });
    });
    const datasets = [];
    wasteTypeMap.forEach((wasteType) => {
      const data = sortedMonths.map((month) => wasteType.monthlyData[month] || 0);
      const total = data.reduce((sum, amount) => sum + amount, 0);
      datasets.push({
        id: wasteType.id,
        name: wasteType.name,
        data,
        total
      });
    });
    return {
      success: true,
      data: {
        months: sortedMonths,
        monthLabels,
        datasets,
        period: {
          from,
          to
        }
      }
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลเปรียบเทียบขยะ:", error3);
    set2.status = 500;
    return {
      success: false,
      message: "เกิดข้อผิดพลาดในการดึงข้อมูลเปรียบเทียบขยะ"
    };
  }
};
var getDailyWasteDataByRange = async ({ query, set: set2, cookie: cookie7, jwt: jwt2 }) => {
  const auth = await verifyAuthToken({ cookie: cookie7, jwt: jwt2, set: set2 });
  if (!auth.authorized) {
    return auth;
  }
  try {
    const { startDate, endDate, wasteTypeId } = query;
    if (!startDate || !endDate) {
      set2.status = 400;
      return {
        success: false,
        message: "กรุณาระบุวันที่เริ่มต้นและสิ้นสุด"
      };
    }
    let dailyWasteQuery = "";
    let queryParams = [];
    if (wasteTypeId) {
      dailyWasteQuery = `
        SELECT 
          wr.recorded_date,
          wr.amount,
          wt.name as waste_type_name
        FROM 
          waste_records wr
        JOIN 
          waste_types wt ON wr.waste_type_id = wt.id
        WHERE 
          wr.waste_type_id = $1 AND
          DATE(wr.recorded_date) BETWEEN $2 AND $3
        ORDER BY 
          wr.recorded_date DESC
      `;
      queryParams = [wasteTypeId, startDate, endDate];
    } else {
      dailyWasteQuery = `
        SELECT 
          wr.recorded_date,
          wr.amount,
          wr.waste_type_id,
          wt.name as waste_type_name
        FROM 
          waste_records wr
        JOIN 
          waste_types wt ON wr.waste_type_id = wt.id
        WHERE 
          DATE(wr.recorded_date) BETWEEN $1 AND $2
        ORDER BY 
          wr.recorded_date DESC
      `;
      queryParams = [startDate, endDate];
    }
    const result = await pool.query(dailyWasteQuery, queryParams);
    if (result.rows.length === 0) {
      return {
        success: true,
        noData: true,
        message: "ไม่พบข้อมูลในช่วงวันที่ที่เลือก"
      };
    }
    const dailyData = result.rows.map((row) => {
      const date2 = new Date(row.recorded_date);
      const formattedDate = date2.toLocaleDateString("th-TH", {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
      const formattedTime = date2.toLocaleTimeString("th-TH", {
        hour: "2-digit",
        minute: "2-digit"
      });
      return {
        id: row.id,
        วันที่: `${formattedDate} ${formattedTime}`,
        ปริมาณ: parseFloat(row.amount),
        หน่วย: "กก.",
        ประเภทขยะ: row.waste_type_name,
        waste_type_id: row.waste_type_id
      };
    });
    return {
      success: true,
      dailyData,
      period: {
        from: startDate,
        to: endDate
      }
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลรายวัน:", error3);
    set2.status = 500;
    return {
      success: false,
      message: "เกิดข้อผิดพลาดในการดึงข้อมูลรายวัน"
    };
  }
};

// src/routes/routes-waste/routes.dashboard.waste.ts
var dashboardWasteController = new Elysia({ prefix: "/api/waste/dashboard" }).use(import_cookie8.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).get("/monthly-waste-data", getMonthlyWasteData).get("/comparison-waste-data", getComparisonWasteData).get("/daily-waste-data", getDailyWasteDataByRange);

// src/routes/routes-waste/routes.waste.ts
var import_cookie9 = __toESM(require_cjs4(), 1);

// src/controllers/controllers-waste/waste.controller.ts
var getWasteRecords = async ({ query, cookie: cookie8, jwt: jwt2, set: set2 }) => {
  console.log("กำลังดึงข้อมูลบันทึกขยะ");
  try {
    const authResult = await verifyAuthToken({ cookie: cookie8, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userRole = authResult.role;
    const userId = authResult.userId;
    const page = parseInt(query.page || "1");
    const pageSize = parseInt(query.pageSize || "10");
    const offset = (page - 1) * pageSize;
    const startDate = query.startDate ? new Date(query.startDate) : null;
    const endDate = query.endDate ? new Date(query.endDate) : null;
    const wasteTypeId = query.wasteTypeId ? parseInt(query.wasteTypeId) : null;
    let conditions = [];
    let queryParams = [];
    let index = 1;
    if (userRole !== "admin") {
      conditions.push(`wr.user_id = $${index++}`);
      queryParams.push(userId);
    }
    if (startDate) {
      conditions.push(`wr.recorded_date >= $${index++}`);
      queryParams.push(startDate);
    }
    if (endDate) {
      const endOfDay = new Date(endDate);
      endOfDay.setHours(23, 59, 59, 999);
      conditions.push(`wr.recorded_date <= $${index++}`);
      queryParams.push(endOfDay);
    }
    if (wasteTypeId) {
      conditions.push(`wr.waste_type_id = $${index++}`);
      queryParams.push(wasteTypeId);
    }
    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";
    const query1 = `
      SELECT 
        wr.*,
        wt.name as waste_type_name,
        u.full_name
      FROM 
        waste_records wr
      JOIN 
        waste_types wt ON wr.waste_type_id = wt.id
      JOIN 
        users u ON wr.user_id = u.user_id
      ${whereClause}
      ORDER BY wr.recorded_date DESC, wr.created_at DESC
      LIMIT $${index++} OFFSET $${index++}
    `;
    const countQuery = `
      SELECT COUNT(*) as total
      FROM waste_records wr
      ${whereClause}
    `;
    queryParams.push(pageSize, offset);
    const result = await pool.query(query1, queryParams);
    const countResult = await pool.query(countQuery, queryParams.slice(0, -2));
    const total = parseInt(countResult.rows[0].total);
    console.log(`ดึงข้อมูลบันทึกขยะสำเร็จ: ${result.rows.length} รายการ จากทั้งหมด ${total} รายการ`);
    return {
      success: true,
      data: result.rows,
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize)
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลบันทึกขยะ:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการดึงข้อมูลบันทึกขยะ" };
  }
};
var getWasteRecordById = async ({
  params,
  cookie: cookie8,
  jwt: jwt2,
  set: set2
}) => {
  console.log(`กำลังดึงข้อมูลบันทึกขยะ ID: ${params.id}`);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie8, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userRole = authResult.role;
    const userId = authResult.userId;
    let query = `
      SELECT 
        wr.*,
        wt.name as waste_type_name,
        u.full_name
      FROM 
        waste_records wr
      JOIN 
        waste_types wt ON wr.waste_type_id = wt.id
      JOIN 
        users u ON wr.user_id = u.user_id
      WHERE wr.id = $1
    `;
    const queryParams = [params.id];
    if (userRole !== "admin") {
      query += ` AND wr.user_id = $2`;
      queryParams.push(userId);
    }
    const result = await pool.query(query, queryParams);
    if (result.rows.length === 0) {
      set2.status = 404;
      return { success: false, message: "ไม่พบข้อมูลบันทึกขยะ" };
    }
    console.log(`ดึงข้อมูลบันทึกขยะสำเร็จ ID: ${params.id}`);
    return {
      success: true,
      data: result.rows[0]
    };
  } catch (error3) {
    console.error(`เกิดข้อผิดพลาดในการดึงข้อมูลบันทึกขยะ ID: ${params.id}:`, error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการดึงข้อมูลบันทึกขยะ" };
  }
};
var addWasteRecord = async ({ body, cookie: cookie8, jwt: jwt2, set: set2 }) => {
  console.log("กำลังเพิ่มข้อมูลบันทึกขยะ:", body);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie8, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userId = authResult.userId;
    if (!body.waste_type_id || !body.amount) {
      set2.status = 400;
      return { success: false, message: "กรุณาระบุประเภทขยะและปริมาณ" };
    }
    const wasteTypeCheck = await pool.query("SELECT id FROM waste_types WHERE id = $1", [body.waste_type_id]);
    if (wasteTypeCheck.rows.length === 0) {
      set2.status = 400;
      return { success: false, message: "ประเภทขยะไม่ถูกต้อง" };
    }
    let recordedDate;
    if (body.recorded_date) {
      recordedDate = new Date(body.recorded_date);
    } else {
      recordedDate = new Date;
    }
    const result = await pool.query(`INSERT INTO waste_records 
        (user_id, waste_type_id, amount, recorded_date) 
       VALUES 
        ($1, $2, $3, $4) 
       RETURNING *`, [userId, body.waste_type_id, body.amount, recordedDate]);
    console.log(`เพิ่มข้อมูลบันทึกขยะสำเร็จ: ID ${result.rows[0].id}`);
    notifyClients("create", {
      id: result.rows[0].id,
      waste_type_id: body.waste_type_id,
      amount: body.amount,
      recorded_date: recordedDate
    });
    return {
      success: true,
      message: "เพิ่มข้อมูลบันทึกขยะสำเร็จ",
      data: result.rows[0]
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการเพิ่มข้อมูลบันทึกขยะ:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการเพิ่มข้อมูลบันทึกขยะ" };
  }
};
var updateWasteRecord = async ({
  params,
  body,
  cookie: cookie8,
  jwt: jwt2,
  set: set2
}) => {
  console.log(`กำลังแก้ไขข้อมูลบันทึกขยะ ID: ${params.id}`, body);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie8, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const checkQuery = `
      SELECT id, user_id FROM waste_records WHERE id = $1
    `;
    const checkResult = await pool.query(checkQuery, [params.id]);
    if (checkResult.rows.length === 0) {
      set2.status = 404;
      return { success: false, message: "ไม่พบข้อมูลบันทึกขยะ" };
    }
    if (body.waste_type_id) {
      const wasteTypeCheck = await pool.query("SELECT id FROM waste_types WHERE id = $1", [body.waste_type_id]);
      if (wasteTypeCheck.rows.length === 0) {
        set2.status = 400;
        return { success: false, message: "ประเภทขยะไม่ถูกต้อง" };
      }
    }
    let updateFields = [];
    let queryParams = [];
    let index = 1;
    if (body.waste_type_id !== undefined) {
      updateFields.push(`waste_type_id = $${index++}`);
      queryParams.push(body.waste_type_id);
    }
    if (body.amount !== undefined) {
      updateFields.push(`amount = $${index++}`);
      queryParams.push(body.amount);
    }
    if (updateFields.length === 0) {
      return {
        success: false,
        message: "ไม่มีข้อมูลที่ต้องการแก้ไข"
      };
    }
    updateFields.push(`updated_at = NOW()`);
    queryParams.push(params.id);
    const query = `
      UPDATE waste_records
      SET ${updateFields.join(", ")}
      WHERE id = $${index}
      RETURNING *
    `;
    const result = await pool.query(query, queryParams);
    console.log(`แก้ไขข้อมูลบันทึกขยะสำเร็จ ID: ${params.id}`);
    notifyClients("update", result.rows[0]);
    return {
      success: true,
      message: "แก้ไขข้อมูลบันทึกขยะสำเร็จ",
      data: result.rows[0]
    };
  } catch (error3) {
    console.error(`เกิดข้อผิดพลาดในการแก้ไขข้อมูลบันทึกขยะ ID: ${params.id}:`, error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการแก้ไขข้อมูลบันทึกขยะ" };
  }
};
var deleteWasteRecord = async ({
  params,
  cookie: cookie8,
  jwt: jwt2,
  set: set2
}) => {
  console.log(`กำลังลบข้อมูลบันทึกขยะ ID: ${params.id}`);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie8, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userRole = authResult.role;
    const userId = authResult.userId;
    const checkQuery = `
      SELECT id, user_id FROM waste_records WHERE id = $1
    `;
    const checkResult = await pool.query(checkQuery, [params.id]);
    if (checkResult.rows.length === 0) {
      set2.status = 404;
      return { success: false, message: "ไม่พบข้อมูลบันทึกขยะ" };
    }
    if (userRole !== "admin" && checkResult.rows[0].user_id !== userId) {
      set2.status = 403;
      return { success: false, message: "คุณไม่มีสิทธิ์ลบข้อมูลนี้" };
    }
    await pool.query("DELETE FROM waste_records WHERE id = $1", [params.id]);
    console.log(`ลบข้อมูลบันทึกขยะสำเร็จ ID: ${params.id}`);
    notifyClients("delete", { id: parseInt(params.id) });
    return {
      success: true,
      message: "ลบข้อมูลบันทึกขยะสำเร็จ"
    };
  } catch (error3) {
    console.error(`เกิดข้อผิดพลาดในการลบข้อมูลบันทึกขยะ ID: ${params.id}:`, error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการลบข้อมูลบันทึกขยะ" };
  }
};

// src/routes/routes-waste/routes.waste.ts
var wasteRecordController = new Elysia({ prefix: "/api/waste/records" }).use(import_cookie9.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).get("/", getWasteRecords).get("/:id", getWasteRecordById).post("/", addWasteRecord).put("/:id", updateWasteRecord).delete("/:id", deleteWasteRecord);

// src/routes/routes-waste/routes.wasteType.ts
var import_cookie10 = __toESM(require_cjs4(), 1);

// src/controllers/controllers-waste/wasteType.controller.ts
var getWasteTypes = async ({ query, cookie: cookie9, jwt: jwt2, set: set2 }) => {
  console.log("กำลังดึงข้อมูลประเภทขยะทั้งหมด");
  try {
    const authResult = await verifyAuthToken({ cookie: cookie9, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const page = query.page ? parseInt(query.page) : null;
    const pageSize = query.pageSize ? parseInt(query.pageSize) : null;
    let sqlQuery = `
      SELECT * FROM waste_types
      ORDER BY name ASC
    `;
    let countQuery = `SELECT COUNT(*) as total FROM waste_types`;
    let queryParams = [];
    if (page !== null && pageSize !== null) {
      const offset = (page - 1) * pageSize;
      sqlQuery += ` LIMIT $1 OFFSET $2`;
      queryParams = [pageSize, offset];
    }
    const result = await pool.query(sqlQuery, queryParams);
    let total = result.rows.length;
    if (page !== null && pageSize !== null) {
      const countResult = await pool.query(countQuery);
      total = parseInt(countResult.rows[0].total);
    }
    console.log(`ดึงข้อมูลประเภทขยะสำเร็จ: ${result.rows.length} รายการ`);
    return {
      success: true,
      data: result.rows,
      total,
      ...page !== null && pageSize !== null ? {
        page,
        pageSize,
        totalPages: Math.ceil(total / pageSize)
      } : {}
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการดึงข้อมูลประเภทขยะ:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการดึงข้อมูลประเภทขยะ" };
  }
};
var addWasteType = async ({ body, cookie: cookie9, jwt: jwt2, set: set2 }) => {
  console.log("กำลังเพิ่มประเภทขยะใหม่:", body);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie9, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userRole = authResult.role;
    if (userRole !== "admin") {
      set2.status = 403;
      return { success: false, message: "คุณไม่มีสิทธิ์เพิ่มประเภทขยะ" };
    }
    if (!body.name) {
      set2.status = 400;
      return { success: false, message: "กรุณาระบุชื่อประเภทขยะ" };
    }
    const checkDuplicate = await pool.query(`
      SELECT id FROM waste_types WHERE name = $1
    `, [body.name]);
    if (checkDuplicate.rows.length > 0) {
      set2.status = 400;
      return { success: false, message: "ชื่อประเภทขยะนี้มีอยู่ในระบบแล้ว" };
    }
    const result = await pool.query(`
      INSERT INTO waste_types (name, description)
      VALUES ($1, $2)
      RETURNING *
    `, [body.name, body.description || null]);
    console.log(`เพิ่มประเภทขยะสำเร็จ: ID ${result.rows[0].id}`);
    notifyClients("waste_type_added", result.rows[0]);
    return {
      success: true,
      message: "เพิ่มประเภทขยะสำเร็จ",
      data: result.rows[0]
    };
  } catch (error3) {
    console.error("เกิดข้อผิดพลาดในการเพิ่มประเภทขยะ:", error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการเพิ่มประเภทขยะ" };
  }
};
var updateWasteType = async ({ params, body, cookie: cookie9, jwt: jwt2, set: set2 }) => {
  console.log(`กำลังแก้ไขประเภทขยะ ID: ${params.id}`, body);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie9, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userRole = authResult.role;
    if (userRole !== "admin") {
      set2.status = 403;
      return { success: false, message: "คุณไม่มีสิทธิ์แก้ไขประเภทขยะ" };
    }
    const checkExists = await pool.query(`
      SELECT id FROM waste_types WHERE id = $1
    `, [params.id]);
    if (checkExists.rows.length === 0) {
      set2.status = 404;
      return { success: false, message: "ไม่พบข้อมูลประเภทขยะ" };
    }
    if (body.name) {
      const checkDuplicate = await pool.query(`
        SELECT id FROM waste_types WHERE name = $1 AND id != $2
      `, [body.name, params.id]);
      if (checkDuplicate.rows.length > 0) {
        set2.status = 400;
        return { success: false, message: "ชื่อประเภทขยะนี้มีอยู่ในระบบแล้ว" };
      }
    }
    let updateFields = [];
    let queryParams = [];
    let index = 1;
    if (body.name !== undefined) {
      updateFields.push(`name = $${index++}`);
      queryParams.push(body.name);
    }
    if (body.description !== undefined) {
      updateFields.push(`description = $${index++}`);
      queryParams.push(body.description);
    }
    if (updateFields.length === 0) {
      return {
        success: false,
        message: "ไม่มีข้อมูลที่ต้องการแก้ไข"
      };
    }
    queryParams.push(params.id);
    const query = `
      UPDATE waste_types
      SET ${updateFields.join(", ")}
      WHERE id = $${index}
      RETURNING *
    `;
    const result = await pool.query(query, queryParams);
    console.log(`แก้ไขประเภทขยะสำเร็จ ID: ${params.id}`);
    notifyClients("waste_type_updated", result.rows[0]);
    return {
      success: true,
      message: "แก้ไขประเภทขยะสำเร็จ",
      data: result.rows[0]
    };
  } catch (error3) {
    console.error(`เกิดข้อผิดพลาดในการแก้ไขประเภทขยะ ID: ${params.id}:`, error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการแก้ไขประเภทขยะ" };
  }
};
var deleteWasteType = async ({ params, cookie: cookie9, jwt: jwt2, set: set2 }) => {
  console.log(`กำลังลบประเภทขยะ ID: ${params.id}`);
  try {
    const authResult = await verifyAuthToken({ cookie: cookie9, jwt: jwt2, set: set2 });
    if (!authResult.authorized) {
      return { success: false, message: authResult.message };
    }
    const userRole = authResult.role;
    if (userRole !== "admin") {
      set2.status = 403;
      return { success: false, message: "คุณไม่มีสิทธิ์ลบประเภทขยะ" };
    }
    const checkUsage2 = await pool.query(`
      SELECT id FROM waste_records WHERE waste_type_id = $1 LIMIT 1
    `, [params.id]);
    if (checkUsage2.rows.length > 0) {
      set2.status = 400;
      return {
        success: false,
        message: "ไม่สามารถลบประเภทขยะนี้ได้ เนื่องจากมีการใช้งานอยู่ กรุณาลบข้อมูลบันทึกขยะที่เกี่ยวข้องก่อน"
      };
    }
    const checkExists = await pool.query(`
      SELECT id FROM waste_types WHERE id = $1
    `, [params.id]);
    if (checkExists.rows.length === 0) {
      set2.status = 404;
      return { success: false, message: "ไม่พบข้อมูลประเภทขยะ" };
    }
    await pool.query("DELETE FROM waste_types WHERE id = $1", [params.id]);
    console.log(`ลบประเภทขยะสำเร็จ ID: ${params.id}`);
    notifyClients("waste_type_deleted", { id: parseInt(params.id) });
    return {
      success: true,
      message: "ลบประเภทขยะสำเร็จ"
    };
  } catch (error3) {
    console.error(`เกิดข้อผิดพลาดในการลบประเภทขยะ ID: ${params.id}:`, error3);
    set2.status = 500;
    return { success: false, message: "เกิดข้อผิดพลาดในการลบประเภทขยะ" };
  }
};

// src/routes/routes-waste/routes.wasteType.ts
var wasteTypeController = new Elysia({ prefix: "/api/waste/types" }).use(import_cookie10.cookie()).use(jwt({
  name: "jwt",
  secret: authConfig.jwt.secret,
  expiresIn: authConfig.jwt.expiresIn
})).get("/", getWasteTypes).post("/", addWasteType).put("/:id", updateWasteType).delete("/:id", deleteWasteType);

// src/routes/routes.data.events.ts
var dataEventsController = new Elysia().get("/api/data-events", createDataEventStream);

// server.ts
var __dirname = "D:\\PROJECT\\WEB_APP\\04-ENVIROMENTS";
import_dotenv4.default.config({
  path: join5(__dirname, ".env")
});
console.log("กำลังสร้าง Elysia app instance...");
var app = new Elysia;
console.log("กำลังตั้งค่า plugins พื้นฐาน...");
console.log("กำลังเพิ่ม middleware และ routes หลัก...");
app.use(staticPlugin({
  assets: "public",
  prefix: "/static"
})).use(authController).use(authRoutesProvider).use(mainRoutes).use(protectedRoutes).use(staticRoutes).use(fallbackRoutes);
console.log("กำลังเพิ่ม controllers ระบบบำบัดน้ำ...");
app.use(dashboardController).use(environmentalController).use(addEnvironmentalDataController).use(equipmentStatusController);
console.log("กำลังเพิ่ม controllers ระบบจัดการขยะ...");
app.use(dashboardWasteController).use(wasteRecordController).use(wasteTypeController);
console.log("กำลังเพิ่ม data events controller (SSE)...");
app.use(dataEventsController);
console.log("กำลังเริ่มต้น server...");
app.listen({
  port: process.env.PORT || 3100,
  idleTimeout: 255
});
console.log(`Server is running on http://localhost:${app.server?.port}`);
console.log("กำลังทดสอบการเชื่อมต่อกับฐานข้อมูล...");
pool.connect((err, client, release) => {
  if (err) {
    console.error("Error connecting to the database:", err);
    return;
  }
  console.log("เชื่อมต่อกับฐานข้อมูลสำเร็จ");
  release();
});
